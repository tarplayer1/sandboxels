//aircrafts
elements.bomb.ignore = ["super_bomber_left","super_bomber_right"],
elements.fast_bullet_left = {
    color: "#4c4e42",
    behavior: [
        "XX|DL|XX",
        "XX|XX|XX",
        "XX|DL|XX",
    ],
tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-3, pixel.y)) {
                if (!isEmpty(pixel.x-3, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x-3][pixel.y];
                    if (newPixel.element === "fast_bullet_left") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "ammunition",
    state: "solid",
    insulate: true,
},
elements.fast_bullet_right = {
    color: "#4c4e42",
    behavior: [
        "XX|DL|XX",
        "XX|XX|XX",
        "XX|DL|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+3, pixel.y)) {
                if (!isEmpty(pixel.x+3, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x+3][pixel.y];
                    if (newPixel.element === "fast_bullet_right") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "ammunition",
    state: "solid",
    insulate: true,
},
elements.flak_cannon = {
    color: "#C0C0C0",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|CR:flak|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    conduct: 1,
},
    elements.flak = {
    color: "#f0f0f0",
    tick: function(pixel) {
        if ((pixel.temp > 10 || pixel.charge) && !pixel.burning) {
            pixel.burning = true;
            pixel.burnStart = pixelTicks;
        }
        if (pixel.burning) {
            if (!tryMove(pixel, pixel.x, pixel.y-1)) {
                // tryMove again to the top left or top right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y-1);
            }
            if (pixelTicks-pixel.burnStart > 50 && Math.random() < 0.005) {
                explodeAt(pixel.x, pixel.y, 10, "flak_shrapnel");
            }
        }
        else {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                // tryMove again to the bottom left or bottom right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y+1);
            }
        }
        doDefaults(pixel);
    },
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "ammunition"
},
    elements.flak_shrapnel = {
    color: "#71797E",
       behavior: [
        "XX|XX|XX",
        "XX|EX:5 %10|XX",
        "M2|M1|M2",
    ],
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "ammunition"
},
elements.fighter_jet_left = {
    color: "#bcc6cc",
    behavior: [
        "M1%0.2|M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap",
        "M1 AND CR:fast_bullet_left|XX|CR:smoke AND EX:5>metal_scrap",
        "M1%0.2|M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap",
    ],
tick: function(pixel) {
    for (var i=0; i<2; i++) {
            if (!tryMove(pixel, pixel.x-1, pixel.y)) {
                if (!isEmpty(pixel.x-1, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x-1][pixel.y];
                    if (newPixel.element === "fast_bullet_left") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "aircrafts",
    breakInto: "metal_scrap"
 },
elements.fighter_jet_right = {
    color: "#bcc6cc",
    behavior: [
        "M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap|M1%0.2",
        "CR:smoke AND EX:5>metal_scrap|XX|M1 AND CR:fast_bullet_right",
        "M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap|M1%0.2",
    ],
tick: function(pixel) {
    for (var i=0; i<2; i++) {
            if (!tryMove(pixel, pixel.x+1, pixel.y)) {
                if (!isEmpty(pixel.x+1, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x+1][pixel.y];
                    if (newPixel.element === "fast_bullet_right") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "aircrafts",
    breakInto: "metal_scrap"
 },
elements.airliner_left = {
    color: "#fafafa",
    category: "aircrafts",
    behavior: [
        "M1%3 AND EX:7>fire,fire,fire,metal_scrap|XX|XX",
        "M1 AND EX:7>fire,fire,fire,metal_scrap|XX|XX",
        "M1%3 AND EX:7>fire,fire,fire,metal_scrap|XX|CR:smoke%10",
    ],
    burnTime: 1000,
    burn: 40,
    burnInto: "metal_scrap",
    breakInto: "metal_scrap",
    conduct: 1
},
elements.airliner_right = {
    color: "#fafafa",
    category: "aircrafts",
    behavior: [
        "XX|XX|M1%3 AND EX:7>fire,fire,fire,metal_scrap",
        "XX|XX|M1 AND EX:7>fire,fire,fire,metal_scrap",
        "CR:smoke%10|XX|M1%3 AND EX:7>fire,fire,fire,metal_scrap",
    ],
    burnTime: 1000,
    burn: 40,
    burnInto: "metal_scrap",
    breakInto: "metal_scrap",
    conduct: 1
},
elements.bomber_left = {
    color: "#fafafa",
    category: "aircrafts",
    behavior: [
        "M1%3 AND EX:7>fire,fire,fire,metal_scrap|XX|XX",
        "M1 AND EX:7>fire,fire,fire,metal_scrap|XX|XX",
        "M1%3 AND EX:7>fire,fire,fire,metal_scrap|XX|CR:smoke%10 AND CR:bomb",
    ],
    burnTime: 1000,
    burn: 40,
    burnInto: "metal_scrap",
    breakInto: "metal_scrap",
    conduct: 1
},
elements.bomber_right = {
    color: "#fafafa",
    category: "aircrafts",
    behavior: [
        "XX|XX|M1%3 AND EX:7>fire,fire,fire,metal_scrap",
        "XX|XX|M1 AND EX:7>fire,fire,fire,metal_scrap",
        "CR:smoke%10 AND CR:bomb|XX|M1%3 AND EX:7>fire,fire,fire,metal_scrap",
    ],
    burnTime: 1000,
    burn: 40,
    burnInto: "metal_scrap",
    breakInto: "metal_scrap",
    conduct: 1
},
elements.super_bomber_left = {
    color: "#000000",
    category: "aircrafts",
    behavior: [
        "XX|XX|XX",
        "M1%3 AND EX:7>fire,fire,fire,metal_scrap|XX|XX",
        "M1 AND EX:7>fire,fire,fire,metal_scrap|XX|XX",
        "M1%3 AND CR:bomb|CR:bomb|CR:smoke%10 AND CR:bomb",
        "CR:bomb|CR:bomb|CR:bomb",  
    ],
    ignore: "bomb",
    burnTime: 1000,
    burn: 40,
    burnInto: "metal_scrap",
    breakInto: "metal_scrap",
    conduct: 1
},
elements.super_bomber_right = {
    color: "#000000",
    category: "aircrafts",
    behavior: [
        "XX|XX|XX",
        "XX|XX|M1%3 AND EX:7>fire,fire,fire,metal_scrap",
        "XX|XX|M1 AND EX:7>fire,fire,fire,metal_scrap",
        "CR:smoke%10 AND CR:bomb|CR:bomb|M1%3 AND CR:bomb",
        "CR:bomb|CR:bomb|CR:bomb",  
    ],
    ignore: "bomb",
    burnTime: 1000,
    burn: 40,
    burnInto: "metal_scrap",
    breakInto: "metal_scrap",
    conduct: 1
}
document.onkeydown = function(ki)/*keyboard_input*/ {
    //a
    if (ki.keyCode == 65) {
        KA = true;
    }
    //d
    if (ki.keyCode == 68) {
        KD = true;
    }
    //w
    if (ki.keyCode == 87) {
        KW = true;
    }
    //s
    if (ki.keyCode == 83) {
        KS = true;
    }
    if (ki.keyCode == 86) {
        KJ = true;
    }
    if (ki.keyCode == 78) {
        KL = true;
    }
    if (ki.keyCode == 71) {
        KI = true;
    }
    if (ki.keyCode == 66) {
        KK = true;
    }
    if (ki.keyCode == 81) {
        KQ = true;
    }
    if (ki.keyCode == 90) {
        ammo = 300;
        missile = 20;
    }
}
document.onkeyup = function(i2)/*input 2*/ {
    //a
    if (i2.keyCode == 65) {
        KA = false;
        ul = false;
        dl = false;
    }
    //d
    if (i2.keyCode == 68) {
        KD = false;
        ur = false;
        dr = false;
    }
    //w
    if (i2.keyCode == 87) {
        KW = false;
        ul = false;
        ur = false;
    }
    //s
    if (i2.keyCode == 83) {
        KS = false;
        dl = false;
        dr = false;
    }
    if (i2.keyCode == 86) {
        KJ = false;
    }
    if (i2.keyCode == 78) {
        KL = false;
    }
    if (i2.keyCode == 71) {
        KI = false;
    }
    if (i2.keyCode == 66) {
        KK = false;
    }
    if (i2.keyCode == 81) {
        KQ = false;
    }
}
var KA = false;
var KD = false;
var KW = false;
var KS = false;
var KJ = false;
var KL = false;
var KI = false;
var KK = false;
var KQ = false;
var vX = 2;
var vY = 2;
var ul = false;
var ur = false;
var dl = false;
var dr = false;
var ammo = 300;
var missile = 20;
elements.cfj = {
    name: "c_fighter_jet",
    tick: function(pixel) {
    logMessage("|");
    logMessage("|[Callsign: Box 1]");
    logMessage("|[Codename: 'Player]'");
    logMessage("|");
    logMessage("|[Operation: 'Sandbox']");
    logMessage("|['Box Squadron']");
    logMessage("|");
    logMessage("|[Ammo:" + ammo +"]");
    logMessage("|[Missiles:" + missile +"]");
    logMessage("|");
    if (KA === true) {
            tryMove (pixel,pixel.x-vX,pixel.y)
        }
    if (KD === true) {
            tryMove (pixel,pixel.x+vX,pixel.y)
        }
    if (KW === true) {
            tryMove (pixel,pixel.x,pixel.y-vY)
        }
    if (KS === true) {
            tryMove (pixel,pixel.x,pixel.y+vY)
        }
    if (KJ === true && missile > 0) {
            createPixel("cfj_missile_left",pixel.x-1,pixel.y);
            missile--;
        }
    if (KL === true && missile > 0) {
            createPixel("cfj_missile_right",pixel.x+1,pixel.y);
            missile--;
        }
    if (KI === true && missile > 0) {
            createPixel("cfj_missile_up",pixel.x,pixel.y-1);
            missile--;
        }
    if (KK === true && missile > 0) {
            createPixel("cfj_missile_down",pixel.x,pixel.y+1);
            missile--;
        }
    if (KQ === true) {
         if (KA === true && dl === false && ul === false && ammo > 0) {
            createPixel("cfj_b_l",pixel.x-4,pixel.y);
            ammo--;
             }
        if (KD === true && dr === false && ur === false && ammo > 0) {
            createPixel("cfj_b_r",pixel.x+4,pixel.y);
            ammo--;
             }
        if (KW === true && ul === false && ur === false && ammo > 0) {
            createPixel("cfj_b_u",pixel.x,pixel.y-4);
            ammo--;
             }
        if (KS === true && dl === false && dr === false && ammo > 0) {
            createPixel("cfj_b_d",pixel.x,pixel.y+4);
            ammo--;
             }
         if (KA === true && KW === true && ammo > 0) {
            createPixel("cfj_b_ul",pixel.x-4,pixel.y-4);
             ul = true;
             ammo--;
             }
        if (KD === true && KW === true && ammo > 0) {
            createPixel("cfj_b_ur",pixel.x+4,pixel.y-4);
            ur = true;
            ammo--;
             }
        if (KA === true && KS === true && ammo > 0) {
            createPixel("cfj_b_dl",pixel.x-4,pixel.y-4);
            dl = true;
            ammo--;
             }
        if (KD === true && KS === true && ammo > 0) {
            createPixel("cfj_b_dr",pixel.x+4,pixel.y+4);
            dr = true;
            ammo--;
             }
        }
    },
    category: "cfj",
    states:"solid",
    color:"#FFFFFF",
},
elements.cfj_missile_left = {
    color: "#524c41",
    category: "cfj",
    state: "solid",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M1|XX|EX:20>missile_shrapnel|CR:smoke AND EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-1, pixel.y)) {
                if (!isEmpty(pixel.x-1, pixel.y,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown,
    ignore: "cfj",
},
elements.cfj_missile_right = {
    color: "#524c41",
    category: "cfj",
    state: "solid",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|CR:smoke AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX|M1|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+1, pixel.y)) {
                if (!isEmpty(pixel.x+1, pixel.y,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown,
    ignore: "cfj",
},
elements.cfj_missile_up = {
    color: "#524c41",
    category: "cfj",
    state: "solid",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|M1 AND EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|CR:smoke AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x, pixel.y-1)) {
                if (!isEmpty(pixel.x, pixel.y-1,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown,
    ignore: "cfj",
},
elements.cfj_missile_down = {
    color: "#524c41",
    category: "cfj",
    state: "solid",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|CR:smoke AND EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX||EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|M1 AND EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                if (!isEmpty(pixel.x, pixel.y+1,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown,
    ignore: "cfj",
},
elements.missile_shrapnel = {
    color: "#71797E",
       behavior: [
        "XX|XX|XX",
        "XX|EX:5 %20|XX",
        "M2%20|M1%20|M2%20",
    ],
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "ammunition"
},
elements.cfj_b_l = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-3, pixel.y)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_r = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+3, pixel.y)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_u = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x, pixel.y-3)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_d = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x, pixel.y+3)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_ul = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-3, pixel.y-3)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_dl = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-3, pixel.y+3)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_ur = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+3, pixel.y-3)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
},
elements.cfj_b_dr = {
    color: "#4c4e42",
    behavior: [
        "DB|DB|DB",
        "DB|XX|DB",
        "DB|DB|DB",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+3, pixel.y+3)) {
                deletePixel(pixel.x,pixel.y)
                }
            }
    },
    category: "cfj",
    state: "solid",
    insulate: true,
    ignore: "cfj",
}
// from code_libary.js
function pyth(xA, yA, xB, yB) {
    var a = Math.abs(xB - xA);
    var b = Math.abs(yB - yA);
    var c = Math.sqrt(a ** 2 + b ** 2);
    return c;
};
tgt = ""

elements.guided_misile = {
    color: "#323333",
    category: "weapons",
    behavior: [
        "EX:10|EX:10|EX:10",
        "EX:10|  XX |EX:10",
        "EX:10|EX:10|EX:10",
    ],
    onSelect: function () {
        var answer1 = prompt("Please input the target element.", (tgt || undefined));
        if (!answer1) { return }
        tgt = answer1;
    },
    tick: (pixel) => {
        let targets = [];

        // find all posible targets
        for (var x = 1; x < width; x++) {
            for (var y = 1; y < height; y++) {
                if (!isEmpty(x, y)) {
                    if (pixelMap[x][y]["element"] === tgt) {
                        pxl = pixelMap[x][y];
                        targets.push(
                            [pxl.x, pxl.y,
                            // calculate distance from target to current pixel
                            pyth(pixel.x, pixel.y, pxl.x, pxl.y)
                            ]);
                    }
                }
            }
        }

        if (targets == []) {
            return
        }

        // sort the targets by distance from self 
        targets.sort((a, b) => a[2] - b[2]);

        try {
            // get the closest target
            current_best = targets[0];

            target = [current_best[0], current_best[1]];
        } catch {
            // no pixels of target found
            return
        }

        if (pixel.x != target[0] || pixel.y != target[1]) {
            let { x, y } = pixel;
            const empty = checkForEmptyPixels(x, y);
            const [tX, tY] = target;

            // Separate moves into non-diagonal and diagonal categories
            const nonDiagonal = [];
            const diagonal = [];

            for (const [dx, dy] of empty) {
                if ((dx === 0) || (dy === 0)) {
                    nonDiagonal.push([dx, dy]); // Horizontal or vertical moves
                } else {
                    diagonal.push([dx, dy]);    // Diagonal moves
                }
            }

            let prioritizedMoves = []

            // chose whether to move diagonaly
            if (Math.abs(Math.abs(x - tX) - Math.abs(y - tY)) > 1) {
                prioritizedMoves = [...nonDiagonal];
            } else {
                prioritizedMoves = [...diagonal];
            }

            let bestVal = pyth(tX, tY, x, y)
            Math.sqrt(Math.pow(tX - x, 2) + Math.pow(tY - y, 2));
            let best = null;

            for (const [dx, dy] of prioritizedMoves) {
                const x_ = x + dx;
                const y_ = y + dy;
                const c = Math.sqrt(Math.pow(tX - x_, 2) + Math.pow(tY - y_, 2));
                if (c < bestVal) {
                    bestVal = c;
                    best = [dx, dy];
                }
            }

            if (best) {
                if (!tryMove(pixel, x + best[0] * 2, y + best[1] * 2, undefined, true)) {
                    tryMove(pixel, x + best[0], y + best[1], undefined, true)
                };
            }
        }
    }
}
for (var i = 3; i <= 15; i++) {
    elements[`cluster_bomb_${i}`] = {
        name: `${i}- cluster bomb`,
        color: "#7d776d",
        behavior: [
            `XX|EX:8>smoke,smoke,smoke,smoke,smoke,cluster_bomb_${i-1}%10|XX`,
            "XX|XX|XX",
            `M2|M1 AND EX:8>smoke,smoke,smoke,smoke,smoke,cluster_bomb_${i-1}%10|M2`,
        ],
        category: "weapons",
        state: "solid",
        density: 1300,
        tempHigh: 1455.5,
        stateHigh: "molten_steel",
        excludeRandom: true,
    }
}

elements.cluster_bomb_2 = {
    color: "#7d776d",
    behavior: [
        "XX|EX:8>smoke,smoke,smoke,smoke,smoke,cluster_bomb%10|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:8>smoke,smoke,smoke,smoke,smoke,cluster_bomb%10|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    excludeRandom: true,
}
var modName = "mods/fire_mod.js";
var libraryMod = "mods/code_library.js";

if(enabledMods.includes(libraryMod)) {
	/*	elements.iron.reactions.radiation =
		{elem1: 'dirty_water', elem2: null}
		when radiation touches iron,
		the iron turns into dirty_water (elem1)
		and the radiation deletes itself (elem2)

		elements.AAA.reactions.BBB:
		{elem1: CCC, elem2: DDD}
		when BBB touches AAA,
		the AAA becomes CCC
		and the BBB becomes DDD
	*/

	//	imaginary reaction elements.iron.reactions.test

	//Variable
	fireSpawnBlacklist = ["fire","cold_fire","rad_fire"];

	//doBurning
	function doBurning(pixel) {
		if (pixel.burning) { // Burning
			pixel.burnStart ??= pixelTicks;
			var info = elements[pixel.element];
			var burnTempChange = info.burnTempChange ?? 1;
			var fireIsCold;
			var fire = info.fireElement === undefined ? "fire" : info.fireElement; //allow null but disallow undefined
			//console.log(info.fireElement,fire);
			while(fire instanceof Array) {
				fire = fire[Math.floor(Math.random()*fire.length)];
			};
			var fireTemp = info.fireSpawnTemp ?? pixel.temp;
			var fireChance = info.fireSpawnChance ?? 10;
			var fireIsCold = (fire === "cold_fire");
			//var fireInfo = fire === null ? null : elements[fire];

			pixel.temp += burnTempChange;
			pixelTempCheck(pixel);
			
			for (var i = 0; i < adjacentCoords.length; i++) { // Burn adjacent pixels
				var x = pixel.x+adjacentCoords[i][0];
				var y = pixel.y+adjacentCoords[i][1];
				if (!isEmpty(x,y,true)) {
					var newPixel = pixelMap[x][y];
					var newInfo = elements[newPixel.element];
					var newFireIsCold;
					var newFire = newInfo.fireElement == undefined ? "fire" : newInfo.fireElement;
					while(newFire instanceof Array) {
						newFire = newFire[Math.floor(Math.random()*newFire.length)];
					};
					newFireIsCold = (newFire === "cold_fire");
					//console.log(`burning pixel ${pixel.element}: ${fire} (${fireIsCold}) / burned element ${newPixel.element}: ${newFire} (${newFireIsCold})`);
					if((!fireIsCold && !newFireIsCold) || (fireIsCold && newFireIsCold)) {
						if (elements[newPixel.element].burn && !newPixel.burning) {
							if (Math.floor(Math.random()*100) < elements[newPixel.element].burn) {
								newPixel.burning = true;
								newPixel.burnStart = pixelTicks;
							}
						}
					}
				}
			}

			if ((pixelTicks - pixel.burnStart > (info.burnTime || 200)) && Math.floor(Math.random()*100)<(info.burn || 10)) {
				var burnInto = info.burnInto ?? "fire";
				while(burnInto instanceof Array) {
					burnInto = burnInto[Math.floor(Math.random()*burnInto.length)];
				};
				changePixel(pixel,burnInto,burnInto !== "smoke");
				//console.log("ass");
				pixel.temp = fireTemp;
				if (info.fireColor != undefined && burnInto == "fire") {
					pixel.color = pixelColorPick(pixel,info.fireColor);
				}
				else {
					pixel.color = pixelColorPick(pixel)
				}
			}
			else if (Math.floor(Math.random()*100)<fireChance && !fireSpawnBlacklist.includes(pixel.element)) { // Spawn fire
				//console.log(fire);
				if (isEmpty(pixel.x,pixel.y-1)) {
					if(fire !== null) {
						createPixel(fire,pixel.x,pixel.y-1);
						pixelMap[pixel.x][pixel.y-1].temp = fireTemp;
						if (info.fireColor != undefined) {
							pixelMap[pixel.x][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x][pixel.y-1],info.fireColor);
						};
					};
				}
				// same for below if top is blocked
				else if (isEmpty(pixel.x,pixel.y+1)) {
					if(fire !== null) {
						createPixel(fire,pixel.x,pixel.y+1);
						pixelMap[pixel.x][pixel.y+1].temp = fireTemp;
						if (info.fireColor != undefined) {
							pixelMap[pixel.x][pixel.y+1].color = pixelColorPick(pixelMap[pixel.x][pixel.y+1],info.fireColor);
						};
					};
				}
			}
		}
	}

	//New elements

	elements.cold_fire.burning = true;
	elements.cold_fire.burnTempChange = -1;
	elements.cold_fire.burnTime = 25;
	elements.cold_fire.burnInto = "cold_smoke";
	elements.cold_fire.fireElement = "cold_fire";
	elements.cold_fire.behavior = [
		"M1|M1|M1",
		"M2|XX|M2",
		"XX|M2|XX"
	],

	elements.cold_smoke = {
		color: "#282848",
		behavior: behaviors.DGAS,
		reactions: {
			"steam": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"rain_cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"snow_cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"hail_cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"acid_cloud": { "elem1": "pyrocumulus", "chance":0.05, "y":[0,12], "setting":"clouds" },
			"fire_cloud": { "elem1": "pyrocumulus", "chance":0.05, "y":[0,12], "setting":"clouds" },
			"pyrocumulus": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
		},
		temp: -100,
		tempHigh: 0,
		stateHigh: "smoke",
		tempLow: -114,
		stateLow: "cold_fire",
		category: "gases",
		state: "gas",
		density: 1280,
		stain: 0.075,
	};

	elements.rad_fire = { //this is BBB
		color: ["#daff21","#a6ff00","#ffff00"],
		behavior: [
			"XX|CR:radiation%0.1|XX",
			"CR:radiation%0.1|XX|CR:radiation%0.1",
			"XX|CR:radiation%0.1|XX",
		],
		tick: function(pixel) {
			if(Math.random() < 0.4) {
				pixel.temp++;
			};
			
			if(Math.random() < 0.05) { //5%/t to radify
				if(typeof(transformAdjacent) === "function" && typeof(radioactiveObject) === "object") {
					transformAdjacent(pixel,radioactiveObject);
				};
			};
			
			var move1Spots = [[-1,-1],[0,-1],[1,-1]];
			var move2Spots = [[-1,0],[0,1],[1,0]];
			
			var randomMove1 = move1Spots[Math.floor(Math.random() * move1Spots.length)];
			
			if(!tryMove(pixel, pixel.x+randomMove1[0], pixel.y+randomMove1[1])) {
				//console.log((pixel.x+randomMove1[0]) + " " + (pixel.y+randomMove1[1]))
				var newPixel = null;
				if(!outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1])) {
					newPixel = pixelMap[pixel.x+randomMove1[0]][pixel.y+randomMove1[1]]; //newPixel is AAA
				};
				if(outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1]) || !reactionStealer(pixel,newPixel,"radiation")) {
					var randomMove2 = move2Spots[Math.floor(Math.random() * move2Spots.length)];
					if(!tryMove(pixel, pixel.x+randomMove2[0], pixel.y+randomMove2[1])) {
						var newPixel = null;
						if(!outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1])) {
							newPixel = pixelMap[pixel.x+randomMove1[0]][pixel.y+randomMove1[1]]; //newPixel is AAA
						};
						if(newPixel !== null) { reactionStealer(pixel,newPixel,"radiation") };
					};
				};
			};
			doDefaults(pixel);
		},
		reactions: { //fire + radiation reacts
			//Merged water-radiation reactions, plus altered seltzer
			"water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			"steam": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			"carbon_dioxide": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			"dirty_water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			"salt_water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			"sugar_water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			"seltzer": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
			//Radiation reactions added programatically
		},
		temp:800,
		tempLow:150,
		stateLow: "rad_smoke",
		//tempHigh: 7000,
		//stateHigh: "rad_plasma",
		category: "energy",
		burning: true,
		fireElement: "radiation",
		state: "gas",
		density: 0.1,
		ignoreAir: true,
	};

	elements.rad_smoke = {
		color: "#415c25",
		behavior: behaviors.DGAS,
		behavior: [
			"XX|CR:radiation%0.05|XX",
			"CR:radiation%0.05|XX|CR:radiation%0.05",
			"XX|CR:radiation%0.05|XX",
		],
		tick: function(pixel) {
			if(Math.random() < 0.05) {
				deletePixel(pixel.x,pixel.y);
				return;
			};
			
			if(Math.random() < 0.2) {
				pixel.temp++;
			};
			
			if(Math.random() < 0.04) { //4%/t to radify
				if(typeof(transformAdjacent) === "function" && typeof(radioactiveObject) === "object") {
					transformAdjacent(pixel,radioactiveObject);
				};
			};

			var move1Spots = [[0,-1],[1,0],[0,1],[-1,0]];
			var move2Spots = [[-1,-1],[1,-1],[1,1],[-1,1]];
			
			var randomMove1 = move1Spots[Math.floor(Math.random() * move1Spots.length)];
			if(!tryMove(pixel, pixel.x+randomMove1[0], pixel.y+randomMove1[1])) {
				//console.log((pixel.x+randomMove1[0]) + " " + (pixel.y+randomMove1[1]))
				var newPixel = null;
				if(!outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1])) {
					newPixel = pixelMap[pixel.x+randomMove1[0]][pixel.y+randomMove1[1]]; //newPixel is AAA
				};
				if(outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1]) || !reactionStealer(pixel,newPixel,"radiation")) {
					var randomMove2 = move2Spots[Math.floor(Math.random() * move2Spots.length)];
					if(!tryMove(pixel, pixel.x+randomMove2[0], pixel.y+randomMove2[1])) {
						var newPixel = null;
						if(!outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1])) {
							newPixel = pixelMap[pixel.x+randomMove1[0]][pixel.y+randomMove1[1]]; //newPixel is AAA
						};
						if(newPixel !== null) { reactionStealer(pixel,newPixel,"radiation") };
					};
				};
			};
			doDefaults(pixel);
		},
		reactions: {
			//Spreading
			"liquid_fire": { "elem2":"liquid_rad_fire", "chance":0.2 },
			"fire": { "elem2":"rad_fire", "chance":0.2 },
			"smoke": { "elem2":"rad_smoke", "chance":0.2 },
			/*"steam": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"rain_cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"snow_cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"hail_cloud": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },
			"acid_cloud": { "elem1": "pyrocumulus", "chance":0.05, "y":[0,12], "setting":"clouds" },
			"fire_cloud": { "elem1": "pyrocumulus", "chance":0.05, "y":[0,12], "setting":"clouds" },
			"pyrocumulus": { "elem1": "pyrocumulus", "chance":0.08, "y":[0,12], "setting":"clouds" },*/
			//Radiation reactions added programatically
		},
		temp: 134,
		tempHigh: 595,
		stateHigh: "rad_fire",
		category: "gases",
		state: "gas",
		density: 1340,
		stain: 0.075,
	};

	elements.cold_torch = {
		"color": "#4394d6",
		"behavior": [
			"XX|CR:cold_fire|XX",
			"XX|XX|XX",
			"XX|XX|XX"
		],
		"reactions": {
			"water": { "elem1": "wood" },
			"sugar_water": { "elem1": "wood" },
			"salt_water": { "elem1": "wood" },
			"seltzer": { "elem1": "wood" },
			"dirty_water": { "elem1": "wood" },
			"pool_water": { "elem1": "wood" },
			"steam": { "elem1": "wood" },
			"smog": { "elem1": "wood" },
			"rain_cloud": { "elem1": "wood" },
			"cloud": { "elem1": "wood" },
			"snow_cloud": { "elem1": "wood" },
			"hail_cloud": { "elem1": "wood" },
			"black_damp": { "elem1": "wood" }
		},
		"temp": -200,
		"category": "special",
		"breakInto": "sawdust",
		"tempHigh": 600,
		"stateHigh": "wood",
	};

	elements.rad_torch = {
		"color": "#85d643",
		"behavior": [
			"XX|CR:rad_fire|XX",
			"XX|XX|XX",
			"XX|XX|XX"
		],
		"reactions": {
			"water": { "elem1": "wood" },
			"sugar_water": { "elem1": "wood" },
			"salt_water": { "elem1": "wood" },
			"seltzer": { "elem1": "wood" },
			"dirty_water": { "elem1": "wood" },
			"pool_water": { "elem1": "wood" },
			"steam": { "elem1": "wood" },
			"smog": { "elem1": "wood" },
			"rain_cloud": { "elem1": "wood" },
			"cloud": { "elem1": "wood" },
			"snow_cloud": { "elem1": "wood" },
			"hail_cloud": { "elem1": "wood" },
			"black_damp": { "elem1": "wood" }
		},
		"temp": 800,
		"category": "special",
		"breakInto": "sawdust",
		"tempLow": -273,
		"stateHigh": "wood",
	};

	elements.napalm = {
		color: "#e0873e",
		behavior: [
			"XX|SA%40 AND ST|XX",
			"M2%10 AND SA%40 AND ST|XX|M2%10 AND SA%40 AND ST",
			"M2%50 AND M1%10|M1 AND SA%40 AND ST|M2%50 AND M1%10"
		],
		category: "weapons",
		state: "liquid",
		viscosity: 1000,
		density: 1200, //google was f***ing useless and i'm not searching that again, so arbitrary 1.2 it is
		burnTempChange: 3,
		burn: 300,
		burnTime: 500,
		temp: airTemp,
	},

	elements.hypernapalm = {
		name: "h y p e r n a p a l m", //HYPERNAPALM
		color: "#bd34eb",
		behavior: [
			"XX|SA%40 AND ST|XX",
			"M2%10 AND SA%40 AND ST|XX|M2%10 AND SA%40 AND ST",
			"M2%50 AND M1%10|M1 AND SA%40 AND ST|M2%50 AND M1%10"
		],
		category: "weapons",
		state: "liquid",
		viscosity: 1000,
		density: 1200,
		fireElement: "plasma",
		fireSpawnChance: 33,
		fireSpawnTemp: 7200,
		burnTempChange: 30,
		burn: 300,
		burnTime: 500,
	},

	elements.cold_napalm = {
		color: "#3e87e0",
		behavior: [
			"XX|SA%40 AND ST|XX",
			"M2%10 AND SA%40 AND ST|XX|M2%10 AND SA%40 AND ST",
			"M2%50 AND M1%10|M1 AND SA%40 AND ST|M2%50 AND M1%10"
		],
		category: "weapons",
		state: "liquid",
		viscosity: 1000,
		density: 1200,
		burn: 300,
		burnTime: 500,
		fireElement: "cold_fire",
		burnTempChange: -1,
		burnInto: "cold_fire",
	}

	elements.rad_napalm = {
		color: "#cdf760",
		behavior: [
			"XX|SA%40 AND ST AND CR:radiation%1|XX",
			"M2%10 AND SA%40 AND ST AND CR:radiation%1|HT%2.5|M2%10 AND SA%40 AND ST AND CR:radiation%1",
			"M2%50 AND M1%10|M1 AND SA%40 AND ST AND CR:radiation%1|M2%50 AND M1%10"
		],
		category: "weapons",
		state: "liquid",
		viscosity: 1000,
		density: 1300,
		burnTempChange: 2,
		burn: 300,
		burnTime: 500,
		fireElement: "rad_fire",
		temp: airTemp,
		burnInto: "rad_fire",
	},

	runAfterLoad(function() {
		if(eLists.spout) {
			eLists.spout.push("cold_torch");
			eLists.spout.push("rad_torch");
		};

		if(enabledMods.includes("mods/liquid_energy.js")) {
			elements.liquid_fire = {
				color: ["#ff6b21","#ffa600","#ff4000"],
				behavior: [
				"XX|M2|XX",
				"M2|XX|M2",
				"M1|M1|M1",
				],
				reactions: {
					"water": { "elem1": "liquid_smoke" },
				},
				temp:600,
				tempLow:100,
				stateLow: "liquid_smoke",
				tempHigh: 7000,
				stateHigh: "liquid_plasma",
				category: "energy liquids",
				burning: true,
				burnTime: Infinity,
				burnTempChange: 2,
				fireSpawnChance: 5,
				state: "liquid",
				density: 21,
			};

			elements.liquid_cold_fire = {
				color: ["#21cbff","#006aff","#00ffff"],
				behavior: [
					"XX|M2|XX",
					"M2|XX|M2",
					"M1|M1|M1",
				],
				reactions: {
					"fire": { "elem1": "liquid_smoke", "elem2": "liquid_smoke" },
					"plasma": { "elem1": "le_liquid_light", "elem2": "le_liquid_light" }, //prefixed to avoid conflict with F&M liquid_light
				},
				temp:-200,
				tempHigh:0,
				stateHigh: "liquid_smoke",
				burning: true,
				burnTempChange: -2,
				fireSpawnChance: 5,
				burnTime: Infinity,
				fireElement: "cold_fire",
				category: "energy liquids",
				state: "liquid",
				density: 42,
			};

			elements.liquid_rad_fire = {
				color: ["#daff21","#a6ff00","#ffff00"],
				behavior: [
					"XX|CR:radiation%0.1|XX",
					"CR:radiation%0.1|XX|CR:radiation%0.1",
					"XX|CR:radiation%0.1|XX",
				],
				tick: function(pixel) {
					if(Math.random() < 0.4) {
						pixel.temp++;
					};
					
					if(Math.random() < 0.06) { //6%/t to radify
						if(typeof(transformAdjacent) === "function" && typeof(radioactiveObject) === "object") {
							transformAdjacent(pixel,radioactiveObject);
						};
					};
			
					var move1Spots = [[-1,1],[0,1],[1,1]];
					var move2Spots = [[-1,0],[0,-1],[1,0]];
					
					var randomMove1 = move1Spots[Math.floor(Math.random() * move1Spots.length)];
					if(!tryMove(pixel, pixel.x+randomMove1[0], pixel.y+randomMove1[1])) {
						//console.log((pixel.x+randomMove1[0]) + " " + (pixel.y+randomMove1[1]))
						var newPixel = null;
						if(!outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1])) {
							newPixel = pixelMap[pixel.x+randomMove1[0]][pixel.y+randomMove1[1]]; //newPixel is AAA
						};
						if(outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1]) || !reactionStealer(pixel,newPixel,"radiation")) {
							var randomMove2 = move2Spots[Math.floor(Math.random() * move2Spots.length)];
							if(!tryMove(pixel, pixel.x+randomMove2[0], pixel.y+randomMove2[1])) {
								var newPixel = null;
								if(!outOfBounds(pixel.x+randomMove1[0],pixel.y+randomMove1[1])) {
									newPixel = pixelMap[pixel.x+randomMove1[0]][pixel.y+randomMove1[1]]; //newPixel is AAA
								};
								if(newPixel !== null) { reactionStealer(pixel,newPixel,"radiation") };
							};
						};
					};
					doDefaults(pixel);
				},
				reactions: { //fire + radiation reacts
					//Merged water-radiation reactions, plus altered seltzer
					"water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					"steam": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					"carbon_dioxide": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					"dirty_water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					"salt_water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					"sugar_water": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					"seltzer": { "elem1": "rad_smoke", "elem2":"rad_steam", "chance":0.4 },
					//Radiation reactions added programatically
				},
				temp:800,
				//tempLow:100,
				//stateLow: "liquid_smoke",
				//tempHigh: 7000,
				//stateHigh: "liquid_plasma",
				category: "energy liquids",
				burning: true,
				burnTime: Infinity,
				burnTempChange: 3,
				fireSpawnChance: 5,
				fireElement: "rad_fire",
				state: "liquid",
				density: 21,
			};
		};
		
		elements.radiation.reactions.liquid_fire = { "elem2":"liquid_rad_fire", "chance":0.4 };
		elements.radiation.reactions.fire = { "elem2":"rad_fire", "chance":0.4 };
		elements.radiation.reactions.smoke = { "elem2":"rad_smoke", "chance":0.4 };
		
		runAfterLoad(function() {
			for(key in elements.radiation.reactions) {
				var value = elements.radiation.reactions[key];
				
				if(typeof(elements.rad_fire.reactions[key]) === "undefined") {
					elements.rad_fire.reactions[key] = value;
				};
			};
		});
		
		if(enabledMods.includes("mods/randomness.js")) {
			elements.unnamed_gas.burnTempChange = 10;
			elements.unnamed_gas.fireElement = "plasma";
			elements.unnamed_powder.burnTempChange = 20;
			elements.unnamed_powder.fireElement = "plasma";
			elements.burning_unnamed_gas.burnTempChange = 15;
			elements.burning_unnamed_gas.fireElement = "plasma";
			elements.burning_unnamed_powder.burnTempChange = 30;
			elements.burning_unnamed_powder.fireElement = "plasma";
		};
	});
} else {
	alert(`The ${libraryMod} mod is required and has been automatically inserted (reload for this to take effect).`)
	enabledMods.splice(enabledMods.indexOf(modName),0,libraryMod)
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
};
var modName = "mods/life_eater.js";
var fireMod = "mods/fire_mod.js";

if(!enabledMods.includes(fireMod)) {
	enabledMods.splice(enabledMods.indexOf(modName),0,fireMod);
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
	alert(`The ${fireMod} mod is required and has been automatically inserted (reload for this to take effect).`);
} else {

	var lifeEaterCategories = ["life","auto creepers","food","fantastic creatures","fey","auto_fey"];
	var lifeEaterBlacklist = ["life_eater_virus","life_eater_slurry","life_eater_infected_dirt"];
	var lifeEaterWhitelist = ["blood","poop","blood_ice","wood","wood_plank","sawdust","straw","paper","birthpool","dried_poop","gloomfly","meat_monster","rotten_ravager","bone_beast","withery","withery_plant","banana","apple","rotten_apple","apioform_player","apioform_bee","apioform","apiodiagoform","sugar_cactus","sugar_cactus_seed","flowering_sugar_cactus","tree_branch","sap","silk","red_velvet","silk_velvet","ketchup", "enchanted_ketchup", "frozen_ketchup", "poisoned_ketchup", "frozen_poisoned_ketchup", "ketchup_spout", "ketchup_cloud", "poisoned_ketchup_cloud", "ketchup_snow", "ketchup_snow_cloud", "poisoned_ketchup_snow", "poisoned_ketchup_snow_cloud", "ketchup_gas", "poisoned_ketchup_gas", "ketchup_powder", "poisoned_ketchup_powder", "eketchup_spout", "ketchup_metal", "antiketchup", "dirty_ketchup", "ketchup_gold", "molten_ketchup_metal", "ketchup_fairy", "ketchup_metal_scrap", "ketchup_gold_scrap", "molten_ketchup_gold", "mycelium","vaccine","antibody","infection","sap","caramel","molasses","melted_chocolate","soda","mustard","fry_sauce","tomato_sauce","sugary_tomato_sauce","bio_ooze","zombie_blood","feather","tooth","decayed_tooth","plaque","tartar","bacteria","replacer_bacteria","pop_rocks"];
	var lifeEaterSubstitutions = {
		"dirt": "life_eater_infected_dirt",
	};


	function tryCreatePlus(element,centerX,centerY) {
		var plusCoords = adjacentCoords.concat([[0,0]]);
		var pixels = 0;
		for(let i = 0; i < plusCoords.length; i++) {
			var newX = centerX + plusCoords[i][0];
			var newY = centerY + plusCoords[i][1];
			if(isEmpty(newX,newY)) {
				while(element instanceof Array) { element = element[Math.floor(Math.random() * element.length)] };
				createPixel(element,newX,newY);
				pixels++;
			};
		};
		return pixels;
	};

	function spreadLifeEater(pixel) {
		var convertedPixels = [];
		for(i = 0; i < adjacentCoords.length; i++) { //iterate through neighbor spots
			if(!isEmpty(pixel.x+adjacentCoords[i][0],pixel.y+adjacentCoords[i][1],true)) { //check for adjacentCoords
				var newPixel = pixelMap[pixel.x+adjacentCoords[i][0]][pixel.y+adjacentCoords[i][1]]
				var isLifeEaterFairy = (elements[newPixel.element].category == "auto_fey" && newPixel.element.includes("life_eater_"))
				//console.log(newPixel.element,isLifeEaterFairy);
				if(
					(lifeEaterCategories.includes(elements[newPixel.element].category) || lifeEaterWhitelist.includes(newPixel.element) || Object.keys(lifeEaterSubstitutions).includes(newPixel.element)) && 
					!lifeEaterBlacklist.includes(newPixel.element) &&
					!isLifeEaterFairy //exclude fairies which produce life eater
				) {
					if(Object.keys(lifeEaterSubstitutions).includes(newPixel.element)) {
						var data = lifeEaterSubstitutions[newPixel.element];
						while(data instanceof Array) {
							data = data[Math.floor(Math.random() * data.length)];
						};
						if(data === null) {
							if(newPixel) { deletePixel(newPixel.x,newPixel.y) };
						} else {
							changePixel(newPixel,data);
							convertedPixels.push(newPixel);
						};
					} else {
						changePixel(newPixel,"life_eater_slurry");
						convertedPixels.push(newPixel);
					};
				};
			};
		};
		return convertedPixels;
	};

	elements.life_eater_explosion = {
		color: ["#96c785","#f0d654","#ffb47a"],
		behavior: [
			"XX|XX|XX",
			"XX|EX:9>plasma,fire,life_eater_virus|XX",
			"XX|XX|XX",
		],
		temp: 1600,
		category: "energy",
		state: "gas",
		density: 1000,
		excludeRandom: true,
		hidden: true,
	},

	elements.life_eater_virus = {
		color: ["#7bb064", "#aabd60", "#9e9e29"],
		behavior: behaviors.GAS,
		tick: function(pixel) {
			spreadLifeEater(pixel).forEach(infectedPixel => spreadLifeEater(infectedPixel));
		},
		category: "life",
		state: "gas",
		density: airDensity,
		excludeRandom: true,
		tempHigh: 300,
		stateHigh: null,
	};

	elements.life_eater_slurry = {
		color: ["#3d6e29", "#666617", "#7d5716"],
		behavior: behaviors.LIQUID,
		properties: {
			methaned: false,
		},
		tick: function(pixel) {
			spreadLifeEater(pixel).forEach(infectedPixel => spreadLifeEater(infectedPixel));
			
			if(pixelTicks - pixel.start > 6) {
				if(!pixel.methaned && Math.random() < 0.2) {
					changePixel(pixel,Math.random() < 0.2 ? "life_eater_virus" : "methane");
				} else {
					pixel.methaned = true;
				};
				tryCreatePlus(["methane","methane","methane","methane","life_eater_virus"],pixel.x,pixel.y);
				return;
			};
		},
		category: "life",
		state: "liquid",
		density: 1050,
		burn: 100,
		burnTime: 10,
		fireSpawnTemp: 1500,
		burnTempChange: 200,
		burnInto: ["life_eater_virus","plasma","fire","life_eater_explosion"],
		excludeRandom: true,
	};

	var crRule50 = "CR:life_eater_virus,methane,methane,methane%0.5";
	var crRule100 = "CR:life_eater_virus,methane,methane,methane%1";

	elements.life_eater_infected_dirt = {
		behavior: [
			"XX|"+crRule100+"|XX",
			crRule50+"|XX|"+crRule50,
			"M2|M1 AND "+crRule50+"|M2",
		],
		color: ["#757137","#617a35","#66622c","#707538"],
		tick: function(pixel) {
			spreadLifeEater(pixel).forEach(infectedPixel => spreadLifeEater(infectedPixel));
		},
		category: "life",
		state: "liquid",
		density: 1050,
		burn: 70,
		burnTime: 15,
		fireSpawnTemp: 1400,
		burnTempChange: 180,
		burnInto: ["life_eater_virus","fire","plasma","life_eater_explosion"],
		excludeRandom: true,
	};
	
	for(i = 0; i < 4; i++) {
		elements.life_eater_infected_dirt.burnInto.push(elements.dry_dirt ? "dry_dirt" : "sand");
	};

	elements.virus_bomb = {
		color: "#accc70",
		behavior: [
			"XX|EX:16>life_eater_virus|XX",
			"XX|XX|XX",
			"XX|EX:16>life_eater_virus AND M1|XX"
		],
		density: 3500,
		hardness: 0.95,
		breakInto: "life_eater_virus",
		tempHigh: 2400,
		category: "weapons",
		excludeRandom: true,
		stateHigh: elements.metal_scrap.stateHigh.concat("life_eater_virus","life_eater_virus","life_eater_virus"),
	};

}
elements.liquid_void = {
	color: "#262626",
	behavior: [
		"XX|DL|XX",
		"DL AND M2|XX|DL AND M2",
		"M1|DL AND M1|M1",
	],
	ignore: ["liquid_void", "void", "wall", "cloner", "ecloner", "slow_cloner", "clone_powder", "floating_cloner", "clone_liquid", "liquid_cloner", "fire_cloner", "antigravity_powder_cloner", "floating_cloner_spout", "clone_liquid_spout", "liquid_cloner_spout", "fire_cloner_spout", "converter", "liquid_void_spout"],
	/*The hardcoded array of cloners is used because I don't know how to detect them.
	Generation code: 
		elementArray = Object.keys(elements);
		for (let i = 0; i < elementArray.length; i++) {
			var elementName = elementArray[i];
			if(elementName.indexOf("lone") !== -1) {
				console.log(elementName);
			};
		};
	*/
	category: "liquids",
	state: "liquid",
	density: 6969,
	excludeRandom: true,
}

if(!elements.void.ignore) {
	elements.void.ignore = [];
};

elements.void.ignore.push("liquid_void");
// Meat Rockets 1.0
// Author: Melecie

meat_rocket_funcs = {
	rocketCreator(rElem, rColor, rName) {
		if (typeof(rName) == "undefined") { rName = rElem + "_rocket" }
		
		elements[rName] = {
			color: rColor,
			state: "solid",
			behavior: behaviors.ITEM_ROCKET,
			properties: { launching: false },
			rocketItem: rElem,
			density: 1024,
			hardness: 0.90,
			burn: 100,
			burnTime: 8192,
			category: "special",
		}
	}
}


behaviors.ITEM_ROCKET = function(pixel) {
	if (pixel.launching) {
		pixel.burning = false;
		
		// launching rocket
		let nextX = pixel.x + (pixel.flipX ? -1:1);
		let nextY = pixel.y-1;
		let rocketItem = elements[pixel.element].rocketItem;
		
		// flip, occasionally explode
		if (Math.random() < 0.1) {
			pixel.flipX = !pixel.flipX;
			if (Math.random() < 0.05) {
				explodeAt(pixel.x, pixel.y-1, 3, [rocketItem, "smoke"]);
			}
		} else if (Math.random() < 0.1) {
			createPixel(pixel.x, pixel.y-1, "smoke")
		}
		
		// movement code
		if (outOfBounds(nextX, nextY)) {
			explodeAt(pixel.x, pixel.y, 10, [rocketItem, "smoke", "smoke"]);
			deletePixel(pixel.x, pixel.y);
		} else if (canMove(pixel, nextX, nextY)) {
			tryMove(pixel, nextX, nextY);
		} else if ( elements[pixelMap[nextX][nextY].element].state == "gas" || pixelMap[nextX][nextY].element == rocketItem ) {
			let otherPixel = pixelMap[nextX][nextY];
			swapPixels(pixel, otherPixel);
		} else if ( pixelMap[nextX][nextY].element == pixel.element ) {
			
		} else {
			explodeAt(pixel.x, pixel.y, 10, [rocketItem, "smoke", "smoke"]);
			deletePixel(pixel.x, pixel.y);
		}
	} else {
		// hasn't started yet
		behaviors.POWDER(pixel);
		if (pixel.burning == true) {
			pixel.launching = true;
		}
	}
	
	doDefaults(pixel);
}

meat_rocket_funcs.rocketCreator("meat", ["#d36e7d", "#a85c4b"])
elements.meat.reactions.fallout = { elem1: "meat_rocket", chance: 0.2 }
libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//URL

	urlParams = new URLSearchParams(window.location.search);

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Objects

	//getKeyByValue code by SO UncleLaz: https://stackoverflow.com/questions/9907419/how-to-get-a-key-in-a-javascript-object-by-its-value
	//CC-BY-SA-4.0
	function getKeyByValue(object, value) {
	  return Object.keys(object).find(key => object[key] === value);
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//RNG

	//Random integer from 0 to n
	function randomIntegerFromZeroToValue(value) {
		var absoluteValuePlusOne = Math.abs(value) + 1;
		if(value >= 0) { //Positive case
			return Math.floor(Math.random() * absoluteValuePlusOne)
		} else { //Negative case: flip sign
			return 0 - Math.floor(Math.random() * absoluteValuePlusOne)
		};
	};

	//Random thing from array
	function randomChoice(array) {
		if(array.length === 0) { throw new Error(`The array ${array} is empty`) };
		var length = array.length;
		var randomIndex = randomIntegerFromZeroToValue(length - 1);
		return array[randomIndex];
	};

	//Random integer from m to n
	function randomIntegerBetweenTwoValues(min,max) {
		if(min > max) {
			var temp = max; //the need of a temporary space has always annoyed me
			max = min;
			min = temp;
		};
		return Math.floor(Math.random() * (max - min + 1)) + min
	};

	//cyrb128 idk where this comes from but it was in the same thread
	function cyrb128(str) {
		let h1 = 1779033703, h2 = 3144134277,
			h3 = 1013904242, h4 = 2773480762;
		for (let i = 0, k; i < str.length; i++) {
			k = str.charCodeAt(i);
			h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
			h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
			h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
			h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
		}
		h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
		h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
		h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
		h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
		return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
	}

	function mulberry32(a) { //Mulberry32 implemented in JS from StackOverflow, https://gist.github.com/tommyettinger/46a874533244883189143505d203312c
		return function() {
		  var t = a += 0x6D2B79F5;
		  t = Math.imul(t ^ t >>> 15, t | 1);
		  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
		  return ((t ^ t >>> 14) >>> 0) / 4294967296;
		}
	} //returns random function seeded with a

	//Seeded randbetween
	function seededRandBetween(min,max,randomFunction) {
		if(min > max) {
			var temp = max;
			max = min;
			min = temp;
		};
		return Math.floor(randomFunction() * (max - min + 1)) + min
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Arrays

	//Shallow array comparer by SO Tim Down: https://stackoverflow.com/a/10260204
	//CC-BY-SA-3.0
	function arraysIdentical(arr1, arr2) {
		var i = arr1.length;
		if (i !== arr2.length) {
			return false;
		};
		while (i--) {
			if (arr1[i] !== arr2[i]) {
				return false;
			};
		};
		return true;
	};

	function indexOf(arr, val, comparer) {
		for (var i = 0, len = arr.length; i < len; ++i) {
			if ( i in arr && comparer(arr[i], val) ) {
				return i;
			};
		};
		return -1;
	};

	function averageNumericArray(array) {
		var total = array.reduce(addTwoNumbers,0)
		return total / array.length
	};

	function sumNumericArray(array) { //Sum of array numbers
		return array.reduce((partialSum, a) => partialSum + a, 0);
	};

	function pad_array(arr,len,fill) { //https://stackoverflow.com/a/38851957
		//console.log("Padding array");
		return arr.concat(Array(len).fill(fill)).slice(0,len);
	}
	
	//Function to check if an array includes a given array by SO Johnny Tisdale: https://stackoverflow.com/a/60922255
	//CC-BY-SA-4.0
	function includesArray(parentArray, testArray) {
		for (let i = 0; i < parentArray.length; i++) {
			if (parentArray[i].every(function(value, index) { return value === testArray[index]})) {
				return true;
			};
		};
		return false;
	};

	function addArraysInPairs(array1,array2,fill=0) { //e.g. [1,2,3] + [10,0,-1] = [11,2,2]
		//console.log("Adding in pairs: " + array1 + " and " + array2 + ".");
		if(array1.length > array2.length) { //zero-padding
			array2 = pad_array(array2,array1.length,fill); //if a1 is longer, pad a2 to a1's length
		} else if(array2.length > array1.length) {
			array1 = pad_array(array1,array2.length,fill); //if a2 is longer, pad a1 to a2's length
		};
		var tempArray = [];
		for(z = 0; z < array1.length; z++) {
			//console.log("Forming output values (" + array1[z] + " + " + array2[z] + ")");
			tempArray[z] = array1[z] + array2[z];
			//console.log("Sum" + tempArray[z]);
		};
		//console.log("Added into " + tempArray + ".");
		return tempArray;
	};

	function tryJoin(stringOrArray,joiner) {
		//console.log(`tryJoin: ${stringOrArray}`);
		if(typeof(stringOrArray) === "string") {
			//console.log("tryJoin: String");
			return stringOrArray;
		} else if(Array.isArray(stringOrArray)) {
			//console.log("tryJoin: Array");
			return stringOrArray.join(joiner);
		} else {
			throw new TypeError(`Unexpected type: ${typeof(stringOrArray)}`);
		};
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Checks

	//Element exists in the elements object
	function elementExists(elementName) {
		return typeof(elements[elementName]) === "object";
	};

	//Has a given state
	function isState(elementName,inputState) {
		if(!elementExists(elementName)) {
			throw new Error(`Element ${elementName} doesn't exist`);
		};

		var infoState = elements[elementName].state;

		if(infoState == undefined) { infoState = "undefined" };

		if(inputState == undefined) { inputState = "undefined" };
		if(inputState instanceof Array) {
			var limit = 0;
			while(inputState.includes(undefined) && limit < 3) {
				inputState[inputState.indexOf(undefined)] = "undefined"
				limit++;
			};
		};

		if(inputState instanceof Array) {
			return inputState.includes(infoState);
		};

		return infoState == inputState;
	};

	//Check if pixel of given element exists at given location
	function hasPixel(x,y,elementInput) {
		if(isEmpty(x,y,true)) { //if empty, it can't have a pixel
			return false;
		} else {
			if(elementInput.includes(",")) { //CSTA
				elementInput = elementInput.split(",");
			};
			if(Array.isArray(elementInput)) { //if element list
				for(i = 0; i < elementInput.length; i++) { if(!elementExists(elementInput[i])) { console.log(`hasPixel: Element "${elementInput[i]}" doesn't exist`) } };
				return elementInput.includes(pixelMap[x][y].element);
			} else { //if single element
				if(!elementExists(elementInput)) { console.log(`hasPixel: Element "${elementInput}" doesn't exist`) };
				return pixelMap[x][y].element === elementInput;
			};
		};		
	};

	//Is movable
	var backupCategoryWhitelist = ["land","powders","weapons","food","life","corruption","states","fey","Fantastic Creatures","dyes","energy liquids","random liquids","random gases","random rocks"];
	var backupElementWhitelist = ["mercury", "chalcopyrite_ore", "chalcopyrite_dust", "copper_concentrate", "fluxed_copper_concentrate", "unignited_pyrestone", "ignited_pyrestone", "everfire_dust", "extinguished_everfire_dust", "mistake", "polusium_oxide", "vaporized_polusium_oxide", "glowstone_dust", "redstone_dust", "soul_mud", "wet_soul_sand", "nitrogen_snow", "fusion_catalyst", "coal", "coal_coke", "blast_furnace_fuel", "molten_mythril"];

	function commonMovableCriteria(name,shallowBlacklist=null) {
		if(typeof(elements[name]) !== "object") {
			throw new Error(`Nonexistent element ${name}`);
		};
		var info = elements[name];
		//console.log(`${name} (${JSON.stringify(elements[name])})`);
		if(typeof(info.state) === "undefined") {
			var state = null;
		} else {
			var state = info.state;
		};
		if(typeof(info.category) === "undefined") {
			var category = "other";
		} else {
			var category = info.category;
		};
		if(shallowBlacklist !== null && shallowBlacklist.includes(name)) {
			return false;
		};
		if(elements[name].tool) {
			return false;
		};
		if(elements[name].behavior && elements[name].behavior.toString() == elements.wall.behavior.toString() && !elements[name].tick) {
			return false;
		};
		if(["liquid","gas"].includes(state)) {
			return true;
		};
		if(info.movable) {
			return true;
		};
		if(elements[name].behavior instanceof Array) {
			var behaviorString = elements[name].behavior.toString();
			return behaviorString.includes("M1") || behaviorString.includes("M2");
		};
		if(backupCategoryWhitelist.includes(category)) {
			return true;
		};
		if(backupElementWhitelist.includes(name)) {
			return true;
		};
		if(category.includes("mudstone")) {
			return true;
		};
		return false;
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Math(s)

	//Base n logarithm from https://stackoverflow.com/a/3019290
	function logN(number,base) { //Vulnerable to float issues
		return Math.log(number) / Math.log(base);
	};

	//Distance between points
	function pyth(xA,yA,xB,yB) {
		var a = Math.abs(xB - xA);
		var b = Math.abs(yB - yA);
		var c = Math.sqrt(a**2 + b**2);
		return c;
	};

	//Limit number to [min, max]
	function bound(number,lowerBound,upperBound) {
		return Math.min(upperBound,Math.max(lowerBound,number));
	};
	
	//Emergency color wrapper
	rgbColorBound = function(color) {
		return bound(color,0,255);
	};

	function addTwoNumbers(number1,number2) { //reducer
		return number1 + number2
	}

	//Logistic curve
		//x = real number
		//L = maximum value
		//x_0 = "the x value of the sigmoid midpoint" i.e. the x center of the bendy part
		//k = steepness
	function logisticCurve(x,L,k,x0) {
		return L/(   1 + (  Math.E ** ( -k * (x - x0) )  )   );
	};

	// https://stackoverflow.com/questions/10756313/javascript-jquery-map-a-range-of-numbers-to-another-range-of-numbers
	// Function from August Miller
	//Map a range of numbers to another range of numbers
	function scale (number, inMin, inMax, outMin, outMax) {
		return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
	}

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Color

	function rgbStringToUnvalidatedObject(string) { //turns rgb() to {r,g,b} with no bounds checking
		//console.log("Splitting string into object");
		string = string.split(",");
		var red = parseFloat(string[0].substring(4));
		var green = parseFloat(string[1]);
		var blue = parseFloat(string[2].slice(0,-1));
		//console.log("String split: outputs " + red + ", " + green + ", " + blue + ".");
		return {r: red, g: green, b: blue};
	};

	function rgbStringToObject(string,doRounding=true,doBounding=true) { //turns rgb() to {r,g,b}
		//console.log(`rgbStringToObject: ${string}`);
			//console.log("Splitting string into object");
		string = string.split(",");
		if( (!string[0].startsWith("rgb(")) || (!string[2].endsWith(")")) ) {
			throw new Error("Color must start with \"rgb(\" and end with \")\"");
		};
		var red = parseFloat(string[0].substring(4));
		var green = parseFloat(string[1]);
		var blue = parseFloat(string[2].slice(0,-1));
			//console.log(`Colors loaded (${red}, ${green}, ${blue})`);
		//NaN checking
			var redNaN = isNaN(red);
			var greenNaN = isNaN(green);
			var blueNaN = isNaN(blue);
			var NanErrorString = "One or more colors are NaN:"
			if(redNaN) { NanErrorString += " red" };
			if(greenNaN) { NanErrorString += " green" };
			if(blueNaN) { NanErrorString += " blue" };
			if(redNaN || greenNaN || blueNaN) { throw new Error(NanErrorString) };
		if(doRounding) {
			red = Math.round(red);
			green = Math.round(green);
			blue = Math.round(blue);
				//console.log(`Colors rounded to (${red}, ${green}, ${blue})`);
		};
		if(doBounding) {
			red = bound(red,0,255)
			green = bound(green,0,255)
			blue = bound(blue,0,255)
				//console.log(`Colors bounded to (${red}, ${green}, ${blue})`);
		};
			//console.log("String split: outputs " + red + ", " + green + ", " + blue + ".");
		return {r: red, g: green, b: blue};
	};

	function hslColorStringToObject(color) {
		if(!color.startsWith("hsl(") || !color.endsWith(")")) {
			throw new Error(`The color ${color} is not a valid hsl() color`)
		};
		var colorTempArray = color.split(",")
		if(colorTempArray.length !== 3) {
			throw new Error(`The color ${color} is not a valid hsl() color`)
		};
		if(!colorTempArray[1].endsWith("%")) { console.log(`hslColorStringToObject: Saturation in color ${color} was missing a %`); colorTempArray[1] += "%"; }
		if(!colorTempArray[2].endsWith("%)")) { console.log(`hslColorStringToObject: Lightness in color ${color} was missing a %`); colorTempArray[2] = [colorTempArray[2].slice(0, colorTempArray[2].length - 1), "%", colorTempArray[2].slice(colorTempArray[2].length - 1)].join(''); }
		var hue = parseFloat(colorTempArray[0].substring(4));
		var saturation = parseFloat(colorTempArray[1].slice(0,-1))
		var lightness = parseFloat(colorTempArray[2].slice(0,-2));
		//NaN checking
            var hueNaN,saturationNaN,lightnessNaN;
			isNaN(hue) ? hueNaN = true : hueNaN = false;
			isNaN(saturation) ? saturationNaN = true : saturationNaN = false;
			isNaN(lightness) ? lightnessNaN = true : lightnessNaN = false;
			var NanErrorString = "One or more colors are NaN:"
			if(hueNaN) { NanErrorString += " hue" };
			if(saturationNaN) { NanErrorString += " saturation" };
			if(lightnessNaN) { NanErrorString += " lightness" };
			if(hueNaN || saturationNaN || lightnessNaN) { throw new Error(NanErrorString) };
		return {h: hue, s: saturation, l: lightness};
	};

	function rgbToHex(color) {
		//console.log(`rgbToHex called on ${typeof(color) === "object" ? JSON.stringify(color) : color}`);
		if(typeof(color) == "object") { //Expects object like "{r: 172, g: 11, b: 34}"
			var red = color.r;
			var green = color.g;
			var blue = color.b;
				//console.log(`Colors loaded (${red}, ${green}, ${blue})`);
			red = Math.round(red);
			green = Math.round(green);
			blue = Math.round(blue);
				//console.log(`Colors rounded to (${red}, ${green}, ${blue})`);
			red = bound(red,0,255)
			green = bound(green,0,255)
			blue = bound(blue,0,255)
				//console.log(`Colors bounded to (${red}, ${green}, ${blue})`);
			red = red.toString(16);
			green = green.toString(16);
			blue = blue.toString(16);
				//console.log(`Colors converted to (0x${red}, 0x${green}, 0x${blue})`);
			//console.log("Padding R");
			while(red.length < 2) {
				red = "0" + red;
			};
			//console.log("Padding G");
			while(green.length < 2) {
				green = "0" + green;
			};
			//console.log("Padding B");
			while(blue.length < 2) {
				blue = "0" + blue;
			};
				//console.log(`Colors padded to (0x${red}, 0x${green}, 0x${blue}), concatenating...`);
			return "#" + red + green + blue;
		} else if(typeof(color) == "string") { //Expects string like "rgb(20,137,4)". Also doesn't round properly for some reason...
				//console.log("Splitting string")
			color = rgbStringToUnvalidatedObject(color);
			red = color.r;
			green = color.g;
			blue = color.b;
				//console.log(`Colors loaded (${red}, ${green}, ${blue})`);
			red = Math.round(red);
			green = Math.round(green);
			blue = Math.round(blue);
				//console.log(`Colors rounded to (${red}, ${green}, ${blue})`);
			red = bound(red,0,255)
			green = bound(green,0,255)
			blue = bound(blue,0,255)
				//console.log(`Colors bounded to (${red}, ${green}, ${blue})`);
			red = red.toString(16);
			green = green.toString(16);
			blue = blue.toString(16);
				//console.log(`Colors converted to (0x${red}, 0x${green}, 0x${blue})`);
			//console.log("Padding R");
			while(red.length < 2) {
				red = "0" + red;
			};
			//console.log("Padding G");
			while(green.length < 2) {
				green = "0" + green;
			};
			//console.log("Padding B");
			while(blue.length < 2) {
				blue = "0" + blue;
			};
				//console.log(`Colors padded to (0x${red}, 0x${green}, 0x${blue}), concatenating...`);
			return "#" + red + green + blue;
			} else {
			throw new Error(`Received invalid color: ${color}`);
		};
	};

	function linearBlendTwoColorObjects(color1,color2,weight1=0.5) { /*third argument is for color1 and expects a float from 0
																  to 1, where 0 means "all color2" and 1 means "all color1"*/
		var w1 = Math.min(Math.max(weight1,0),1);
		var red1 = color1.r;
		var green1 = color1.g;
		var blue1 = color1.b;
		var red2 = color2.r;
		var green2 = color2.g;
		var blue2 = color2.b;
		var red3 = (red1 * w1) + (red2 * (1 - w1));
		var green3 = (green1 * w1) + (green2 * (1 - w1));
		var blue3 = (blue1 * w1) + (blue2 * (1 - w1));
		return {r: red3, g: green3, b: blue3};
	};

	function lightenColor(color,offset,outputType="rgb") {
		if(typeof(color) === "string") {
			if(color.length < 10) {
			//console.log(`detected as hex: ${color}`);
				//catch missing octothorpes
				if(!color.startsWith("#")) {
					color = "#" + color;
				};
			//console.log(`octothorpe checked: ${color}`);

				offset = parseFloat(offset);
				if(isNaN(offset)) {
					throw new Error("Offset is NaN");
				};
				
				color = hexToRGB(color);
				if(color === null) {
					throw new Error("hexToRGB(color) was null (maybe it's an invalid hex triplet?)");
				};
				
			//console.log("converted color: " + JSON.stringify(color));
				var red = color.r + offset;
				var green = color.g + offset;
				var blue = color.b + offset;
			//console.log(`altered color: rgb(${red},${green},${blue})`);
				
				//rounding and bounding
				red = Math.round(red);
				green = Math.round(green);
				blue = Math.round(blue);
			//console.log(`rounded color: rgb(${red},${green},${blue})`);
				red = bound(red,0,255)
				green = bound(green,0,255)
				blue = bound(blue,0,255)
			//console.log(`bounded color: rgb(${red},${green},${blue})`);

				color = {r: red, g: green, b: blue};

				switch(outputType.toLowerCase()) {
					case "rgb":
						return `rgb(${red},${green},${blue})`;
						break;
					case "hex":
						return rgbToHex(color);
						break;
					case "json":
						return color;
						break;
					default:
						throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
				};
			} else {
				if(color.startsWith("rgb(")) {
					color = convertColorFormats(color,"json"); //object conversion
				//console.log(`color converted to object: ${JSON.stringify(color)}`);

					offset = parseFloat(offset);
					if(isNaN(offset)) {
						throw new Error("Offset is NaN");
					};
					
					var red = color.r + offset;
					var green = color.g + offset;
					var blue = color.b + offset;
				//console.log(`altered color: rgb(${red},${green},${blue})`);
					
					//rounding and bounding
					red = Math.round(red);
					green = Math.round(green);
					blue = Math.round(blue);
				//console.log(`rounded color: rgb(${red},${green},${blue})`);
					red = bound(red,0,255)
					green = bound(green,0,255)
					blue = bound(blue,0,255)
				//console.log(`bounded color: rgb(${red},${green},${blue})`);

					color = {r: red, g: green, b: blue};

					switch(outputType.toLowerCase()) {
						case "rgb":
							return `rgb(${red},${green},${blue})`;
							break;
						case "hex":
							return rgbToHex(color);
							break;
						case "json":
							return color;
							break;
						default:
							throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
					};
				} /*else if(color.startsWith("hsl")) {
					throw new Error("HSL is not implemented yet");
				}*/ else {
					throw new Error('Color must be of the type "rgb(red,green,blue)"'/* or "hsl(hue,saturation%,luminance%)"*/);
				};
			};
		} else if(typeof(color) === "object") {
			if(typeof(color.r) === "undefined" || typeof(color.g) === "undefined" || typeof(color.b) === "undefined") {
				throw new Error("Color must be of the form {r: red, g: green, b: blue}");
			};
			
		//console.log("received color: " + JSON.stringify(color));
			var red = color.r + offset;
			var green = color.g + offset;
			var blue = color.b + offset;
		//console.log(`altered color: rgb(${red},${green},${blue})`);
			
			//rounding and bounding
			red = Math.round(red);
			green = Math.round(green);
			blue = Math.round(blue);
		//console.log(`rounded color: rgb(${red},${green},${blue})`);
			red = bound(red,0,255)
			green = bound(green,0,255)
			blue = bound(blue,0,255)
		//console.log(`bounded color: rgb(${red},${green},${blue})`);

			color = {r: red, g: green, b: blue};

			switch(outputType.toLowerCase()) {
				case "rgb":
					return `rgb(${red},${green},${blue})`;
					break;
				case "hex":
					return rgbToHex(color);
					break;
				case "json":
					return color;
					break;
				default:
					throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
			};
		};
	};

	function rgbObjectToString(color) {
		if(typeof(color) !== "object") {
			throw new Error("Input color is not an object");
		};
		var red = color.r;
		var green = color.g;
		var blue = color.b;
			//console.log(`Colors loaded (${red}, ${green}, ${blue})`);
		red = Math.round(red);
		green = Math.round(green);
		blue = Math.round(blue);
			//console.log(`Colors rounded to (${red}, ${green}, ${blue})`);
		red = bound(red,0,255)
		green = bound(green,0,255)
		blue = bound(blue,0,255)
			//console.log(`Colors bounded to (${red}, ${green}, ${blue})`);
		return `rgb(${red},${green},${blue})`
	};
	
	function convertColorFormats(color,outputType="rgb") { //Hex triplet and object to rgb(), while rgb() is untouched
		if(typeof(color) === "undefined") {
			//console.log("Warning: An element has an undefined color. Unfortunately, due to how the code is structured, I can't say which one.");
			//color = "#FF00FF";
			throw new Error("Color is undefined!");
		};
		//console.log("Logged color for convertColorFormats: " + color);
		if(typeof(color) === "string") {
			if(typeof(color) === "string" && color.length < 10) {
				//console.log(`detected as hex: ${color}`);
					//catch missing octothorpes
					if(!color.startsWith("#")) {
						color = "#" + color;
					};
				//console.log(`octothorpe checked: ${color}`);

				color = hexToRGB(color);
				if(color === null) {
					throw new Error("hexToRGB(color) was null (maybe it's an invalid hex triplet?)");
				};
				
				switch(outputType.toLowerCase()) {
					case "rgb":
						return `rgb(${color.r},${color.g},${color.b})`;
						break;
					case "hex":
						return rgbToHex(color);
						break;
					case "json":
						return color;
						break;
					case "array":
						return [color.r, color.g, color.b];
						break;
					default:
						throw new Error("outputType must be \"rgb\", \"hex\", \"json\", or \"array\"");
				};
			} else {
				if(typeof(color) === "string" && color.startsWith("rgb(")) {
					//console.log(`convertColorFormats: calling rgbStringToObject on color ${color}`);
					color = rgbStringToObject(color,true,false);
					switch(outputType.toLowerCase()) {
						case "rgb":
							if(typeof(color) === "string") { color = rgbStringToObject(color) };
							return `rgb(${color.r},${color.g},${color.b})`;
							break;
						case "hex":
							return rgbToHex(color);
							break;
						case "json":
							return color;
							break;
						case "array":
							return [color.r, color.g, color.b];
							break;
						default:
							throw new Error("outputType must be \"rgb\", \"hex\", \"json\", or \"array\"");
					};
				} else {
					throw new Error('Color must be of the type "rgb(red,green,blue)"');
				};
			};
		} else if(typeof(color) === "object") {
			switch(outputType.toLowerCase()) {
				case "rgb":
					return `rgb(${color.r},${color.g},${color.b})`;
					break;
				case "hex":
					return rgbToHex(color);
					break;
				case "json":
					return color;
					break;
				case "array":
					return [color.r, color.g, color.b];
					break;
				default:
					throw new Error("outputType must be \"rgb\", \"hex\", \"json\", or \"array\"");
			};
		};
	};
	
	function rgbHexCatcher(color) {
		return convertColorFormats(color,"rgb");
	};

	
	function averageColorObjects(color1,color2,weight1=0.5) { //misnomer, actually a linear interpolation but it's too late to rename that
		//third argument is for color1 and expects a float from 0 to 1, where 0 means "all color2" and 1 means "all color1"
		//(backwards from how it should work)
		var w1 = Math.min(Math.max(weight1,0),1)
		var red1 = color1.r
		var green1 = color1.g
		var blue1 = color1.b
		var red2 = color2.r
		var green2 = color2.g
		var blue2 = color2.b
		var red3 = (red1 * w1) + (red2 * (1 - w1))
		var green3 = (green1 * w1) + (green2 * (1 - w1))
		var blue3 = (blue1 * w1) + (blue2 * (1 - w1))
		return {r: red3, g: green3, b: blue3}
	};

	function lerpColors(color1,color2,outputType="rgb",weight1=0.5) {
		color1 = convertColorFormats(color1,"json");
		color2 = convertColorFormats(color2,"json");
		theColor = averageColorObjects(color1,color2,weight1);
		return convertColorFormats(theColor,outputType);
	};

	function multiplyColors(color1,color2,outputType="rgb") {
		//normalize rgb()/hex by turning any hex into rgb() and then rgb()s to {r,g,b}
		if(typeof(color1) !== "object") {
			color1 = convertColorFormats(color1,"json");
		};
		if(typeof(color2) !== "object") {
			color2 = convertColorFormats(color2,"json");
		};
		var finalR = Math.round(color1.r * (color2.r/255));
		var finalG = Math.round(color1.g * (color2.g/255));
		var finalB = Math.round(color1.b * (color2.b/255));
		var finalColor = {r: finalR, g: finalG, b: finalB};
		switch(outputType.toLowerCase()) {
			case "rgb":
				return `rgb(${finalColor.r},${finalColor.g},${finalColor.b})`;
				break;
			case "hex":
				return rgbToHex(finalColor);
				break;
			case "json":
				return finalColor;
				break;
			default:
				throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
		};
	};

	function divideColors(color1,color2,outputType="rgb") { //color2 is the divisor and color1 the dividend (base/original color)
		//normalize rgb()/hex by turning any hex into rgb() and then rgb()s to {r,g,b}
		if(typeof(color1) !== "object") {
			color1 = convertColorFormats(color1,"json");
		};
		if(typeof(color2) !== "object") {
			color2 = convertColorFormats(color2,"json");
		};
		var finalR = bound(Math.round(255 / (color2.r / color1.r)),0,255);
		var finalG = bound(Math.round(255 / (color2.g / color1.g)),0,255);
		var finalB = bound(Math.round(255 / (color2.b / color1.b)),0,255);
		if(isNaN(finalR)) { finalR = 255 };
		if(isNaN(finalG)) { finalG = 255 };
		if(isNaN(finalB)) { finalB = 255 };
		var finalColor = {r: finalR, g: finalG, b: finalB};
		switch(outputType.toLowerCase()) {
			case "rgb":
				return `rgb(${finalColor.r},${finalColor.g},${finalColor.b})`;
				break;
			case "hex":
				return rgbToHex(finalColor);
				break;
			case "json":
				return finalColor;
				break;
			default:
				throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
		};
	};

	function addColors(color1,color2,outputType="rgb") {
		//normalize rgb()/hex by turning any hex into rgb() and then rgb()s to {r,g,b}
		if(typeof(color1) !== "object") {
			color1 = convertColorFormats(color1,"json");
		};
		if(typeof(color2) !== "object") {
			color2 = convertColorFormats(color2,"json");
		};
		var finalR = bound(Math.round(color1.r + color2.r),0,255)
		var finalG = bound(Math.round(color1.g + color2.g),0,255)
		var finalB = bound(Math.round(color1.b + color2.b),0,255)
		var finalColor = {r: finalR, g: finalG, b: finalB};
		switch(outputType.toLowerCase()) {
			case "rgb":
				return `rgb(${finalColor.r},${finalColor.g},${finalColor.b})`;
				break;
			case "hex":
				return rgbToHex(finalColor);
				break;
			case "json":
				return finalColor;
				break;
			default:
				throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
		};
	};

	function subtractColors(color1,color2,outputType="rgb") {
		//normalize rgb()/hex by turning any hex into rgb() and then rgb()s to {r,g,b}
		if(typeof(color1) !== "object") {
			color1 = convertColorFormats(color1,"json");
		};
		if(typeof(color2) !== "object") {
			color2 = convertColorFormats(color2,"json");
		};
		var finalR = bound(Math.round(color1.r - color2.r),0,255)
		var finalG = bound(Math.round(color1.g - color2.g),0,255)
		var finalB = bound(Math.round(color1.b - color2.b),0,255)
		var finalColor = {r: finalR, g: finalG, b: finalB};
		switch(outputType.toLowerCase()) {
			case "rgb":
				return `rgb(${finalColor.r},${finalColor.g},${finalColor.b})`;
				break;
			case "hex":
				return rgbToHex(finalColor);
				break;
			case "json":
				return finalColor;
				break;
			default:
				throw new Error("outputType must be \"rgb\", \"hex\", \"json\"");
		};
	};

	function averageRgbPrefixedColorArray(colorArray,returnObject=false) { //array of rgb()s to single rgb() of average color
		//averageRgbPrefixedColorArray(["rgb(255,0,0)", "rgb(0,0,0)", "rgb(0,0,255)"]);
		//console.log("Averaging started");
		var reds = [];
		var greens = [];
		var blues = [];
		for(k = 0; k < colorArray.length; k++) {
			//console.log("Average function: Executing catcher on " + colorArray);
			var color = convertColorFormats(colorArray[k]);
			//console.log("Logged color for aRPCA: " + color);
			color = color.split(","); 
			var red = parseFloat(color[0].substring(4));
			reds.push(red)
			var green = parseFloat(color[1]);
			greens.push(green)
			var blue = parseFloat(color[2].slice(0,-1));
			blues.push(blue)
		};
		redAverage = Math.round(averageNumericArray(reds));
		greenAverage = Math.round(averageNumericArray(greens));
		blueAverage = Math.round(averageNumericArray(blues));
		var output; 
		returnObject ? output = {r: redAverage, g: greenAverage, b: blueAverage} : output = `rgb(${redAverage},${greenAverage},${blueAverage})`;
		//console.log("Averaging finished, product: " + output);
		return output;
	};

	//https://stackoverflow.com/questions/46432335/hex-to-hsl-convert-javascript
	function rgbStringToHSL(rgb,outputType="array") { //Originally a hex-to-HSL function, edited to take RGB and spit out an array
		//console.log("HSLing some RGBs");
		var result = rgbStringToUnvalidatedObject(rgb);

		var r = result.r;
		var g = result.g;
		var b = result.b;

		r /= 255, g /= 255, b /= 255;
		var max = Math.max(r, g, b), min = Math.min(r, g, b);
		var h, s, l = (max + min) / 2;

		if(max == min){
			h = s = 0; // achromatic
		} else {
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			switch(max) {
				case r: h = (g - b) / d + (g < b ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		};

		s = s*100;
		s = Math.round(s);
		l = l*100;
		l = Math.round(l);
		h = Math.round(360*h);

		//var colorInHSL = 'hsl(' + h + ', ' + s + '%, ' + l + '%)';
		//Edit to return an array
		switch(outputType.toLowerCase()) {
			case "array":
				return [h,s,l];
				break;
			case "hsl":
				return `hsl(${h},${s}%,${l}%)`;
				break;
			case "json":
				return {h: h, s: s, l: l};
			default:
				throw new Error("outputType must be \"array\", \"hsl\", or \"json\"");
				break;				
		};
		//console.log("HSL output "+ colorInHSL + ".");
		
	};

	function normalizeColorToHslObject(color,arrayType=null) {
		var ambiguousArrayError = "changeSaturation can't tell if the array input is supposed to be RGB or HSL. Please use an \"arrayType\" argument of \"rgb\" or \"hsl\".";
		var isHsl = false;
		if(Array.isArray(color)) {
			if(arrayType === null) {
				throw new Error(ambiguousArrayError);
			} else if(arrayType === "rgb") {
				color = `rgb(${color[0]},${color[1]},${color[2]})`;
				color = rgbStringToHSL(color,"json"); //rgb arr to hsl obj
			} else if(arrayType === "hsl") {
				color = {h: color[0], s: color[1], l: color[2]}; //hsl arr to hsl obj
			} else {
				throw new Error(ambiguousArrayError);
			};
		} else {
			//by this point, any array cases would have been handled, leaving just hex (rgb), json rgb, json hsl, string rgb, and string hsl 
			if(typeof(color) === "string") {
				if(color.length < 10) { //detect hex: assume hex triplet if too short to be a well-formed rgb()
					if(!color.startsWith("#")) {
						color = "#" + color; //catch missing #
					};
					isHsl = false;
				};
				if(color.startsWith("rgb(")) { //detect rgb(): self-explanatory
					isHsl = false;
				};
				if(color.startsWith("hsl(")) { //detect hsl(): self-explanatory
					isHsl = true;
				};
			} else if(typeof(color) === "object") {
				if(typeof(color.r) !== "undefined") { //detect {r,g,b}: check for r key
					isHsl = false;
				};
				if(typeof(color.h) !== "undefined") { //detect {h,s,l}: check for h key
					isHsl = true;
				};
			};
			if(!isHsl) {
				color = convertColorFormats(color,"rgb"); //make any RGBs rgb()
				color = rgbStringToHSL(color,"json"); //make that rgb() an {h,s,l}
			} else { //by this point, it would have to either be a string or an object
				if(typeof(color) === "string") { //if it's a string
					color = hslColorStringToObject(color) //now it's an object
				};
			};
		};
		return color;		
	};

	function convertHslObjects(color,outputType="rgb") {
		switch(outputType.toLowerCase()) {
			//RGB cases
			case "rgb":
				color = hexToRGB(hslToHex(...Object.values(color))); //hsl to hex, hex to rgb_json, and rgb_json to rgb()
				return `rgb(${color.r},${color.g},${color.b})`;
				break;
			case "hex":
				color = hslToHex(...Object.values(color)); //hsl to hex
				return color;
				break;
			case "rgbjson":
			case "rgb-json":
			case "rgb_json":
				color = hexToRGB(hslToHex(...Object.values(color))); //hsl to hex and hex to rgb_json
				return color; 
				break;
			case "rgbarray":
			case "rgb-array":
			case "rgb_array":
				color = hexToRGB(hslToHex(...Object.values(color))); //hsl to hex, hex to rgb_json, and rgb_json to rgb_array
				return [color.r, color.g, color.b]; 
				break;
			//HSL cases
			case "hsl":
				//note: color was previously converted to {h, s, l}
				return `hsl(${color.h},${color.s}%,${color.l}%)`;
				break;
			case "hsljson":
			case "hsl-json":
			case "hsl_json":
				return color; 
				break;
			case "hslarray":
			case "hsl-array":
			case "hsl_array":
				return [color.h, color.s, color.l]; 
				break;
			default:
				throw new Error("outputType must be \"rgb\", \"hex\", \"rgb_json\", \"rgb_array\", \"hsl\", \"hsl_json\", or \"hsl_array\"");
		};
	}

	function changeSaturation(color,saturationChange,operationType="add",outputType="rgb",arrayType=null) {
		color = normalizeColorToHslObject(color,arrayType);
		//only {h,s,l} should exist now
		
		//Math
		switch(operationType.toLowerCase()) {
			case "+":
			case "add":
				color.s += saturationChange;
				break;
			case "-":
			case "subtract":
				color.s -= saturationChange;
				break;
			case "*":
			case "x":
			case "":
			case "multiply":
				color.s *= saturationChange;
				break;
			case "/":
			case "":
			case "divide":
				color.s /= saturationChange;
				break;
			case "=":
			case "set":
				color.s = saturationChange;
				break;
			case ">":
			case ">=":
			case "min": //lower-bounds the color
				color.s = Math.max(color.s,saturationChange); //math.max to bound it to the higher of the input number or the existing color
				break;
			case "<":
			case "<=":
			case "max": //upper-bounds the color
				color.s = Math.min(color.s,saturationChange); //math.min to bound it to the lower of the input number or the existing color
				break;
			default:
				throw new Error("Operation must be \"add\", \"subtract\", \"multiply\", \"divide\", \"set\", \"min\", or \"max\"");
		};
		
		color.h = Math.round(color.h % 360);
		color.s = Math.round(bound(color.s,0,100));
		color.l = Math.round(bound(color.l,0,100));
		
		return convertHslObjects(color,outputType)
	};

	function changeLuminance(color,luminanceChange,operationType="add",outputType="rgb",arrayType=null) {
		color = normalizeColorToHslObject(color,arrayType);
		//only {h,s,l} should exist now
		
		//Math
		switch(operationType.toLowerCase()) {
			case "+":
			case "add":
				color.l += luminanceChange;
				break;
			case "-":
			case "subtract":
				color.l -= luminanceChange;
				break;
			case "*":
			case "x":
			case "":
			case "multiply":
				color.l *= luminanceChange;
				break;
			case "/":
			case "":
			case "divide":
				color.l /= luminanceChange;
				break;
			case "=":
			case "set":
				color.l = luminanceChange;
				break;
			case ">":
			case ">=":
			case "min":
				color.l = Math.max(color.l,luminanceChange);
				break;
			case "<":
			case "<=":
			case "max":
				color.l = Math.min(color.l,luminanceChange);
				break;
			default:
				throw new Error("Operation must be \"add\", \"subtract\", \"multiply\", \"divide\", \"set\", \"min\", or \"max\"");
		};
		
		color.h = Math.round(color.h % 360);
		color.s = Math.round(bound(color.s,0,100));
		color.l = Math.round(bound(color.l,0,100));
		
		return convertHslObjects(color,outputType);
	};

	function changeHue(color,hueChange,operationType="add",outputType="rgb",arrayType=null) {
		color = normalizeColorToHslObject(color,arrayType);
		//only {h,s,l} should exist now
		
		//Math
		switch(operationType.toLowerCase()) {
			case "+":
			case "add":
				color.h += hueChange;
				break;
			case "-":
			case "subtract":
				color.h -= hueChange;
				break;
			case "*":
			case "x":
			case "":
			case "multiply":
				color.h *= hueChange;
				break;
			case "/":
			case "":
			case "divide":
				color.h /= hueChange;
				break;
			case "=":
			case "set":
				color.h = hueChange;
				break;
			case ">":
			case ">=":
			case "min":
				color.h = Math.max(color.h,hueChange);
				break;
			case "<":
			case "<=":
			case "max":
				color.h = Math.min(color.h,hueChange);
				break;
			default:
				throw new Error("Operation must be \"add\", \"subtract\", \"multiply\", \"divide\", \"set\", \"min\", or \"max\"");
		};
		
		color.h = Math.round(color.h % 360);
		color.s = Math.round(bound(color.s,0,100));
		color.l = Math.round(bound(color.l,0,100));
		
		return convertHslObjects(color,outputType);
	};

	function colorToHsl(color,outputType="rgb") {
		color = convertColorFormats(color,"rgb");
		color = rgbStringToHSL(color,outputType);
		return color;
	};

	//https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex
	function hslToHex(h, s, l) { //h, s, l params to hex triplet
	  //console.log(`Hexing some HSLs (the HSLs are ${h},${s},${l})`)
	  s = bound(s,0,100); //limit to 0-100
	  l = bound(l,0,100);
	  l /= 100;
	  var a = s * Math.min(l, 1 - l) / 100;
	  var f = n => {
		var k = (n + h / 30) % 12;
		var color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
		return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
	  };
	  //console.log(`Hexed to #${f(0)}${f(8)}${f(4)}`)
	  return `#${f(0)}${f(8)}${f(4)}`;
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Pixels

	function exposedToAir(pixel) {	
		return (isEmpty(pixel.x+1,pixel.y) || isEmpty(pixel.x-1,pixel.y) || isEmpty(pixel.x,pixel.y+1) || isEmpty(pixel.x,pixel.y-1));
	};

	function tryTarnish(pixel,element,chance) {
		if(exposedToAir(pixel)) {
			if(Array.isArray(element)) {
				if(Math.random() < chance) {
					changePixel(pixel,randomChoice(element));
				};
			} else {
				if(Math.random() < chance) {
					changePixel(pixel,element);
				};
			};
		};
	};

	//Try to create a pixel, return true if it could be created and false if it couldn't
	function tryCreatePixel(elementInput,x,y) {
		//array handling
		if(elementInput.includes(",")) { //CSTA
			elementInput = elementInput.split(",");
		};
		if(Array.isArray(elementInput)) { //if element list
			elementInput = elementInput.filter(function(e) {
				return elementExists(e);
			});
			if(elementInput.length === 0) { throw new Error("elementInput has no existing elements") };
			elementInput = randomChoice(elementInput);
		};

		//existence check
		if(!elementExists(elementInput)) {
			throw new Error("Element " + elementInput + " doesn't exist!");
		};

		//actual creation check
		if(isEmpty(x,y)) {
			createPixel(elementInput,x,y);
			return true;
		} else {
			return false;
		};
	};

	function tryCreatePixelReturn(elementInput,x,y) {
		//array handling
		if(elementInput.includes(",")) { //CSTA
			elementInput = elementInput.split(",");
		};
		if(Array.isArray(elementInput)) { //if element list
			elementInput = elementInput.filter(function(e) {
				return elementExists(e);
			});
			if(elementInput.length === 0) { throw new Error("elementInput has no existing elements") };
			elementInput = randomChoice(elementInput);
		};

		//existence check
		if(!elementExists(elementInput)) {
			throw new Error("Element " + elementInput + " doesn't exist!");
		};

		//actual creation check
		if(isEmpty(x,y)) {
			return createPixelReturn(elementInput,x,y);
		} else {
			return false;
		};
	};

	function createPixelReturn(element,x,y) { //sugar
		var newPixel = new Pixel(x, y, element);
		currentPixels.push(newPixel);
		checkUnlock(element);
		return newPixel;
	};

	function changePixelReturn(pixel,element,changetemp=true) {
		pixel.element = element;
		pixel.color = pixelColorPick(pixel);
		pixel.start = pixelTicks;
		var elementInfo = elements[element];
		if (elementInfo.burning == true) {
			pixel.burning = true;
			pixel.burnStart = pixelTicks;
		}
		else if (pixel.burning && !elementInfo.burn) {
			delete pixel.burning;
			delete pixel.burnStart;
		}
		delete pixel.origColor; // remove stain
		if (pixel.r && !elementInfo.rotatable) {
			delete pixel.r;
		}
		if (pixel.flipX && !elementInfo.flippableX) {
			delete pixel.flipX;
		}
		if (pixel.flipY && !elementInfo.flippableY) {
			delete pixel.flipY;
		}
		// If elementInfo.flippableX, set it to true or false randomly
		if (elementInfo.flipX !== undefined) { pixel.flipX = elementInfo.flipX }
		else if (elementInfo.flippableX) {
			pixel.flipX = Math.random() >= 0.5;
		}
		// If elementInfo.flippableY, set it to true or false randomly
		if (elementInfo.flipY !== undefined) { pixel.flipY = elementInfo.flipY }
		else if (elementInfo.flippableY) {
			pixel.flipY = Math.random() >= 0.5;
		}
		if (elementInfo.temp != undefined && changetemp) {
			pixel.temp = elementInfo.temp;
			pixelTempCheck(pixel)
		}
		// If elementInfo.properties, set each key to its value
		if (elementInfo.properties !== undefined) {
			for (var key in elementInfo.properties) {
				// If it is an array or object, make a copy of it
				if (typeof elementInfo.properties[key] == "object") {
					pixel[key] = JSON.parse(JSON.stringify(elementInfo.properties[key]));
				}
				else {
					pixel[key] = elementInfo.properties[key];
				}
			}
		}
		checkUnlock(element);
		return pixel;
	};

	function storeFirstTouchingElement(pixel,propertyName,copyTemp=true,spread=true) {
		var info = elements[pixel.element];
		if(pixel[propertyName]) {
			return false;
		};
		for(i = 0; i < adjacentCoords.length; i++) {
			var newCoords = {x: pixel.x+adjacentCoords[i][0], y: pixel.y+adjacentCoords[i][1]};

			if (!isEmpty(newCoords.x,newCoords.y,true)) {
				newPixel = pixelMap[newCoords.x][newCoords.y];
				if (info.ignore && info.ignore.indexOf(newPixel.element) !== -1) {
					continue;
				};
				if (newPixel.element != pixel.element && newPixel.element != "wire") {
					pixel[propertyName] = newPixel.element;
					if(copyTemp) { pixel.temp = newPixel.temp };
					return newPixel.element;
				}
				else if (newPixel[propertyName] && spread) {
					pixel[propertyName] = newPixel[propertyName];
					pixel.temp = newPixel.temp;
					return newPixel[propertyName];
				}
			}
		};
	};

	function breakPixel(pixel,changetemp=false) {
		var info = elements[pixel.element];
		if(typeof(info.breakInto) === "undefined") {
			return false;
		};
		var breakIntoElement = info.breakInto;
		if(Array.isArray(breakIntoElement)) {
			breakIntoElement = breakIntoElement[Math.floor(Math.random() * breakIntoElement.length)]
		};
		var result = breakIntoElement;
		// change the pixel to the result
		if (result === null) {
			deletePixel(pixel.x,pixel.y);
			return;
		}
		if (elements[pixel.element].breakIntoColor) {
			var oldelement = pixel.element;
			changePixel(pixel,result,changetemp);
			pixel.color = pixelColorPick(pixel, elements[oldelement].breakIntoColor);
		}
		else {
			changePixel(pixel,result,changetemp);
		}
	};

	function tryBreak(pixel,changetemp=false,defaultBreakIntoDust=false) {
		var info = elements[pixel.element];
		var hardness = defaultHardness;
		if(typeof(info.hardness) === "number") {
			hardness = info.hardness;
		};
		hardness = 1 - hardness; //invert hardness, so a hardness of 0 becomes a 100% chance and a hardness of 1 becomes a 0% chance
		if(Math.random() < hardness) {
			return breakPixel(pixel,changetemp=false,defaultBreakIntoDust=false);
		} else {
			return false;
		};
	};

	function reactionStealer(pixel,newPixel,reactionTarget) {
		if(!elements[reactionTarget]) {
			throw new Error(`No such element ${reactionTarget}!`);
		};
		if(typeof(newPixel) === "undefined") { //timing issue?
			return false;
		};
		var newElement = newPixel.element;
		var newInfo = elements[newElement];
		if(typeof(newInfo.reactions) === "undefined") {
			return false;
		};
		if(typeof(newInfo.reactions[reactionTarget]) === "undefined") {
			return false;
		};
		var pixel2 = pixel;
		var pixel1 = newPixel;
		var r = newInfo.reactions[reactionTarget];
		
		if (r.setting && settings[r.setting]===0) {
			return false;
		}
		// r has the attribute "y" which is a range between two y values
		// r.y example: [10,30]
		// return false if y is defined and pixel1's y is not in the range
		if (r.tempMin !== undefined && pixel1.temp < r.tempMin) {
			return false;
		}
		if (r.tempMax !== undefined && pixel1.temp > r.tempMax) {
			return false;
		}
		if (r.charged && !pixel.charge) {
			return false;
		}
		if (r.chance !== undefined && Math.random() > r.chance) {
			return false;
		}
		if (r.y !== undefined && (pixel1.y < r.y[0] || pixel1.y > r.y[1])) {
			return false;
		}
		if (r.elem1 !== undefined) {
			// if r.elem1 is an array, set elem1 to a random element from the array, otherwise set it to r.elem1
			if (Array.isArray(r.elem1)) {
				var elem1 = r.elem1[Math.floor(Math.random() * r.elem1.length)];
			} else { var elem1 = r.elem1; }
			
			if (elem1 == null) {
				deletePixel(pixel1.x,pixel1.y);
			}
			else {
				changePixel(pixel1,elem1);
			}
		}
		if (r.charge1) { pixel1.charge = r.charge1; }
		if (r.temp1) { pixel1.temp += r.temp1; pixelTempCheck(pixel1); }
		if (r.color1) { // if it's a list, use a random color from the list, else use the color1 attribute
			pixel1.color = pixelColorPick(pixel1, Array.isArray(r.color1) ? r.color1[Math.floor(Math.random() * r.color1.length)] : r.color1);
		}
		if (r.attr1) { // add each attribute to pixel1
			for (var key in r.attr1) {
				pixel1[key] = r.attr1[key];
			}
		}
		if (r.elem2 !== undefined) {
			// if r.elem2 is an array, set elem2 to a random element from the array, otherwise set it to r.elem2
			if (Array.isArray(r.elem2)) {
				var elem2 = r.elem2[Math.floor(Math.random() * r.elem2.length)];
			} else { var elem2 = r.elem2; }

			if (elem2 == null) {
				deletePixel(pixel2.x,pixel2.y);
			}
			else {
				changePixel(pixel2,elem2);
			}
		}
		if (r.charge2) { pixel2.charge = r.charge2; }
		if (r.temp2) { pixel2.temp += r.temp2; pixelTempCheck(pixel2); }
		if (r.color2) { // if it's a list, use a random color from the list, else use the color2 attribute
			pixel2.color = pixelColorPick(pixel2, Array.isArray(r.color2) ? r.color2[Math.floor(Math.random() * r.color2.length)] : r.color2);
		}
		if (r.attr2) { // add each attribute to pixel2
			for (var key in r.attr2) {
				pixel2[key] = r.attr2[key];
			}
		}
		if (r.func) { r.func(pixel1,pixel2); }
		return r.elem1!==undefined || r.elem2!==undefined;
	};

	function spreadingProperty(pixel,propertyName,whitelist=null) {
		if(isNaN(pixel[propertyName])) {
			pixel[propertyName] = 0;
		};
		var randomNeighborOffset = adjacentCoords[Math.floor(Math.random() * adjacentCoords.length)];
		var rX = randomNeighborOffset[0];
		var rY = randomNeighborOffset[1];
		var rfX = pixel.x+rX;
		var rfY = pixel.y+rY;
		if(!isEmpty(rfX,rfY,true)) {
			if(!pixelMap[rfX]) {
				return false;
			};
			var rOtherPixel = pixelMap[rfX][rfY];
			var rOtherElement = rOtherPixel.element;
			if(whitelist === null || (whitelist !== null && whitelist.includes(rOtherElement))) {
				if(typeof(rOtherPixel) === "undefined" || isEmpty(rfX,rfY,true)) {
					return false;
				};
				if(isNaN(pixel[propertyName])) { //should include undefined
					pixel[propertyName] = 0;
				};
				var averageValue = (pixel[propertyName] + rOtherPixel[propertyName]) / 2;
				pixel[propertyName] = averageValue;
				rOtherPixel[propertyName] = averageValue;
			};
		};
		return true;
	};

	function spreadingPropertyReturn(pixel,propertyName,whitelist=null) {
		if(isNaN(pixel[propertyName])) {
			pixel[propertyName] = 0;
		};
		var recipients = []; //will never be more than one but done with [] for forEach
		var randomNeighborOffset = adjacentCoords[Math.floor(Math.random() * adjacentCoords.length)];
		var rX = randomNeighborOffset[0];
		var rY = randomNeighborOffset[1];
		var rfX = pixel.x+rX;
		var rfY = pixel.y+rY;
		if(!isEmpty(rfX,rfY,true)) {
			if(!pixelMap[rfX]) {
				return [];
			};
			var rOtherPixel = pixelMap[rfX][rfY];
			var rOtherElement = rOtherPixel.element;
			if(whitelist === null || (whitelist !== null && whitelist.includes(rOtherElement))) {
				if(typeof(rOtherPixel) === "undefined" || isEmpty(rfX,rfY,true)) {
					return [];
				};
				if(isNaN(pixel[propertyName])) { //should include undefined
					pixel[propertyName] = 0;
				};
				var averageValue = (pixel[propertyName] + rOtherPixel[propertyName]) / 2;
				pixel[propertyName] = averageValue;
				rOtherPixel[propertyName] = averageValue;
				recipients.push(rOtherPixel);
			};
		};
		return recipients;
	};

	function swapNumericPropertyValues(pixel1,pixel2,propertyName,whitelist=null) {
		if(!pixel1 || !pixel2) {
			return false;
		};
		if(isNaN(pixel1[propertyName])) {
			pixel1[propertyName] = 0;
		};
		if(isNaN(pixel2[propertyName])) {
			pixel2[propertyName] = 0;
		};
		if(whitelist === null || (whitelist !== null && whitelist.includes(pixel1.element) && whitelist.includes(pixel2.element))) {
			var temp1 = pixel1[propertyName];
			pixel1[propertyName] = pixel2[propertyName];
			pixel2[propertyName] = temp1;
		};
		return true;
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//World

	function breakCircle(x,y,radius,respectHardness=false,changeTemp=false,defaultBreakIntoDust=false) {
		var coords = circleCoords(x,y,radius);
		for(i = 0; i < coords.length; i++) {
			coordX = coords[i].x;
			coordY = coords[i].y;
			if(!isEmpty(coordX,coordY,true)) {
				var pixel = pixelMap[coordX][coordY];
				respectHardness ? tryBreak(pixel,changeTemp,defaultBreakIntoDust) : breakPixel(pixel,changeTemp,defaultBreakIntoDust);
			};
		};
	};
	
	function fillCircle(element,x,y,radius,overwrite=false) {
		var coords = circleCoords(x,y,radius);
		var newElement = element;
		if(Array.isArray(newElement)) {
			newElement = newElement[Math.floor(Math.random() * newElement.length)];
		};
		for(i = 0; i < coords.length; i++) {
			coordX = Math.round(coords[i].x);
			coordY = Math.round(coords[i].y);
			if(overwrite && !isEmpty(coordX,coordY,true)) {
				changePixel(pixelMap[coordX][coordY],element);
			};
			if(isEmpty(coordX,coordY,false)) {
				createPixel(element,coordX,coordY);
			};
		};
	};

	function fillCircleReturn(element,x,y,radius,overwrite=false) {
		//console.log("fcr");
		var pixels = [];
		//console.log("pixels initted");
		var coords = circleCoords(x,y,radius);
		//console.log("coords gotten");
		var newElement = element;
		//console.log("element processing");
		if(Array.isArray(newElement)) {
			newElement = newElement[Math.floor(Math.random() * newElement.length)];
		};
		//console.log("element processed");
		for(i = 0; i < coords.length; i++) {
			//console.log("iterator through spots: " + i);
			coordX = Math.round(coords[i].x);
			coordY = Math.round(coords[i].y);
			//console.log(`coord: (${coords[i].x},${coords[i].y})`);
			if(overwrite && !isEmpty(coordX,coordY,true)) {
				//console.log("replaced pixel");
				pixels.push(changePixelReturn(pixelMap[coordX][coordY],newElement));
			};
			if(isEmpty(coordX,coordY,false)) {
				//console.log("created pixel");
				pixels.push(createPixelReturn(newElement,coordX,coordY));
			};
		};
		//console.log("fcr finished");
		//console.log(pixels.map(x => x.element));
		return pixels;
	};

	function isOpenAndOnSurface(x,y,includeBottomBound=true) {
		if(!isEmpty(x,y,false)) {
			return false;
		};
		if(y + 1 == height) {
			return includeBottomBound;
		};
		return !isEmpty(x,y+1,true);
	};

	//Freeze pixel
	function freezePixel(pixel,changetemp=true) {
		var info = elements[pixel.element];
		var result = info.stateLow;
		if (!result) {
			return false
		};
		if(result instanceof Array) {
			result = result.filter(elementExists);
			if(result.length == 0) {
				return false;
			};
		} else {
			if(!(elementExists(result))) {
				return false;
			};
		};
		
		while(result instanceof Array) {
			result = randomChoice(result);
		};
		
		changePixel(pixel,result,changetemp);
		return true;
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Logic

	function xor(c1,c2) {
		if(!!c1 && !c2) {
			return true;
		} else if(!c1 && !!c2) {
			return true;
		} else {
			return false;
		};
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//currentPixels operations

	function findInCurrentPixels(x,y) {
		var pixel = currentPixels.filter(function(pixelObject) {
			return pixelObject.x == x && pixelObject.y == y;
		});
		if(pixel.length <= 0) {
			return undefined;
		};
		if(pixel.length > 1) {
			pixel.length = 1;
		};
		pixel = pixel[0];
		return pixel;
	};

	function filterCurrentPixels(filterFunction) {
		return currentPixels.filter(filterFunction);
	};
	
	//Filter test functions

	function _filterTest_xIsTwenty(pixel) {
		return pixel.x == 20;
	};

	function _filterTest_tempIsOdd(pixel) {
		return Math.trunc(pixel.temp) % 2 == 1;
	};

	function _filterTest_redRock(pixel) {
		if(typeof(convertColorFormats) === "undefined") {
			throw new Error("code_library.js is required!");
		};
		var color = rgbStringToHSL(convertColorFormats(pixel.color,"rgb"),"json");
		var isRed = ((color.h % 360) >= 350) || ((color.h % 360) <= 10);
		var isVivid = (color.s > 30);
		var isBright = (color.l > 20);
		return isRed && isVivid && isBright;
	};

	//Ghost pixel repair function
	function rebuildCurrentPixels() {
		var currPix = []; //rebuild currentPixels from pixelMap to try to fix bug
		for(pmi = 0; pmi < pixelMap.length; pmi++) {
			var pixelMapPart = pixelMap[pmi];
			for(pmj = 0; pmj < pixelMapPart.length; pmj++) {
				var pixelMapUnit = pixelMapPart[pmj];
				if(typeof(pixelMapUnit) === "object") {
					if(pixelMapUnit !== null) {
						currPix.push(pixelMapUnit);
					};
				};
			};
		};
		currentPixels = currPix;
	};


libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Sugar functions

	function newElement(name="element_name",color="#FF00FF",otherProps={}) {
		elements[name] = {
			color: color,
		};
		for(property in otherProps) {
			elements[name][property] = otherProps[property];
		};
		return elements[name];
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

//Fixes

	//fix -1-caused ghost pixels
	function deletePixel(x,y) {
		// remove pixelMap[x][y] from currentPixels
		var pixelIndex = currentPixels.indexOf(pixelMap[x][y]);
		if(pixelIndex !== -1) {
			currentPixels.splice(pixelIndex,1)
		};
		if (pixelMap[x][y]) {pixelMap[x][y].del = true}
		delete pixelMap[x][y];
		/*for (var i = 0; i < currentPixels.length; i++) {
			if (currentPixels[i].x == x && currentPixels[i].y == y) {
				currentPixels.splice(i, 1);
				break;
			}
		}*/
		/*if (id != null) {
			for (var i = 0; i < currentPixels.length; i++) {
				if (currentPixels[i].id == id) {
					currentPixels.splice(i, 1);
					return;
				}
			}
		}*/
	};

libraryLoaded = true;
this.libraryLoaded = true;
window.libraryLoaded = true;

runAfterLoad(function() {
	if(!libraryLoaded) {
		libraryLoaded = true;
		this.libraryLoaded = true;
		window.libraryLoaded = true
	}
})
//runs after the elements in "names" are defined

function runAfterAutogen(callback) {
    var interval = 10; // ms
    window.setTimeout(function() {
        if (window.autoElements) {
            callback();
        } else {
            runAfterAutogen(callback);
        }
    }, interval);
}
function createButtonsAndCountElements() {
	window.setTimeout(function() {
    document.getElementById("categoryControls").innerHTML = "";
	document.getElementById("elementControls").innerHTML = "";
    document.getElementById("category-tools").innerHTML = "";
	document.getElementById("extraInfo").innerHTML = "";
	elementCount = 0;
	hiddenCount = 0;
	categoryList = [];
	for (var element in elements) {
		elementCount++;
		if (settings.cheerful && elements[element].nocheer) {
			elements[element].hidden = true;
			hiddenCount++;
			continue;
		}
		if (element === "unknown") {continue;}
		var category = elements[element].category;
		if (category==null) {category="other"}
		if (categoryList.indexOf(category) === -1) {
			categoryList.push(category);
		}
		if (elements[element].hidden && (!settings["unhide"] || ( settings["unhide"]===2 && !settings.unlocked[element] ))) { hiddenCount++; continue; }
		var categoryDiv = document.getElementById("category-"+category);
		if (categoryDiv == null) {
			createCategoryDiv(category);
			categoryDiv = document.getElementById("category-"+category);
		}
		createElementButton(element);
	}
	if (document.getElementById("categoryButton-states")) {
		// move it to the end of its parent
		document.getElementById("categoryButton-states").parentNode.appendChild(document.getElementById("categoryButton-states"));
	}
	// Set the first button in categoryControls div to be the current category
	document.getElementById("categoryControls").children[0].click()
	document.getElementById("extraInfo").insertAdjacentHTML("beforeend", "<small><p>v" + currentversion + "  " + elementCount + " elements, including " + hiddenCount + " hidden ones.</p><p>2021-" + new Date().getFullYear() + ". All Rights Reserved. <a style='color:#00ffff' href='https://r74n.com'>R74n</a></p></small>");
	selectElement(currentElement);
	}, 10);
};

runAfterAutogen(createButtonsAndCountElements);

raaLoaded = true;
function whenAvailable(names, callback) {
    var interval = 10; // ms
    window.setTimeout(function() {
		let bool = true;
		for(let i = 0; i < names.length; i++)
		{
			if(!window[names[i]])
			{
				bool = false;
			}
		}
        if (bool) {
            callback();
        } else {
            whenAvailable(names, callback);
        }
    }, interval);
}

var modName = "mods/rays.js";
var runAfterAutogenMod = "mods/runAfterAutogen2.js";
var libraryMod = "mods/code_library.js";

if(enabledMods.includes(runAfterAutogenMod) && enabledMods.includes(libraryMod)) {
whenAvailable(["raaLoaded","libraryLoaded"], function() {
	runAfterAutogen(function() {
		snowAndIceCache = Object.keys(elements).filter(function(name) {
			return name.endsWith("snow") || name.endsWith("ice") || name == "rime"
		})
	});
	lightlikes = ["light","flash","laser","radiation","insulate_flash"];
	grbBreakIntos = Object.keys(elements).filter(function(elemName) {
		return elements[elemName].breakInto && elements[elemName].breakInto.includes("gamma_ray_burst");
	});

	elements.insulate_flash = {
		hidden: true,
		color: "#fffdcf",
		tick: function(pixel) {
			if (Math.random() < 0.75 && pixelTicks - pixel.start > 1) {
				deletePixel(pixel.x, pixel.y)
			}
		},
		reactions: {
			"blood": { elem1:"pointer" },
			"molten_stained_glass": { elem1:"rainbow" },
			"gray_goo": { elem1:"static" }
		},
		category: "energy",
		temp: 40,
		state: "gas",
		density: 1,
		tempLow: -270,
		stateLow: "light",
		hidden: true,
		noMix: true,
		insulate: true
	};

	elements.heat_ray.tick = function(pixel) {
		var x = pixel.x;
		for (var y = pixel.y; y < height; y++) {
			if (outOfBounds(x, y)) {
				break;
			}
			if (isEmpty(x, y)) {
				if (Math.random() > 0.025) { continue }
				createPixel("insulate_flash", x, y);
				pixelMap[x][y].color = "#ff0000";
			}
			else {
				if (elements[pixelMap[x][y].element].isGas) { pixelMap[x][y].temp -= 50; continue; }
				if (elements[pixelMap[x][y].element].id === elements.heat_ray.id) { break }
				pixelMap[x][y].temp += 100;
				break;
			}
		}
		deletePixel(pixel.x, pixel.y);
	};	

	elements.sun.isSun = true;
	if(elements.nellsun) { elements.nellsun.isSun = true };
	if(elements.rainbow_sun) { elements.rainbow_sun.isSun = true };

	elements.cold_ray = {
		color: ["#00ffae","#00ffff"],
		tick: function(pixel) {
			var x = pixel.x;
			for (var y = pixel.y; y < height; y++) {
				if (outOfBounds(x, y)) {
					break;
				}
				if (isEmpty(x, y)) {
					if (Math.random() > 0.05) { continue }
					createPixel("insulate_flash", x, y);
					pixelMap[x][y].color = "#00ffff";
				}
				else {
					if (elements[pixelMap[x][y].element].isGas) {
						if(elements[pixelMap[x][y].element].isSun) {
							pixelMap[x][y].temp -= 0.5;
						} else {
							pixelMap[x][y].temp -= 50;
						};
						continue; 
					};
					if (elements[pixelMap[x][y].element].id === elements.cold_ray.id) { break }
					pixelMap[x][y].temp -= 150;
					break;
				}
			}
			deletePixel(pixel.x, pixel.y);
		},
		temp: -200,
		category: "energy",
		state: "gas",
		excludeRandom: true,
		noMix: true
	};

	elements.freeze_ray = {
		color: ["#7fbfff","#bfffff"],
		tick: function(pixel) {
			var x = pixel.x;
			for (var y = pixel.y; y < height; y++) {
				if (outOfBounds(x, y)) {
					break;
				}
				if (isEmpty(x, y)) {
					if (Math.random() > 0.02) { continue }
					createPixel("insulate_flash", x, y);
					pixelMap[x][y].color = "#e1f8fc";
				}
				else {
					var otherPixel = pixelMap[x][y];
					var otherInfo = elements[otherPixel.element];
					//Gas: Freeze chance, cool, always penetrate
					if (otherInfo.isGas) {
						if(Math.random() < 0.05 && otherInfo.stateLow) {
							if(otherInfo.stateLow.includes("supernova") || otherInfo.stateLow.includes("gamma_ray_burst")) {
								//do nothing
							} else {
								freezePixel(otherPixel)
							};
						};
						if(elements[otherPixel.element].isSun) {
							otherPixel.temp -= 0.5;
						} else {
							otherPixel.temp -= 50;
						};
						continue;
					};

					//Self: Break
					if (otherInfo.id === elements.freeze_ray.id) { break }

					//Non-gas, Freeze chance, cool more, half penetrate
					if(Math.random() < 0.05 && otherInfo.stateLow) {
						if(otherInfo.stateLow.includes("supernova") || otherInfo.stateLow.includes("gamma_ray_burst")) {
							//do nothing
						} else {
							freezePixel(otherPixel)
						};
					};
					pixelMap[x][y].temp -= 150;

					if(Math.random() < 0.05) {
					
						if(!isEmpty(x,y-1,false)) {
							if(pixelMap[x]?.[y-1]?.element && lightlikes.includes(pixelMap[x][y-1].element)) {
								deletePixel(x,y-1);
							};
						};
						var newSnow = tryCreatePixelReturn("snow",x,y-1);
						if(newSnow) { newSnow.temp = -100 };
					};

					//Penetrate snow and ice
					if(snowAndIceCache && snowAndIceCache.includes(otherPixel.element)) {
						continue;
					};

					if(Math.random() < 0.7) { //thanks, I hate random continue
						continue;
					};
					break;
				}
			}
			deletePixel(pixel.x, pixel.y);
		},
		temp: -200,
		category: "energy",
		state: "gas",
		excludeRandom: true,
		noMix: true
	};

	var hasVelocity = enabledMods.includes("mods/velocity.js");

	elements.smash_ray = {
		color: ["#ff9999", "#8c8279"],
		tick: function(pixel) {
			var x = pixel.x;
			for (var y = pixel.y; y < height; y++) {
				if (outOfBounds(x, y)) {
					break;
				}
				if (isEmpty(x, y)) {
					if (Math.random() > 0.05) { continue }
					createPixel("flash", x, y);
					pixelMap[x][y].color = "#edd0c5";
				}
				else {
					var otherPixel = pixelMap[x][y]
					var otherInfo = elements[otherPixel.element];
					if (!(grbBreakIntos.includes(otherPixel.element))) {
						if (otherInfo.isGas) {
							if(Math.random() > ((otherInfo.hardness ?? 0) ** 2)) { breakPixel(otherPixel,false,false) };
							if(hasVelocity && otherPixel && !(lightlikes.includes(otherPixel.element))) {
								var vels = [randomIntegerBetweenTwoValues(-7,7),randomIntegerBetweenTwoValues(-7,7)];
								otherPixel.vx = vels[0];
								otherPixel.vy = vels[1];
							};
							continue;
							
						};
						if (otherInfo.id === elements.heat_ray.id) { break }
						if(Math.random() > ((otherInfo.hardness ?? 0) ** 2)) { breakPixel(otherPixel,false,false) };
						if(hasVelocity && otherPixel) {
							var vels = [randomIntegerBetweenTwoValues(-7,7),randomIntegerBetweenTwoValues(-5,0)];
							otherPixel.vx = vels[0];
							otherPixel.vy = vels[1];
						};
						if(Math.random() < Math.max(0.8,0.3 + ((1 - (otherInfo.hardness ?? 0)) / 2))) { //thanks, I hate random continue
							continue;
						};
						break;
					}
				}
			}
			deletePixel(pixel.x, pixel.y);
		},
		temp: 20,
		category: "energy",
		state: "gas",
		excludeRandom: true,
		noMix: true
	};

	//combines heat ray and smash ray
	elements.death_ray = {
		color: ["#a88d77", "#ff4a36"],
		tick: function(pixel) {
			var x = pixel.x;
			for (var y = pixel.y; y < height; y++) {
				if (outOfBounds(x, y)) {
					break;
				}
				if (isEmpty(x, y)) {
					if (Math.random() > 0.05) { continue }
					createPixel("insulate_flash", x, y);
					pixelMap[x][y].color = "#eb7b59";
				}
				else {
					var otherPixel = pixelMap[x][y]
					var otherInfo = elements[otherPixel.element];
					otherPixel.temp += (400 * (shiftDown + 1));
					if(otherPixel.del) { continue };
					if (!(grbBreakIntos.includes(otherPixel.element))) {
						if (otherInfo.isGas) {
							if(Math.random() > ((otherInfo.hardness ?? 0) ** (4 + shiftDown))) { breakPixel(otherPixel,false,false) };
							if(hasVelocity && otherPixel && !(lightlikes.includes(otherPixel.element))) {
								var vels = [randomIntegerBetweenTwoValues(-7 - (shiftDown * 2),7 + (shiftDown * 2)),randomIntegerBetweenTwoValues(-7 - (shiftDown * 2),7 + (shiftDown * 2))];
								otherPixel.vx = vels[0];
								otherPixel.vy = vels[1];
							};
							continue;
							
						};
						if (otherInfo.id === elements[pixel.element].id) { break }
						if(Math.random() > ((otherInfo.hardness ?? 0) ** (2 + shiftDown))) { breakPixel(otherPixel,false,false) };
						if(hasVelocity && otherPixel) {
							var vels = [randomIntegerBetweenTwoValues(-9 - (shiftDown * 2),9 + (shiftDown * 2)),randomIntegerBetweenTwoValues(-7 - (shiftDown * 2),0 + (shiftDown * 2))];
							otherPixel.vx = vels[0];
							otherPixel.vy = vels[1];
						};
						if(Math.random() < ((shiftDown / 20) + (Math.max(0.9,0.4 + ((1 - (otherInfo.hardness ?? 0)) / 2))))) { //thanks, I hate random continue
							continue;
						};
						break;
					}
				}
			}
			deletePixel(pixel.x, pixel.y);
		},
		temp: 4000,
		category: "energy",
		state: "gas",
		excludeRandom: true,
		noMix: true
	};

	elements.annihilation_ray = {
		color: ["#220c0c", "#c11515"],
		tick: function(pixel) {
			var x = pixel.x;
			for (var y = pixel.y; y < height; y++) {
				if (outOfBounds(x, y)) {
					break;
				}
				if (isEmpty(x, y)) {
					if (Math.random() > 0.05) { continue }
					createPixel("insulate_flash", x, y);
					pixelMap[x][y].color = "#292929";
				}
				else {
					var otherPixel = pixelMap[x][y];
					var otherInfo = elements[otherPixel?.element];

					if(otherPixel) {
						otherPixel.temp += 2500 * (shiftDown + 1);
						if(otherPixel.del || !otherPixel) { continue };

						if (otherPixel && grbBreakIntos.includes(otherPixel.element)) {
							if(Math.random() < 0.01 && otherPixel) {
								deletePixel(otherPixel.x,otherPixel.y);
							};
							continue;
						} else if(otherPixel) {
							breakPixel(otherPixel,false,false);
							if(otherPixel.del || !otherPixel) {
								continue
							};

							if(otherPixel && hasVelocity) {
								var vels = [randomIntegerBetweenTwoValues(-8,8),randomIntegerBetweenTwoValues(-6,0)];
								otherPixel.vx = vels[0];
								otherPixel.vy = vels[1];
							};

							if(otherPixel && Math.random() < (otherInfo.isGas ? 0.2 : 0.1)) {
								deletePixel(otherPixel.x,otherPixel.y);
								continue;
							};

							if(Math.random() > 0.8) {
								continue;
							};
						};
						if (otherInfo.id === elements[pixel.element].id) { break }
					};
				}
			}
			deletePixel(pixel.x, pixel.y);
		},
		temp: 150000000,
		category: "energy",
		state: "gas",
		excludeRandom: true,
		noMix: true
	};

	//bless falls within god ray
	elements.bless.reactions.dry_dirt = { elem2: "dirt" };
	elements.bless.reactions.dead_cum = { elem2: "cum" };
	elements.bless.reactions.dead_cum_water = { elem2: "cum_water" };
	elements.bless.reactions.dead_cum_ice = { elem2: "cum_ice" };
	elements.bless.reactions.dead_cum_water_ice = { elem2: "cum_water_ice" };
	elements.bless.reactions.dead_cum_snow = { elem2: "cum_snow" };
	elements.bless.reactions.dead_cummy_mud = { elem2: "cummy_mud" };
	elements.bless.reactions.dead_cummy_sand = { elem2: "cummy_sand" };
	elements.bless.reactions.dead_cummy_permafrost = { elem2: "cummy_permafrost" };
	elements.bless.reactions.burnt_cum = { elem2: null };
	elements.bless.reactions.poop = { elem2: null };
	elements.bless.reactions.dried_poop = { elem2: null };
	elements.bless.reactions.shit = { elem2: null };
	elements.bless.reactions.dried_shit = { elem2: null };
	elements.bless.reactions.frozen_shit = { elem2: null };
	elements.bless.reactions.diarrhea = { elem2: null };
	elements.bless.reactions.frozen_diarrhea = { elem2: null };
	elements.bless.reactions.piss = { elem2: null };
	elements.bless.reactions.vomit = { elem2: null };
	elements.bless.reactions.crimson_grass = { elem2: "grass" };
	elements.bless.reactions.crimstone = { elem2: "rock" };
	elements.bless.reactions.crimsand = { elem2: "sand" };
	elements.bless.reactions.red_ice = { elem2: "ice" };
	elements.bless.reactions.crimgravel = { elem2: "gravel" };
	elements.bless.reactions.crimwater = { elem2: "water" };
	elements.bless.reactions.crimsnow = { elem2: "snow" };
	elements.bless.reactions.vicious_mushroom = { elem2: null };
	elements.bless.reactions.crimson_vine = { elem2: "vine" };
	/*elements.bless.reactions.shadewood = { elem2: "wood" };
	elements.bless.reactions.shadewood_tree_branch = { elem2: "tree_branch" };
	elements.bless.reactions.shadewood_sapling = { elem2: "sapling" };
	elements.bless.reactions.shadewood_sawdust = { elem2: "sawdust" };
	elements.bless.reactions.crimson_leaf = { elem2: "leaf" };*/
	elements.bless.reactions.ichor = { elem2: null }; //per blood, absent the gods' immune systems (apparenly they don't need immune systems because of immortality anyway)
	elements.bless.reactions.virus_bomb = { elem2: null };
	elements.bless.reactions.life_eater_slurry = { elem2: null };
	elements.bless.reactions.life_eater_explosion = { elem2: null };
	elements.bless.reactions.life_eater_virus = { elem2: null };
	elements.bless.reactions.injector_poison = { elem2: null };
	elements.bless.reactions.dead_matter = { elem2: null };
	elements.bless.reactions.life_eater_infected_dirt = { elem2: "dirt" };
	elements.bless.reactions.poisoned_dirt = { elem2: "dirt" };
	elements.bless.reactions.vicious_goldfish = { elem2: "fish" };
	elements.bless.reactions.nellfire = { elem2: "bless" };
	elements.bless.reactions.gloomwind = { elem2: null };
	elements.bless.reactions.gloomfly = { elem2: null };
	elements.bless.reactions.meat_monster = { elem2: null };
	elements.bless.reactions.rotten_ravager = { elem2: null };
	elements.bless.reactions.bone_beast = { elem2: null };
	elements.bless.reactions.poisonwater = { elem2: "water" };
	elements.bless.reactions.poisoned_ice = { elem2: "ice" };
	elements.bless.reactions.poisoned_gas = { elem2: "steam" };
	elements.bless.reactions.corrupt_land = { elem2: "dirt" };
	elements.bless.reactions.corrupt_rock = { elem2: "rock" };
	elements.bless.reactions.withery = { elem2: null };
	elements.bless.reactions.withery_plant = { elem2: null };
	elements.bless.reactions.corrupt_solid_rock = { elem2: "rock_wall" };
	elements.bless.reactions.toxin = { elem2: "antidote" };
	elements.bless.reactions.dead = { elem2: null };
	elements.bless.reactions.brain = { elem2: null };
	elements.bless.reactions.bioooze = { elem2: null };
	elements.bless.tool = function(pixel) {
        if (elements.bless.ignore.indexOf(pixel.element) !== -1) { return; }
        if (pixel.burning) { // stop burning
            delete pixel.burning;
            delete pixel.burnStart;
        }
        if (pixel.nellburn) { // change: stop nellburn
            delete pixel.nellburn;
            delete pixel.nellburnStart;
        }
        if (pixel.temp > 100) {
            pixel.temp = (pixel.temp+100)/2;
            pixelTempCheck(pixel);
            if (pixel.del) {return}
        }
        if (pixel.origColor) {
            pixel.color = "rgb("+pixel.origColor.join(",")+")";
            delete pixel.origColor;
        }
        if (pixel.charge) {
            delete pixel.charge;
            pixel.chargeCD = 16;
        }
        if (elements.bless.reactions[pixel.element] && Math.random()<0.25) {
            var r = elements.bless.reactions[pixel.element];
            var elem2 = r.elem2;
            if (elem2 !== undefined) {
                if (Array.isArray(elem2)) { elem2 = elem2[Math.floor(Math.random()*elem2.length)]; }
                if (elem2 === null) { deletePixel(pixel.x,pixel.y) }
                else { changePixel(pixel, elem2); }
            }
        }
	};
});
} else {
	if(!enabledMods.includes(libraryMod))			{ enabledMods.splice(enabledMods.indexOf(modName),0,libraryMod) };
	if(!enabledMods.includes(runAfterAutogenMod))	{ enabledMods.splice(enabledMods.indexOf(modName),0,runAfterAutogenMod) };
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
	alert(`The "${runAfterAutogenMod}" and "${libraryMod}" mods are required and have been automatically inserted (reload for this to take effect).`);
};
elements.shock_ray = {
    color: ["#fffba6", "#8c8279"],
    tick: function (pixel) {
        var x = pixel.x;
        for (var y = pixel.y + 1; y < height; y++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.1) { continue }
                createPixel("electric", x, y);
            }
            else {
                if (elements[pixelMap[x][y].element].id === elements.flash.id) { continue }
                if (elements[pixelMap[x][y].element].id === elements.god_ray.id) { break }
                if (!elements[pixelMap[x][y].element].isGas && isEmpty(x, y - 1)) {
                    createPixel("electric", x, y - 1);
                }
                if (Math.random() > 0.1) { continue }
                elements.bless.tool(pixelMap[x][y])
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
	temp: 20,
	category: "energy",
	state: "gas",
	excludeRandom: true,
	noMix: true
};
elements.magic_ray = {
    color: ["#a270ff","#f2d9ff"],
    tick: function (pixel) {
        var x = pixel.x;
        for (var y = pixel.y + 1; y < height; y++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.1) { continue }
                createPixel("magic", x, y);
            }
            else {
                if (elements[pixelMap[x][y].element].id === elements.flash.id) { continue }
                if (elements[pixelMap[x][y].element].id === elements.god_ray.id) { break }
                if (!elements[pixelMap[x][y].element].isGas && isEmpty(x, y - 1)) {
                    createPixel("magic", x, y - 1);
                }
                if (Math.random() > 0.1) { continue }
                elements.bless.tool(pixelMap[x][y])
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    temp: 20,
    category: "energy",
    state: "gas",
    excludeRandom: true,
    noMix: true
};
function playSubspace(file) {
    var audio = new Audio("https://JustAGenericUsername.github.io/" + file + ".mp3");
    audio.play();
}
elements.subspace_tripmine = {
    color: "#2e2430",
    behavior: behaviors.STURDYPOWDER,
    maxSize: 1,
    cooldown: defaultCooldown,
    density: 1500,
    category: "weapons",
    state: "solid",
    properties:{
        counter: 0
    },
    tick: function(pixel){
        if (pixel.counter == 0){
            playSubspace("subspaceplace")
        }
        if (!pixel.rgb){pixel.rgb = pixel.color.match(/\d+/g);}
        if (pixel.counter >= 90 && pixel.counter < 121){
            if (!pixel.a){pixel.a = 1}
            pixel.a -= 0.05
            pixel.color = "rgba(" + pixel.rgb[0] + "," + pixel.rgb[1] + "," + pixel.rgb[2] + "," + pixel.a + ")"
        }
        if (pixel.counter >= 121){
            if (!isEmpty(pixel.x, pixel.y-1, true)){
                let oldx = pixel.x
                let oldy = pixel.y
                explodeAt(pixel.x, pixel.y, 20)
                playSubspace("subspaceboom")
                deletePixel(pixel.x, pixel.y)
                var coords = circleCoords(oldx, oldy, 25)
                for (var i = 0; i < coords.length; i++){
                    var x = coords[i].x
                    var y = coords[i].y
                    if (!isEmpty(x, y, true)){
                        var newPixel = pixelMap[x][y]
                        newPixel.color = pixelColorPick(pixel, "#FF00FF")
                    }
                }
            }
        }
        pixel.counter ++
    }
}
// feel free to add to/improve this mod

// this has bee worked on by:
// voidapex11

elements.tear_gas = {
    color: "#d5dce6",
    behavior: [
        "XX|XX|XX",
        "XX|XX|M2%2.5 AND BO",
        "XX|M1%1|XX"
    ],
    tick: function (pixel) {
        for (var i = 0; i < adjacentCoords.length; i++) {
            var coords = adjacentCoords[i];
            var x = pixel.x + coords[0];
            var y = pixel.y + coords[1];
            try { // this code causes errors acationally, who knows why.
                if (!isEmpty(x, y)) {
                    if (pixelMap[x][y].element == "tear_gas_grenade") {
                        var x = pixel.x - coords[0];
                        var y = pixel.y - coords[1];
                        tryMove(pixel, x, y)
                    }
                }
            } catch {} // lazy fix 
        }
    },
    category: "weapons",
    temp: 20,
    cooldown: 1,
    reactions: {
        "head": { elem2: ["head", "rotten_meat"], elem1: ["tear_gas", "tear_gas", "salt_water"], chance: 0.1, oneway: true },
        "body": { elem2: "rotten_meat", chance: 0.05, oneway: true },
    },
    tempLow: -30,
    state: "gas",
    density: 0.4,
    ignoreAir: true,
};

elements.tear_gas_grenade = {
    color: "#65665c",
    behavior: [
        "XX|CR:tear_gas|XX",
        "CR:tear_gas%80|EX:4>tear_gas%5|CR:tear_gas%80",
        "M2|M1|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 7300,
    conduct: 0.73,
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    excludeRandom: true,
    cooldown: 5,
    nocheer: true,
};

elements.sonic_grenade = {
    color: "#65665c",
    tick: function (pixel) {
        if (!pixel.primed) {
            ground=false
            num = 0
            coords=lineCoords(pixel.x,pixel.y,pixel.x,pixel.y+20)
            for (coord in coords) {
                pxl=coords[coord]
                if (!isEmpty(pxl[0],pxl[1])) {
                    if (num>=5) {
                        ground=true
                        break
                    }
                    if (elements[pixel.element].density>100||elements[pixel.element].hardness!==undefined) {
                        num++
                    }
                } else {
                    num--
                }
            }
            if (ground) {
                pixel.primed=true
            }
        }
        if ((pixel.primed||!isEmpty(pixel.x, pixel.y + 1))&&((Math.random() < 0.05) || (isEmpty(pixel.x, pixel.y + 1) && Math.random() < 0.3))) {
            // if ~random chance~ or it has something below it & ~higher random chance~: explode
            coords = circleCoords(pixel.x, pixel.y, 10);
            for (i in coords) {
                coord = coords[i]
                var x = coord.x;
                var y = coord.y;
                if (!isEmpty(x, y, true)) {
                    pxl = pixelMap[x][y]
                    if ((typeof elements[pxl.element].density == "number")||(elements[pxl.element].hardness!==undefined)) {
                        if ((elements[pxl.element].density > 2000)||(elements[pxl.element].hardness!==undefined)) {
                            if (elements[pxl.element].breakInto&&(Math.random()>0.2||pxl.element=="glass")) {
                                if (Math.random()>0.4) {
                                    deletePixel(x,y)
                                } else {
                                    breakPixel(pxl);
                                }
                                pxl = pixelMap[x][y]
                            }
                        }
                    }
                }
            }
            explodeAt(pixel.x, pixel.y, 3, "smoke")
            deletePixel(pixel.x, pixel.y)
            return
        } else {
            if (isEmpty(pixel.x, pixel.y + 1, true)) {
                // first, try to move straight down
                tryMove(pixel, pixel.x, pixel.y + 1)
            } else if ((Math.random() < 0.5) && isEmpty(pixel.x + 1, pixel.y + 1, true)) {
                tryMove(pixel, pixel.x + 1, pixel.y + 1)
            } else if (isEmpty(pixel.x - 1, pixel.y + 1, true)) {
                tryMove(pixel, pixel.x - 1, pixel.y + 1)
            }
        }
    },
    category: "weapons",
    state: "solid",
    density: 7300,
    conduct: 0.73,
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    excludeRandom: true,
    cooldown: 5,
    nocheer: true,
};
elements.tsar_bomba = {
    color: "#524C41",
    behavior: [
        "XX|EX:150>plasma|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:150>plasma|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.little_boy = {
    color: "#F5F5DC",
    behavior: [
        "XX|EX:20>plasma|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:70>plasma,plasma,plasma,plasma,radiation,fallout|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 500,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.fat_man = {
    color: ["#ffff00","#333333"],
    behavior: [
        "XX|EX:28>plasma|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:98>plasma,plasma,plasma,plasma,radiation,fallout|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1000,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.self_propelled_bomb = {
    color: "#71797E",
    tick: function(pixel) {
        if ((pixel.temp > 1000 || pixel.charge) && !pixel.burning) {
            pixel.burning = true;
            pixel.burnStart = pixelTicks;
        }
        if (pixel.burning) {
            if (!tryMove(pixel, pixel.x, pixel.y-1)) {
                // tryMove again to the top left or top right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y-1);
            }
            if (pixelTicks-pixel.burnStart > 50 && Math.random() < 0.1) {
                explodeAt(pixel.x, pixel.y, 10, "bomb");
            }
        }
        else {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                // tryMove again to the bottom left or bottom right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y+1);
            }
        }
        doDefaults(pixel);
    },
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "weapons"
},
elements.left_missile = {
    color: "#4c4e42",
    behavior: [
        "M2|EX:10|XX",
        "M1 AND EX:10|XX|EX:10",
        "M2|EX:10|XX",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.right_missile = {
    color: "#4c4e42",
    behavior: [
        "XX|EX:10|M2",
       "EX:10|XX|M1 AND EX:10",
        "XX|EX:10|M2",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.up_missile = {
    color: "#4c4e42",
    behavior: [
        "M2|M1 AND EX:10|M2",
       "EX:10|XX|EX:10",
        "XX|EX:10|XX",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
    elements.cluster_munition = {
    color: "#444444",
    behavior: [
        "XX|EX:10>smoke,smoke,smoke,smoke,bomb,bomb|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10>smoke,smoke,smoke,smoke,bomb,cluster_munition|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
},
    elements.RL_cluster_munition = {
    color: "#444444",
    behavior: [
        "XX|XX|XX",
        "CRcluster%20|XX|CR:cluster%20",
        "M2|M1|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
},
    elements.cluster = {
    color: "#444444",
    behavior: [
        "XX|EX:10%10|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10%10|M2",
    ],
    category: "ammunition",
    state: "solid",
    density: 1300,
    hidden: true,
},
    elements.machine_gun_left = {
    color: "#C0C0C0",
    behavior: [
        "XX|XX|XX",
        "CR:left_bullet|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
},
    elements.machine_gun_right = {
    color: "#C0C0C0",
    behavior: [
        "XX|XX|XX",
        "XX|XX|CR:right_bullet",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
},
elements.left_bullet = {
    color: "#4c4e42",
    behavior: [
        "M2|XX|XX",
        "M1 AND DB|XX|XX",
        "M2|XX|XX",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
    elements.right_bullet = {
    color: "#4c4e42",
    behavior: [
        "XX|XX|M2",
        "XX|XX|M1 AND DB",
        "XX|XX|M2",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
    elements.e_gun_left = {
    color: "#C0C0C0",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "CR:left_bullet|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    conduct: 1,
    density: 1300,
},
    elements.e_gun_right = {
    color: "#C0C0C0",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "XX|XX|CR:right_bullet",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    conduct: 1,
    density: 1300,
},
    elements.auto_rocket_launcher_left = {
    color: "#C0C0C0",
    behavior: [
        "XX|XX|XX",
        "CR:left_rocket|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
},
    elements.auto_rocket_launcher_right = {
    color: "#C0C0C0",
    behavior: [
        "XX|XX|XX",
        "XX|XX|CR:right_rocket",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
},
elements.left_rocket = {
    color: "#4c4e42",
    behavior: [
        "XX|XX|XX",
        "M1 AND EX:10|XX|XX",
        "XX|XX|XX",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
    elements.right_rocket = {
    color: "#4c4e42",
    behavior: [
        "XX|XX|XX",
        "XX|XX|M1 AND EX:10",
        "XX|XX|XX",
    ],
    state: "solid",
    category:"ammunition",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
    elements.e_rocket_launcher_left = {
    color: "#C0C0C0",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "CR:left_rocket|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    conduct: 1,
    density: 1300,
},
    elements.e_rocket_launcher_right = {
    color: "#C0C0C0",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "XX|XX|CR:right_rocket",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    conduct: 1,
    density: 1300,
},
elements.gaster_blast_left = {
    color: "#c5e9f0",
    behavior: [
        "DL|DL|XX",
        "DL AND CR:gaster_blast_left%5|XX|XX",
        "DL|DL|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-2, pixel.y)) {
                if (!isEmpty(pixel.x-2, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x-2][pixel.y];
                    if (newPixel.element === "gaster_blast_left") { break; }
                    if (elements[newPixel.element].state == "gas") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "energy",
    state: "gas",
    insulate: true,
},
elements.gaster_blast_right = {
    color: "#c5e9f0",
    behavior: [
        "XX|DL|DL",
        "XX|XX|DL AND CR:gaster_blast_right%5",
        "XX|DL|DL",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+2, pixel.y)) {
                if (!isEmpty(pixel.x+2, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x+2][pixel.y];
                    if (newPixel.element === "gaster_blast_right") { break; }
                    if (elements[newPixel.element].state == "gas") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "energy",
    state: "gas",
    insulate: true,
},
    elements.gaster_blaster_left = {
    color: "#ffffff",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "CR:gaster_blast_left|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    conduct: 20,
},
    elements.gaster_blaster_right = {
    color: "#ffffff",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "XX|XX|CR:gaster_blast_right",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    conduct: 20,
},
elements.fast_bullet_left = {
    color: "#4c4e42",
    behavior: [
        "XX|DL|XX",
        "XX|XX|XX",
        "XX|DL|XX",
    ],
tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-3, pixel.y)) {
                if (!isEmpty(pixel.x-3, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x-3][pixel.y];
                    if (newPixel.element === "fast_bullet_left") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "ammunition",
    state: "solid",
    insulate: true,
},
elements.fast_bullet_right = {
    color: "#4c4e42",
    behavior: [
        "XX|DL|XX",
        "XX|XX|XX",
        "XX|DL|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+3, pixel.y)) {
                if (!isEmpty(pixel.x+3, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x+3][pixel.y];
                    if (newPixel.element === "fast_bullet_right") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "ammunition",
    state: "solid",
    insulate: true,
},
elements.flak_cannon = {
    color: "#C0C0C0",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|CR:flak|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    conduct: 1,
},
    elements.flak = {
    color: "#f0f0f0",
    tick: function(pixel) {
        if ((pixel.temp > 10 || pixel.charge) && !pixel.burning) {
            pixel.burning = true;
            pixel.burnStart = pixelTicks;
        }
        if (pixel.burning) {
            if (!tryMove(pixel, pixel.x, pixel.y-1)) {
                // tryMove again to the top left or top right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y-1);
            }
            if (pixelTicks-pixel.burnStart > 50 && Math.random() < 0.005) {
                explodeAt(pixel.x, pixel.y, 10, "flak_shrapnel");
            }
        }
        else {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                // tryMove again to the bottom left or bottom right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y+1);
            }
        }
        doDefaults(pixel);
    },
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "ammunition"
},
    elements.flak_shrapnel = {
    color: "#71797E",
       behavior: [
        "XX|XX|XX",
        "XX|EX:5 %10|XX",
        "M2|M1|M2",
    ],
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "ammunition"
},
elements.fighter_jet_left = {
    color: "#bcc6cc",
    behavior: [
        "M1%0.2|M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap",
        "M1 AND CR:fast_bullet_left|XX|CR:smoke AND EX:5>metal_scrap",
        "M1%0.2|M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap",
    ],
tick: function(pixel) {
    for (var i=0; i<2; i++) {
            if (!tryMove(pixel, pixel.x-1, pixel.y)) {
                if (!isEmpty(pixel.x-1, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x-1][pixel.y];
                    if (newPixel.element === "fast_bullet_left") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "aircrafts",
    breakInto: "metal_scrap"
 },
elements.fighter_jet_right = {
    color: "#bcc6cc",
    behavior: [
        "M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap|M1%0.2",
        "CR:smoke AND EX:5>metal_scrap|XX|M1 AND CR:fast_bullet_right",
        "M2%0.005 AND EX:5>metal_scrap|M2%0.005 AND EX:5>metal_scrap|M1%0.2",
    ],
tick: function(pixel) {
    for (var i=0; i<2; i++) {
            if (!tryMove(pixel, pixel.x+1, pixel.y)) {
                if (!isEmpty(pixel.x+1, pixel.y,true)) {
                    var newPixel = pixelMap[pixel.x+1][pixel.y];
                    if (newPixel.element === "fast_bullet_right") { break; }
                    if (elements[newPixel.element].state == "solid") {
                        if (Math.random() > (elements[newPixel.element].hardness || 0)) {
                            if (elements[newPixel.element].breakInto) {
                                breakPixel(newPixel);
                            }
                            else {
                                deletePixel(newPixel.x, newPixel.y);
                            }}}}
                deletePixel(pixel.x,pixel.y);
                break;
            }}},
    category: "aircrafts",
    breakInto: "metal_scrap"
 },
elements.machine_for_throwing_bombs_at_you_left = {
    color: "#524c41",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "CR:bombs_for_throwing_at_you_left|XX|XX",
        "XXXX|XX",
    ],
    category: "weapons",
    conduct: 1
},
elements.bombs_for_throwing_at_you_left = {
    color: "#524c41",
    category: "ammunition",
    behavior: [
        "XX|EX:10>bomb|XX",
        "XX|XX|XX",
        "M1|M1%10 AND EX:10>bomb|XX",
    ],
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
}
elements.machine_for_throwing_bombs_at_right = {
    color: "#524c41",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "XX|XX|CR:bombs_for_throwing_at_you_right",
        "XXXX|XX",
    ],
    category: "weapons",
    conduct: 1
},
elements.bombs_for_throwing_at_you_right = {
    color: "#524c41",
    category: "ammunition",
    behavior: [
        "XX|EX:10>bomb|XX",
        "XX|XX|XX",
        "XX|M1%10 AND EX:10>bomb|M1",
    ],
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.energized_orb_left = {
    color: ["#e0e000","#f3f300"],
    category: "energy",
    behavior: [
        "XX|EX:50>electric|XX",
        "M1 AND EX:50>electric|XX|EX:50>electric",
        "XX|EX:50>electric|XX"
    ],
    state: "gas",
},
elements.energized_orb_right = {
    color: ["#e0e000","#f3f300"],
    category: "energy",
    behavior: [
        "XX|EX:50>electric|XX",
        "EX:50>electric|XX|M1 AND EX:50>electric",
        "XX|EX:50>electric|XX"
    ],
    state: "gas",
},
elements.fast_bomb = {
    color: "#524c41",
    category: "weapons",
    state: "solid",
    behavior: [
        "XX|EX:10>explosion|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10>explosion|M2",
        ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                if (!isEmpty(pixel.x, pixel.y+1,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.liquid_bomb = {
    color: "#524c41",
    tick: function(pixel) {
                if (pixel.start === pixelTicks) {return}
                if (pixel.charge && elements[pixel.element].behaviorOn) {
                    pixelTick(pixel)
                }
                if (elements[pixel.element].viscosity && (!((Math.random()*100) < 100 / Math.pow(elements[pixel.element].viscosity, 0.25)))) {
                    var move1Spots = [
                        [pixel.x, pixel.y+1]
                    ]
                }
                else {
                    var move1Spots = [
                        [pixel.x+1, pixel.y+1],
                        [pixel.x, pixel.y+1],
                        [pixel.x-1, pixel.y+1],
                    ]
                }
                var moved = false;
                for (var i = 0; i < move1Spots.length; i++) {
                    var coords = move1Spots[Math.floor(Math.random()*move1Spots.length)];
                    if (tryMove(pixel, coords[0], coords[1])) { moved = true; break; }
                    else { move1Spots.splice(move1Spots.indexOf(coords), 1); }
                }
                if (!moved) {
                    if (elements[pixel.element].viscosity===undefined || !(!((Math.random()*100) < 100 / Math.pow(elements[pixel.element].viscosity, 0.25)))) {
                        if (Math.random() < 0.5) {
                            if (!tryMove(pixel, pixel.x+1, pixel.y)) {
                                tryMove(pixel, pixel.x-1, pixel.y);
                            }
                        } else {
                            if (!tryMove(pixel, pixel.x-1, pixel.y)) {
                                tryMove(pixel, pixel.x+1, pixel.y);
                            }
                        }
                    }
                }
                doDefaults(pixel);
            },
    category: "weapons",
    state: "liquid",
    behavior: [
        "XX|EX:10>explosion|XX",
        "XX|XX|XX",
        "XX|EX:10>explosion|XX",
        ],
    density: 1300,
    excludeRandom: true,
    ignore: "gas_bomb",
    cooldown: defaultCooldown
},
elements.gas_bomb = {
    color: "#524c41",
    tick: function(pixel) {
                if (pixel.start === pixelTicks) {return}
                if (pixel.charge && elements[pixel.element].behaviorOn) {
                    pixelTick(pixel)
                }
                var move1Spots = [
                    [pixel.x, pixel.y+1],
                    [pixel.x, pixel.y-1],
                    [pixel.x+1, pixel.y],
                    [pixel.x-1, pixel.y],
                ]
                var moved = false;
                for (var i = 0; i < move1Spots.length; i++) {
                    var coords = move1Spots[Math.floor(Math.random()*move1Spots.length)];
                    if (tryMove(pixel, coords[0], coords[1])) { moved = true; break; }
                    else { move1Spots.splice(move1Spots.indexOf(coords), 1);}
                }
                if (!moved) {
                    var move2Spots = [
                        [pixel.x+1, pixel.y+1],
                        [pixel.x-1, pixel.y+1],
                        [pixel.x+1, pixel.y-1],
                        [pixel.x-1, pixel.y-1],
                    ]
                    for (var i = 0; i < move2Spots.length; i++) {
                        var coords = move2Spots[Math.floor(Math.random()*move2Spots.length)];
                        if (tryMove(pixel, coords[0], coords[1])) { break; }
                        else { move2Spots.splice(move2Spots.indexOf(coords), 1); }
                    }
                }
                doDefaults(pixel);
            },
    category: "weapons",
    state: "gas",
    behavior: [
        "XX|EX:10>explosion|XX",
        "XX|XX|XX",
        "XX|EX:10>explosion|XX",
        ],
    density: 1300,
    excludeRandom: true,
    ignore: "liquid_bomb",
    cooldown: defaultCooldown
}
elements.tank_left = {
    color: "#bcc6cc",
    category: "vehicles",
    behavior: [
        "M2 AND CR:fast_bullet_left|XX|XX",
        "M1|XX|XX",
        "M1|M1|XX",
    ],
},
elements.tank_right = {
    color: "#bcc6cc",
    category: "vehicles",
    behavior: [
        "XX|XX|M2 AND CR:fast_bullet_right",
        "XX|XX|M1",
        "XX|M1|M1",
    ],
},
elements.realistic_missile_left = {
    color: "#524c41",
    category: "weapons",
    state: "solid",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M1 AND EX:20>missile_shrapnel|XX|EX:20>missile_shrapnel|CR:smoke AND EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x-1, pixel.y)) {
                if (!isEmpty(pixel.x-1, pixel.y,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.realistic_missile_right = {
    color: "#524c41",
    category: "weapons",
    state: "solid",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|CR:smoke AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX|M1|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|M2 AND EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x+1, pixel.y)) {
                if (!isEmpty(pixel.x+1, pixel.y,true)) {
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
    elements.missile_shrapnel = {
    color: "#71797E",
       behavior: [
        "XX|XX|XX",
        "XX|EX:5 %20|XX",
        "M2%20|M1%20|M2%20",
    ],
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "ammunition"
},
elements.vlms_left = {
    color: "#71797E",
    tick: function(pixel) {
        if ((pixel.temp > 1000 || pixel.charge) && !pixel.burning) {
            pixel.burning = true;
            pixel.burnStart = pixelTicks;
        }
        if (pixel.burning) {
            if (!tryMove(pixel, pixel.x, pixel.y-1)) {
                // tryMove again to the top left or top right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y-1);
            }
            if (pixelTicks-pixel.burnStart > 50 && Math.random() < 0.1) {
                explodeAt(pixel.x, 10, 4, "realistic_missile_left");
                deletePixel(pixel.x,pixel.y)
            }
        }
        else {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                // tryMove again to the bottom left or bottom right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y+1);
            }
        }
        doDefaults(pixel);
    },
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "weapons"
},
elements.vlms_right = {
    color: "#71797E",
    tick: function(pixel) {
        if ((pixel.temp > 1000 || pixel.charge) && !pixel.burning) {
            pixel.burning = true;
            pixel.burnStart = pixelTicks;
        }
        if (pixel.burning) {
            if (!tryMove(pixel, pixel.x, pixel.y-1)) {
                // tryMove again to the top left or top right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y-1);
            }
            if (pixelTicks-pixel.burnStart > 50 && Math.random() < 0.1) {
                explodeAt(pixel.x, 10, 4, "realistic_missile_right");
                deletePixel(pixel.x,pixel.y)
            }
        }
        else {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                // tryMove again to the bottom left or bottom right
                tryMove(pixel, pixel.x+(Math.random() < 0.5 ? -1 : 1), pixel.y+1);
            }
        }
        doDefaults(pixel);
    },
    burn: 90,
    burnTime: 100,
    density: 2000,
    conduct: 1,
    state: "solid",
    category: "weapons"
},
createAtXvar = 0;
createAtYvar = 0;
create1var = "";
elements.element_spawner = {
    color: "#71797E",
    onSelect: function() {
        var answer1 = prompt("Please input the x value.",(createAtXvar||undefined));
        if (!answer1) {return}
        createAtXvar = parseInt(answer1);
        var answer2 = prompt("Please input the y value.",(createAtYvar||undefined));
        if (!answer2) {return}
        createAtYvar = parseInt(answer2);
        var answer3 = prompt("Please input what element should spawn.",(create1var||undefined));
        if (!answer3) {return}
        create1var = answer3;
    },
    tick: function(pixel) {
        if (pixel.charge){
            createPixel(create1var, createAtXvar, createAtYvar);
        }
        doDefaults(pixel);
    },
    density: 1,
    conduct: 1,
    state: "solid",
    category: "machines"
},
elements.railgun_beam_left = {
    color: ["#ff0000","#ff5e00"],
    tick: function(pixel) {
        var y = pixel.y;
        for (var x = pixel.x; x < width; x--) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                createPixel("railgun_ammo_left", x, y);
                pixelMap[x][y].temp = 3500;
            }
            else {
                if (elements[pixelMap[x][y].element].isGas) { continue }
                if (elements[pixelMap[x][y].element].id === elements.railgun_beam_left.id) { break }
                pixelMap[x][y].temp += 100;
                pixelTempCheck(pixelMap[x][y]);
                break;
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    temp: 3500,
    category: "ammunition",
    state: "gas",
    density: 1,
    excludeRandom: true,
    noMix: true
},
elements.railgun_beam_right = {
    color: ["#ff0000","#ff5e00"],
    tick: function(pixel) {
        var y = pixel.y;
        for (var x = pixel.x; x < width; x++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                createPixel("railgun_ammo_right", x, y);
                pixelMap[x][y].temp = 3500;
            }
            else {
                if (elements[pixelMap[x][y].element].isGas) { continue }
                if (elements[pixelMap[x][y].element].id === elements.railgun_beam_right.id) { break }
                pixelMap[x][y].temp += 100;
                pixelTempCheck(pixelMap[x][y]);
                break;
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    temp: 3500,
    category: "ammunition",
    state: "gas",
    density: 1,
    excludeRandom: true,
    noMix: true
},
elements.railgun_ammo_left = {
    color: ["#ff0000","#ff5e00"],
    category: "ammunition",
    state: "solid",
    density: 1300,
    tick: function(pixel) {
        explodeAt(pixel.x, pixel.y, 10)
        doHeat(pixel);
    },
},
elements.railgun_ammo_right = {
    color: ["#ff0000","#ff5e00"],
    category: "ammunition",
    state: "solid",
    density: 1300,
    tick: function(pixel) {
        explodeAt(pixel.x, pixel.y, 10)
        doHeat(pixel);
    },
},
elements.railgun_left = {
    category: "weapons",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "CR:railgun_beam_left|XX|XX",
        "XX|XX|XX",
    ],
    color: "#71797E",
    conduct: 1,
    hardness: 1,
},
elements.railgun_right = {
    category: "weapons",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|XX|XX",
        "XX|XX|CR:railgun_beam_right",
        "XX|XX|XX",
    ],
    color: "#71797E",
    conduct: 1,
    hardness: 1,
},
elements.static_bomb = {
    color: "#524c41",
    behavior: [
        "XX|EX:10|XX",
        "EX:10|XX|EX:10",
        "XX|EX:10|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
}
var target =[,];
var tgt = "head";
elements.tracking_missile = {
    color: "#323232",
    category: "weapons",
    behavior: [
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel",
        "XX|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|EX:20>missile_shrapnel|XX",
    ],
    onSelect: function() {
        var answer1 = prompt("Please input the target element.",(tgt||undefined));
        if (!answer1) {return}
        tgt = answer1;
    },
    tick: (pixel) => {
        for (var x = 1; x < width; x++) {
            for (var y = 1; y < height; y++) {
                if (!isEmpty(x,y)) {
                    if (pixelMap[x][y].element===tgt) {
                        target = [pixelMap[x][y].x, pixelMap[x][y].y];
                    }
                }
            }
        }
        if (pixel.x != target[0] || pixel.y != target[1]) {
            let {x, y} = pixel;
            const empty = checkForEmptyPixels(x, y);
            const [tX, tY] = target;
            let bestVal = Math.sqrt(Math.pow(tX - x, 2) + Math.pow(tY - y, 2));
            let best = null;
            for (const pixelPair of empty) {
                const [x_, y_] = [x + pixelPair[0], y + pixelPair[1]];
                const c = Math.sqrt(Math.pow(tX - x_, 2) + Math.pow(tY - y_, 2));
                if (c < bestVal) {
                    bestVal = c;
                    best = pixelPair;
                }
            }
            if (best) {
                tryMove(pixel, x + best[0]*2, y + best[1]*2, undefined, true);
            }
        } 
    }
},
elements.laser_bomb = {
    category: "weapons",
    color: "#524c41",
    tick: function(pixel) {
        var x = pixel.x;
        for (var y = pixel.y; y < height+1; y++) {
            if (outOfBounds(x, y)) {
                if (isEmpty(x, y-1)) { createPixel("smoke", x, y-1); }
                break;
            }
            if (isEmpty(x, y)) {

                createPixel("flash", x, y);
                pixelMap[x][y].color = "#ff0000";
                pixelMap[x][y].temp = 35000;
                pixelMap[x][y].delay = (y + pixel.y) / 8;
            }
        }
        for (var y = pixel.y; y < height-1; y--) {
            if (outOfBounds(x, y)) {
                if (isEmpty(x, y+1)) { createPixel("smoke", x, y+1); }
                break;
            }
            if (isEmpty(x, y)) {

                createPixel("flash", x, y);
                pixelMap[x][y].color = "#ff0000";
                pixelMap[x][y].temp = 35000;
                pixelMap[x][y].delay = (y + pixel.y) / 8;
            }
        }
        var y = pixel.y;
        for (var x = pixel.x; x < width+1; x++) {
            if (outOfBounds(x, y)) {
                if (isEmpty(x-1, y)) { createPixel("smoke", x-1, y); }
                break;
            }
            if (isEmpty(x, y)) {

                createPixel("flash", x, y);
                pixelMap[x][y].color = "#ff0000";
                pixelMap[x][y].temp = 35000;
                pixelMap[x][y].delay = (x + pixel.x) / 8;
            }
        }
        for (var x = pixel.x; x < width-1; x--) {
            if (outOfBounds(x, y)) {
                if (isEmpty(x+1, y)) { createPixel("smoke", x+1, y); }
                break;
            }
            if (isEmpty(x, y)) {

                createPixel("flash", x, y);
                pixelMap[x][y].color = "#ff0000";
                pixelMap[x][y].temp = 35000;
                pixelMap[x][y].delay = (x + pixel.x) / 8;
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
},
elements.cluster_nuke = {
    color: "#323232",
    category: "weapons",
    behavior: behaviors.POWDER,
    tick: (pixel) => {
        for (var y = 1; y < 50; y++) {
            if (!isEmpty(pixel.x, pixel.y + y, false)) {
                explodeAt(pixel.x,pixel.y,50,["dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","dirty_bomb","nuke",])
            }
        }
    }
}
document.onkeydown = function(ki)/*keyboard_input*/ {
    //a
    if (ki.keyCode == 65) {
        KA = true;
        //vX ++;
    }
    //d
    if (ki.keyCode == 68) {
        KD = true;
        //vX ++;
    }
    //w
    if (ki.keyCode == 87) {
        KW = true;
        //vY ++;
    }
    //s
    if (ki.keyCode == 83) {
        KS = true;
        //vY ++;
    }
}
document.onkeyup = function(i2)/*keyboard_input*/ {
    //a
    if (i2.keyCode == 65) {
        KA = false;
        //vX --;
    }
    //d
    if (i2.keyCode == 68) {
        KD = false;
       //vX --;
    }
    //w
    if (i2.keyCode == 87) {
        KW = false;
        //vY = 0;
    }
    //s
    if (i2.keyCode == 83) {
        KS = false;
        //vY = 0;
    }
}
var KA = false;
var KD = false;
var KW = false;
var KS = false;
var vX = 1;
var vY = 1;
elements.heli_bomb = {
    behavior: [
        "XX|EX:10|XX",
        "EX:10|XX|EX:10",
        "XX|EX:10|XX",
    ],
    tick: function(pixel) {
    /*if (vX === 3) {
            vX --;
        }
    if (vY === 3) {
            vY --;
        }*/
    if (KA === true) {
            tryMove (pixel,pixel.x-vX,pixel.y)
        }
    if (KD === true) {
            tryMove (pixel,pixel.x+vX,pixel.y)
        }
    if (KW === true) {
            tryMove (pixel,pixel.x,pixel.y-vY)
        }
    if (KS === true) {
            tryMove (pixel,pixel.x,pixel.y+vY)
        }
    },
    category: "weapons",
    states:"solid",
    color: "#524c41",
},
elements.mini_nuke = {
    color: "#534636",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:20>plasma,plasma,plasma,plasma,radiation,rad_steam|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1500,
    excludeRandom: true,
    cooldown: defaultCooldown
},
elements.left_uranium_bullet = {
    color: "#406040",
    behavior: [
        "M2|XX|XX",
        "M1 AND EX:4>fallout|XX|XX",
        "M2|XX|XX",
    ],
    state: "solid",
    category:"ammunition",
    density: 2100,
    excludeRandom: true,
    cooldown: defaultCooldown,
    temp: 4000,
},
elements.right_uranium_bullet = {
    color: "#406040",
    behavior: [
        "XX|XX|M2",
        "XX|XX|M1 AND EX:4>fallout",
        "XX|XX|M2",
    ],
    state: "solid",
    category:"ammunition",
    density: 2100,
    excludeRandom: true,
    cooldown: defaultCooldown,
    temp: 4000,
}
velocityBlacklist = [];

function explodeAtPlus(x,y,radius,fire="fire",smoke="smoke",beforeFunction=null,afterFunction=null,changeTemp=true) {
	// if fire contains , split it into an array
	if(fire !== null) {
		if (fire.indexOf(",") !== -1) {
			fire = fire.split(",");
		};
	};
	if(smoke !== null) {
		if (smoke.indexOf(",") !== -1) {
			smoke = smoke.split(",");
		};
	};
	var coords = circleCoords(x,y,radius);
	var power = radius/10;
	//for (var p = 0; p < Math.round(radius/10+1); p++) {
	for (var i = 0; i < coords.length; i++) {
		// damage value is based on distance from x and y
		var damage = Math.random() + (Math.floor(Math.sqrt(Math.pow(coords[i].x-x,2) + Math.pow(coords[i].y-y,2)))) / radius;
		// invert
		damage = 1 - damage;
		if (damage < 0) { damage = 0; }
		damage *= power;
		if (isEmpty(coords[i].x,coords[i].y)) {
			// create smoke or fire depending on the damage if empty
			if (damage < 0.02) { } // do nothing
			else if (damage < 0.2) {
				// if smoke is an array, choose a random item
				if(smoke !== null) {
					if (Array.isArray(smoke)) {
						createPixel(smoke[Math.floor(Math.random() * smoke.length)],coords[i].x,coords[i].y);
					}
					else {
						createPixel(smoke,coords[i].x,coords[i].y);
					}
				}
			}
			else {
				if(fire !== null) {
					// if fire is an array, choose a random item
					if (Array.isArray(fire)) {
						createPixel(fire[Math.floor(Math.random() * fire.length)],coords[i].x,coords[i].y);
					}
					else {
						createPixel(fire,coords[i].x,coords[i].y);
					}
				}
			}
		}
		else if (!outOfBounds(coords[i].x,coords[i].y)) {
			// damage the pixel
			var pixel = pixelMap[coords[i].x][coords[i].y];
			var info = elements[pixel.element];
			if(typeof(beforeFunction) === "function") {
				beforeFunction(pixel,x,y,radius,fire,smoke,power,damage);
			};
			if (info.hardness) { // lower damage depending on hardness(0-1)
				if (info.hardness < 1) {
					damage = damage * ((1 - info.hardness)*10);
				}
				else { damage = 0; }
			}
			if (damage > 0.9) {
				if(fire !== null) {
					if (Array.isArray(fire)) {
						var newfire = fire[Math.floor(Math.random() * fire.length)];
					}
					else {
						var newfire = fire;
					}
					changePixel(pixel,newfire,changeTemp);
				} else {
					deletePixel(pixel.x,pixel.y);
				}
				continue;
			}
			else if (damage > 0.25) {
				if (info.breakInto) {
					// if it is an array, choose a random item, else just use the value
					if (Array.isArray(info.breakInto)) {
						var result = info.breakInto[Math.floor(Math.random() * info.breakInto.length)];
					}
					else {
						var result = info.breakInto;
					}
					if(typeof(breakIntoElement) === "undefined") {
						deletePixel(pixel.x,pixel.y);
						continue
					};
					// change the pixel to the result
					changePixel(pixel,result,changeTemp);
					if(info.onExplosionBreakOrSurvive) {
						info.onExplosionBreakOrSurvive(pixel,x,y,radius,fire,smoke,power,damage);
					};
					continue;
				}
				else {
					if(fire !== null) {
						if (Array.isArray(fire)) {
							var newfire = fire[Math.floor(Math.random() * fire.length)];
						}
						else {
							var newfire = fire;
						}
						changePixel(pixel,newfire,changeTemp);
					} else {
						deletePixel(pixel.x,pixel.y);
					}
					continue;
				}
			} else {
				if(info.onExplosionBreakOrSurvive) {
					info.onExplosionBreakOrSurvive(pixel,x,y,radius,fire,smoke,power,damage);
				};
			}
			if (damage > 0.75 && info.burn) {
				pixel.burning = true;
				pixel.burnStart = pixelTicks;
			}
			pixel.temp += damage*radius*power;
			pixelTempCheck(pixel);
			if(enabledMods.includes("mods/velocity.js")) {
            // set the pixel.vx and pixel.vy depending on the angle and power
				if (!elements[pixel.element].excludeRandom && !elements[pixel.element].excludeVelocity) {
					var angle = Math.atan2(pixel.y-y,pixel.x-x);
					pixel.vx = Math.round((pixel.vx|0) + Math.cos(angle) * (radius * power/10));
					pixel.vy = Math.round((pixel.vy|0) + Math.sin(angle) * (radius * power/10));
				}
			};
			if(typeof(afterFunction) === "function") {
				//console.log(`running afterFunction ${afterFunction}`)
				//console.log(`arguments: ${pixel}, ${x}, ${y}, ${radius}, ${fire}, ${smoke}, ${power}, ${damage}`)
				afterFunction(pixel,x,y,radius,fire,smoke,power,damage);
			};
		};
	};
};
function whenAvailable(names, callback) {
    var interval = 10; // ms
    window.setTimeout(function() {
		let bool = true;
		for(let i = 0; i < names.length; i++)
		{
			if(!window[names[i]])
			{
				bool = false;
			}
		}
        if (bool) {
            callback();
        } else {
            whenAvailable(names, callback);
        }
    }, interval);
}
var modName = "mods/mobs.js";
var explodeAtPlusMod = "mods/explodeAtPlus.js";
var runAfterAutogenMod = "mods/runAfterAutogen2.js";
var libraryMod = "mods/code_library.js";
var mobsLoaded = false;
if(enabledMods.includes(runAfterAutogenMod) && enabledMods.includes(explodeAtPlusMod) && enabledMods.includes(libraryMod)) {
whenAvailable(["runAfterAutogen","explodeAtPlus"], function() {
	//Prerequisite Functions and Variables

	minimumCreeperTries = 3;
	maximumCreeperTries = 3;

	minimumZombieTries = 3;
	maximumZombieTries = 3;

	minimumSkeletonTries = 3;
	maximumSkeletonTries = 3;

	eLists.CREEPER = ["creeper", "angelic_creeper", "hell_creeper", "bombing_creeper", "baby_creeper"];

	headBodyObject = {
		"head": "body",
		"creeper_head": "creeper_body",
		"angelic_creeper_head": "angelic_creeper_body",
		"hell_creeper_head": "hell_creeper_body",
		"bombing_creeper_head": "bombing_creeper_body",
		"zombie_head": "zombie_body",
		"skeleton_head": "skeleton_body",
		"nothing_there_phase_3_head": "nothing_there_phase_3_body",
	};

	var style = document.createElement('style'); //Initialize CSS for creeper spawning's status indicator
	style.type = 'text/css';
	style.id = 'creeperStatusStylesheet';
	//initial style conditional branch
	if(typeof(settings.creeperSpawning) === "undefined") { //undefined (falsy but it needs special handling)
		style.innerHTML = '.creeperStatus { color: #E11; text-decoration: none; }';
	} else {
		if(!settings.creeperSpawning) { //falsy: red
			style.innerHTML = '.creeperStatus { color: #E11; text-decoration: none; }';
		} else if(settings.creeperSpawning) { //truthy: green
			style.innerHTML = '.creeperStatus { color: #1E1; text-decoration: none; }';
		};
	};
	document.getElementsByTagName('head')[0].appendChild(style);

	function coordPyth(xA,yA,xB,yB) { //Distance function, used for explosion trigger
		var a = Math.abs(xB - xA);
		var b = Math.abs(yB - yA);
		var c = Math.sqrt(a**2 + b**2);
		return c;
	};

	function pythSpeed(number1,number2) {
		return Math.sqrt(number1**2 + number2**2);
	};

	function rgbColorBound(number) { //RGB bounding function, used for safety checking color changes
		return Math.min(255,Math.max(0,number));
	};

	function slBound(number) { //SL bounding function (not hue), same use as above
		return Math.min(100,Math.max(0,number));
	};

	function angelicUpwardVelocity(pixel,x,y,radius,fire,smoke,power) { //Angelic Creeper's effect, "compatible" with velocity.js by including the modified version of its code in itself
		var info = elements[pixel.element]
		if(enabledMods.includes("mods/velocity.js")) {
			//console.log("yeet");
			// set the pixel.vx and pixel.vy depending on the angle and power
			if (!elements[pixel.element].excludeRandom) {
				//console.log("LOOKS LIKE IT'S YEETING TIME!");
				var angle = Math.atan2(pixel.y-y,pixel.x-x);
				//console.log(`angle calculated (${angle})`);
				pixel.vx = Math.round((pixel.vx|0) + Math.cos(angle) * (radius * power/10));
				//console.log(`vx calculated (${pixel.vx}) for pixel (${pixel.x},${pixel.y})`);
				pixel.vy = 0 - Math.abs(Math.round((pixel.vy|0) + Math.sin(angle) * (radius * power/4)) + 4); //massively increased Y velocities even for objects below
				//pixel.color = "rgb(255,0,0)";
				//console.log(`vy calculated (${pixel.vy}) for pixel (${pixel.x},${pixel.y})`);
			};
			//console.log(`Velocities set`);
		};
		//console.log(`end`);
	};

	//afterFunction(pixel,x,y,radius,fire,smoke,power,damage);
	function hellExplosionFire(pixel,x,y,radius,fire,smoke,power,damage) { //Angelic Creeper's effect, "compatible" with velocity.js by including the modified version of its code in itself
		var coords = circleCoords(pixel.x,pixel.y,radius);
		for (var i = 0; i < coords.length; i++) {
			var x = coords[i].x;
			var y = coords[i].y;
			if(!isEmpty(x,y,true)) {
				var pixel = pixelMap[x][y];
				var info = elements[pixel.element]
				if (info.burn) { //Light everything on fire
					pixel.burning = true;
					pixel.burnStart = pixelTicks;
					pixel.temp += 10; //smoke prevention
				} else if(Math.random() < 0.05) { //5%/px cursed burning
					pixel.burning = true;
					pixel.burnStart = pixelTicks;
					pixel.temp += 10;
				};
			} else if(isEmpty(x,y)) { //if there's space for fire
				if (Array.isArray(fire)) { //this should remain "fire"
					var newfire = fire[Math.floor(Math.random() * fire.length)];
				} else {
					var newfire = fire;
				};
				createPixel(newfire,x,y); //add fire
				var firePixel = pixelMap[x][y];
				firePixel.temp = Math.max(elements[newfire].temp,firePixel.temp);
				firePixel.burning = true;
			};
		};
	};

	//explodeAtPlus moved to separate file

	if(typeof(settings.creeperSpawning) === "undefined") { //Default creeper setting
		setSetting("creeperSpawning",false);
	};

	function updateCreeperPreferences() { //Creeper setting handler
		if(settings.creeperSpawning) { //If the setting is on
			if(typeof(randomEvents.creeper) !== "function") { //add the event if it's missing
				randomEvents.creeper = function() {
					var amount = Math.floor((Math.random() * maximumCreeperTries)+minimumCreeperTries); //1-3
					//In worldgen worlds, you can expect about half of this because about half of the world is pixels in it.
					for(i = 0; i < amount; i++) { //dummy for to break
						if(settings.creeperSpawning) { //setting validation
							// random x between 1 and width-1
							var x = Math.floor(Math.random()*(width-1))+1;
							// random y between 1 and height
							var y = Math.floor(Math.random()*height-1)+1;
							if (isEmpty(x,y)) {
								// random element from the list of spawnable creepers
								var element = spawnCreepers[Math.floor(Math.random()*spawnCreepers.length)];
								// if element is an array, choose a random element from the array
								if (Array.isArray(element)) {
									element = element[Math.floor(Math.random()*element.length)];
								}
								createPixel(element,x,y);
							};
						} else { //if false (this function is never supposed to fire with the setting false)
							delete randomEvents.creeper; //self-disable
							//substitute event
							var event = randomEvents[Object.keys(randomEvents)[Math.floor(Math.random()*Object.keys(randomEvents).length)]];
							event();
							break;
						};
					};
				};
			};
		} else if(!settings.creeperSpawning) { //and if it's off
			if(randomEvents.creeper) { delete randomEvents.creeper }; //delete it if it exists.
		};
	};

	function toggleCreeperSpawning() { //Creeper toggle handler
		if(settings.creeperSpawning != true) { //If it's false
			setSetting("creeperSpawning",true); //make it true and update the status display CSS
			updateCreeperPreferences(); //apply
			document.getElementById("creeperStatusStylesheet").innerHTML = '.creeperStatus { color: #1E1; text-decoration: underline; }'; //Displayed info doen't update until it's pulled up again, so I'm using CSS to dynamically change the color of an element, like with find.js (RIP).
		} else { //and the inverse if it's true
			setSetting("creeperSpawning",false);
			updateCreeperPreferences();
			document.getElementById("creeperStatusStylesheet").innerHTML = '.creeperStatus { color: #E11; text-decoration: none; }';
		};
	};
	
	//Functions used by Nothing There

	function hasPixel(x,y,elementInput) {
		if(isEmpty(x,y,true)) { //if empty, it can't have a pixel
			return false;
		} else {
			if(elementInput.includes(",")) { //CSTA
				elementInput = elementInput.split(",");
			};
			if(Array.isArray(elementInput)) { //if element list
				return elementInput.includes(pixelMap[x][y].element);
			} else { //if single element
				return pixelMap[x][y].element === elementInput;
			};
		};		
	};

	function breakPixel(pixel,changetemp=false,defaultBreakIntoDust=false) {
		var info = elements[pixel.element];
		if(typeof(info.breakInto) === "undefined") {
			if(defaultBreakIntoDust) {
				if(Math.random() < defaultBreakIntoDust) { changePixel(pixel,"dust",changetemp) };
			};
			return defaultBreakIntoDust;
		};
		var breakIntoElement = info.breakInto;
		if(Array.isArray(breakIntoElement)) {
			breakIntoElement = breakIntoElement[Math.floor(Math.random() * breakIntoElement.length)]
		};
		if(typeof(breakIntoElement) === "undefined" || breakIntoElement === null) {
			deletePixel(pixel.x,pixel.y);
			return true;
		};
		changePixel(pixel,breakIntoElement,changetemp)
		return true;
	};

	defaultHardness = 0;

	function arrowAltTb(pixel,breakChanceMultiplier,changetemp=false,defaultBreakIntoDust=false) {
		var info = elements[pixel.element];
		var hardness = defaultHardness;
		if(typeof(info.hardness) === "number") {
			hardness = info.hardness;
		};
		hardness = 1 - hardness; //invert hardness, so a hardness of 0 becomes a 100% chance and a hardness of 1 becomes a 0% chance
		hardness *= breakChanceMultiplier;
		if(Math.random() < hardness) {
			return breakPixel(pixel,changetemp=false,defaultBreakIntoDust=false);
		} else {
			return false;
		};
	};

	function nothingThereBulletMovement(pixel,x,y) {
		if(!tryMove(pixel,x,y)) {
			if(!isEmpty(x,y,true)) {
				var thisDensity = elements[pixel.element].density;
				var newPixel = pixelMap[x][y];
				var newElement = newPixel.element;
				var newInfo = elements[newElement];
				var newHardness = 0;
				if(nothingThereBulletExcludedElements.includes(newElement)) {
					return false;
				};
				if(typeof(newInfo.hardness) === "number") {
					newHardness = newInfo.hardness;
					//it's inverted later
				};
				if(typeof(newInfo.state) === "undefined" && newElement !== pixel.element) { //Copy-paste of "break" code
					if(Math.random() < ((1 - newHardness) ** 0.6)) {
						swapPixels(pixel,newPixel);
						//console.log(`nothingThereBulletMovement: Breaking pixel (${newPixel.element}, ${newPixel.x}, ${newPixel.y}))`)
						breakPixel(newPixel,false,0.3);
						return true;
					} else {
						deletePixel(pixel.x,pixel.y);
						return false;
					};
				} else {
					if(newElement == pixel.element) {
						swapPixels(pixel,newPixel);
						return true;
					} else if(newInfo.state == "gas") {
						swapPixels(pixel,newPixel);
						return true;
					} else if(newInfo.state == "liquid") {
						var newDensity = 1000;
						if(typeof(newInfo.density) === "number") {
							newDensity = newInfo.density;
							//console.log(`density ${newInfo.density} for ${newElement}`);   
						//} else {
							//console.log(`undef density for ${newElement}, 1000 default`);   
						};
						//console.log(`thisDensity: ${thisDensity}`);
						//console.log(`newDensity: ${newDensity}`);
						var chance = thisDensity/(thisDensity+newDensity);
						//console.log(`${newElement}, ${chance}`)
						if(Math.random() < chance) {
							swapPixels(pixel,newPixel);
						};
						return true;
					} else if(newInfo.state == "solid") {
						if(Math.random() < ((1 - newHardness) ** 0.6)) {
							swapPixels(pixel,newPixel);
							//console.log(`nothingThereBulletMovement: Breaking pixel (${newPixel.element}, ${newPixel.x}, ${newPixel.y}))`)
							breakPixel(newPixel,false,0.3);
							return true;
						} else {
							deletePixel(pixel.x,pixel.y);
							return false;
						};
					};
				};
			} else {
				return false;
			};
		} else {
			return true;
		};
	};

	//End NT functions

	nothingThereBulletExcludedElements = ["wall","nothing_there_phase_1","nothing_there_phase_2","nothing_there_phase_3_body","nothing_there_phase_3_head", "nothing_there_cleaver", "nothing_there_mace"];

	enemyHumanoidArray = ["head","body"] //just in case

	spawnCreepers = ["creeper","baby_creeper","angelic_creeper","bombing_creeper","hell_creeper"];

	if(settings.creeperSpawning) { //creeper spawning option
		randomEvents.creeper = function() {
			var amount = Math.floor((Math.random() * maximumCreeperTries)+minimumCreeperTries); //1-3
			for(i = 0; i < amount; i++) { //dummy for to break
				if(settings.creeperSpawning) { //setting validation
					// random x between 1 and width-1
					var x = Math.floor(Math.random()*(width-1))+1;
					// random y between 1 and height
					var y = Math.floor(Math.random()*height-1)+1;
					if (isEmpty(x,y)) {
						// random element from the list of spawnable creepers
						var element = spawnCreepers[Math.floor(Math.random()*spawnCreepers.length)];
						// if element is an array, choose a random element from the array
						if (Array.isArray(element)) {
							element = element[Math.floor(Math.random()*element.length)];
						}
						createPixel(element,x,y);
					};
				} else { //if false (this function is never supposed to fire with the setting false)
					delete randomEvents.creeper; //self-disable
					//substitute event
					var event = randomEvents[Object.keys(randomEvents)[Math.floor(Math.random()*Object.keys(randomEvents).length)]];
					event();
					break;
				};
			};
		};
	};

	standaloneSpawnCreeper = function(amount=1) {
		/*	The amount is the maximum amount of *attempts*. Often, less creepers will spawn due to things in the way.
			In a generated world, which uses half of the space, you can expect about half of this number to spawn.	*/
		for(i = 0; i < amount; i++) { //dummy for to break
			// random x between 1 and width-1
			var x = Math.floor(Math.random()*(width-1))+1;
			// random y between 1 and height
			var y = Math.floor(Math.random()*height-1)+1;
			if (isEmpty(x,y)) {
				// random element from the list of spawnable creepers
				var element = spawnCreepers[Math.floor(Math.random()*spawnCreepers.length)];
				// if element is an array, choose a random element from the array
				if (Array.isArray(element)) {
					element = element[Math.floor(Math.random()*element.length)];
				}
				createPixel(element,x,y);
			};
		};
	};

	//Prerequisite Functions and Variables

	function headHasBody(pixel) {
		var pX = pixel.x;
		var pY = pixel.y;
		//console.log("Checking head for body");
		if(Object.keys(headBodyObject).includes(pixel.element)) {
			//console.log("The head has a corresponding body element.");
			if(typeof(pixelMap[pX][pY+1]) === "undefined") {
				//console.log("The body's place is empty.");
				return false;
			} else {
				var bodyPixel = pixelMap[pX][pY+1];
				//console.log("The body's place is not empty.");
				return (bodyPixel.element === headBodyObject[pixel.element]);
			};
		} else {
			//console.log("The head does not have corresponding body element.");
			return null;
		};
	};

	function bodyHasHead(pixel) {
		var pX = pixel.x;
		var pY = pixel.y;
		//console.log("Checking body for head");
		if(Object.values(headBodyObject).includes(pixel.element)) {
			//console.log("The body has a corresponding head element.");
			if(typeof(pixelMap[pX][pY-1]) === "undefined") {
				//console.log("The head's place is empty.");
				return false;
			} else {
				var headPixel = pixelMap[pX][pY-1];
				//console.log("The head's place is not empty.");
				return (headPixel.element === getKeyByValue(headBodyObject,pixel.element));
			};
		} else {
			//console.log("The body does not have corresponding head element.");
			return null;
		};
	};

	function zombifyHuman(pixel) {
		var pX = pixel.x;
		var pY = pixel.y;
		if(!["head","body"].includes(pixel.element)) {
			//console.log("Not part of a human");
			return false;
		} else {
			if(pixel.element === "head") {
				//console.log("Head");
				if(headHasBody(pixel)) {
					//console.log("There's also a body");
					var body = pixelMap[pX][pY+1];
					changePixel(body,"zombie_body",false);
					//console.log("Body turned (head path)");
				};
				changePixel(pixel,"zombie_head");
				//console.log("Head turned (head path)");
			} else {
				//console.log("Not head (i.e. body)");
				if(bodyHasHead(pixel)) {
					//console.log("There's also a head");
					var head = pixelMap[pX][pY-1];
					changePixel(head,"zombie_head",false);
					//console.log("Head turned (body path)");
				};
				changePixel(pixel,"zombie_body");
				//console.log("Body turned (body path)");
			};
		};
	};

	function dezombifyHuman(pixel) {
		var pX = pixel.x;
		var pY = pixel.y;
		if(!["zombie_head","zombie_body"].includes(pixel.element)) {
			return false;
		} else {
			if(pixel.element === "zombie_head") {
				if(headHasBody(pixel)) {
					var body = pixelMap[pX][pY+1];
					changePixel(body,"body",false);
				};
				changePixel(pixel,"head");
			} else {
				if(bodyHasHead(pixel)) {
					var head = pixelMap[pX][pY-1];
					changePixel(head,"head",false);
				};
				changePixel(pixel,"body");
			};
		};
	};

	elements.spawner = {
		color: "#1c3038",
		breakInto: ["steel","steel","smoke",null,null,null,null,null],
		properties: {
			spawnCounter: 0,
			spawnTime: 160,
			spawn: null,
			squadiusX: 4,
			squadiusY: 4,
			spawnTries: 4,
			//spawnRangeMax: null, //Disabled by default for performance and because I can't think of how to make it count MPL elements towards the limit
		},
		tick: function(pixel) {
			//validation
			if(Array.isArray(pixel.spawn)) {
				pixel.spawn = pixel.spawn.filter(function(e){ return elementExists(e) });
				if(pixel.spawn.length == 0) {
					pixel.spawn = null;
				};
			} else {
				if(!elementExists(pixel.spawn)) {
					pixel.spawn = null;
				};
			};
			if(pixel.spawn === null) {
				return false;
			};
			if(pixel.spawnCounter <= 0) {
				//var pixelsOfSpawnElement = 0;
				
				var newSpawn = pixel.spawn;
				if(Array.isArray(newSpawn)) {
					newSpawn = newSpawn[Math.floor(Math.random() * newSpawn.length)];
				};

				var xForMin = -1 * pixel.squadiusX;
				var xForMax = pixel.squadiusX + 1;
				var yForMin = -1 * pixel.squadiusY;
				var yForMax = pixel.squadiusY + 1;
				
				/*if(pixel.spawnRangeMax !== null) {
					for(xOffset = xForMin; xOffset < xForMax; xOffset++) {
						for(yOffset = yForMin; yOffset < yForMax; yOffset++) {
							var newX = pixel.x + xOffset;
							var newY = pixel.y + yOffset;
							if(isEmpty(newX,newY,true) || outOfBounds(newX,newY)) {
								continue;
							};
							newPixel = pixelMap[newX][newY];
							if(newPixel.element == pixel.spawn || pixel.spawn.includes(newPixel.element)) {
								pixelsOfSpawnElement++;
							};
						};
					};
					if(pixelsOfSpawnElement > pixel.spawnRangeMax) {
						return false;
					};
				};*/

				for(s = 0; s < pixel.spawnTries; s++) {
					var randomX = pixel.x + randomIntegerBetweenTwoValues(0 - pixel.squadiusX, pixel.squadiusX);
					var randomY = pixel.y + randomIntegerBetweenTwoValues(0	- pixel.squadiusY, pixel.squadiusY);
					if(isEmpty(randomX,randomY,false)) {
						createPixel(newSpawn,randomX,randomY);
					};
				};
				pixel.spawnCounter = pixel.spawnTime;
			} else {
				pixel.spawnCounter--;
			};
		},
		hardness: 0.7,
		state: "solid",
	}

	if(enabledMods.includes("mods/fey_and_more.js")) {
		elements.spawner.breakInto.push("magic");
	};

	elements.frozen_rotten_meat = {
		color: ["#8FB588", "#8FA888"],
		behavior: [
			"XX|CR:plague,stench,stench%0.125 AND CH:meat>rotten_meat%1 AND CH:frozen_meat>frozen_rotten_meat%0.85|XX",
			"SP%99 AND CH:meat>rotten_meat%1 AND CH:frozen_meat>frozen_rotten_meat%0.85|XX|SP%99 AND CH:meat>rotten_meat%1 AND CH:frozen_meat>frozen_rotten_meat%0.85",
			"XX|M1 AND CH:meat>rotten_meat%1 AND CH:frozen_meat>frozen_rotten_meat%0.85|XX",
		],
		temp: -18,
		tempHigh: 0,
		stateHigh: "rotten_meat",
		category:"food",
		hidden:true,
		state: "solid",
		density: 1037.5,
	};

	elements.rotten_meat.tempLow = -18;
	elements.rotten_meat.stateLow = "frozen_rotten_meat";

	elements.zombie_blood = {
		color: ["#d18228", "#9a9e2f"],
		behavior: behaviors.LIQUID,
		reactions: {
			"vaccine": { "elem2":null, "chance": 0.01 },
			"plague": { "elem2":null, "chance": 0.01 },
			"virus": { "elem2":null, "chance": 0.01 },
			"cancer": { "elem1":"cancer", "chance": 0.02 },
			/*"rat": { "elem2":"infection", "chance":0.075 },
			"flea": { "elem1":"infection", "chance":0.03 },
			"dirt": { "elem1":null, "elem2":"mud" },
			"sand": { "elem1":null, "elem2":"wet_sand" },
			"mercury": { "elem1":"infection", "elem2":null, "chance":0.05 },
			"carbon_dioxide": { "elem2":null, "chance":0.05 },
			"alcohol": { "elem1":[null,"dna"], "chance":0.02 },*/
			"oxygen": { "elem2":null, "chance":0.04 },
			"blood": { "elem2":"zombie_blood", "chance":0.1 },
		},
		viscosity: 30,
		tempHigh: 127.55,
		stateHigh: ["steam","salt","oxygen","plague"],
		tempLow: 0,
		category:"liquids",
		state: "liquid",
		density: 1160,
		stain: 0.06,
		tick: function(pixel) {
			if(Math.random() < 0.2) {
				var pX = pixel.x;
				var pY = pixel.y;
				for(i = 0; i < adjacentCoords.length; i++) {
					var coord = adjacentCoords[i];
					var oX = coord[0];
					var oY = coord[1];
					var nX = pX+oX;
					var nY = pY+oY;
					if(isEmpty(nX,nY,true)) {
						continue;
					} else {
						var newPixel = pixelMap[nX][nY];
						var newElement = newPixel.element;
						if(enemyHumanoidArray.includes(newElement)) {
							if(Math.random() < 0.1) { zombifyHuman(newPixel) };
						};
					};
				};
			};
		},
	};

	var style = document.createElement('style'); //Initialize CSS for zombie spawning's status indicator
	style.type = 'text/css';
	style.id = 'zombieStatusStylesheet';
	//initial style conditional branch
	if(typeof(settings.zombieSpawning) === "undefined") { //undefined (falsy but it needs special handling)
		style.innerHTML = '.zombieStatus { color: #E11; text-decoration: none; }';
	} else {
		if(!settings.zombieSpawning) { //falsy: red
			style.innerHTML = '.zombieStatus { color: #E11; text-decoration: none; }';
		} else if(settings.zombieSpawning) { //truthy: green
			style.innerHTML = '.zombieStatus { color: #1E1; text-decoration: none; }';
		};
	};
	document.getElementsByTagName('head')[0].appendChild(style);

	if(typeof(settings.zombieSpawning) === "undefined") { //Default zombie setting
		setSetting("zombieSpawning",false);
	};

	function updateZombiePreferences() { //Zombie setting handler
		if(settings.zombieSpawning) { //If the setting is on
			if(typeof(randomEvents.zombie) !== "function") { //add the event if it's missing
				randomEvents.zombie = function() {
					var amount = Math.floor((Math.random() * maximumZombieTries)+minimumZombieTries); //1-3
					//In worldgen worlds, you can expect about half of this because about half of the world is pixels in it.
					for(i = 0; i < amount; i++) { //dummy for to break
						if(settings.zombieSpawning) { //setting validation
							// random x between 1 and width-1
							var x = Math.floor(Math.random()*(width-1))+1;
							// random y between 1 and height
							var y = Math.floor(Math.random()*height-1)+1;
							if (isEmpty(x,y)) {
								// random element from the list of spawnable zombies
								var element = spawnZombies[Math.floor(Math.random()*spawnZombies.length)];
								// if element is an array, choose a random element from the array
								if (Array.isArray(element)) {
									element = element[Math.floor(Math.random()*element.length)];
								}
								createPixel(element,x,y);
							};
						} else { //if false (this function is never supposed to fire with the setting false)
							delete randomEvents.zombie; //self-disable
							//substitute event
							var event = randomEvents[Object.keys(randomEvents)[Math.floor(Math.random()*Object.keys(randomEvents).length)]];
							event();
							break;
						};
					};
				};
			};
		} else if(!settings.zombieSpawning) { //and if it's off
			if(randomEvents.zombie) { delete randomEvents.zombie }; //delete it if it exists.
		};
	};

	function toggleZombieSpawning() { //Zombie toggle handler
		if(settings.zombieSpawning != true) { //If it's false
			setSetting("zombieSpawning",true); //make it true and update the status display CSS
			updateZombiePreferences(); //apply
			document.getElementById("zombieStatusStylesheet").innerHTML = '.zombieStatus { color: #1E1; text-decoration: underline; }'; //Displayed info doen't update until it's pulled up again, so I'm using CSS to dynamically change the color of an element, like with find.js (RIP).
		} else { //and the inverse if it's true
			setSetting("zombieSpawning",false);
			updateZombiePreferences();
			document.getElementById("zombieStatusStylesheet").innerHTML = '.zombieStatus { color: #E11; text-decoration: none; }';
		};
	};

	spawnZombies = ["zombie","baby_zombie"];

	if(settings.zombieSpawning) { //zombie spawning option
		randomEvents.zombie = function() {
			var amount = Math.floor((Math.random() * maximumZombieTries)+minimumZombieTries); //1-3
			for(i = 0; i < amount; i++) { //dummy for to break
				if(settings.zombieSpawning) { //setting validation
					// random x between 1 and width-1
					var x = Math.floor(Math.random()*(width-1))+1;
					// random y between 1 and height
					var y = Math.floor(Math.random()*height-1)+1;
					if (isEmpty(x,y)) {
						// random element from the list of spawnable zombies
						var element = spawnZombies[Math.floor(Math.random()*spawnZombies.length)];
						// if element is an array, choose a random element from the array
						if (Array.isArray(element)) {
							element = element[Math.floor(Math.random()*element.length)];
						}
						createPixel(element,x,y);
					};
				} else { //if false (this function is never supposed to fire with the setting false)
					delete randomEvents.zombie; //self-disable
					//substitute event
					var event = randomEvents[Object.keys(randomEvents)[Math.floor(Math.random()*Object.keys(randomEvents).length)]];
					event();
					break;
				};
			};
		};
	};

	standaloneSpawnZombie = function(amount=1) {
		/*	The amount is the maximum amount of *attempts*. Often, less zombies will spawn due to things in the way.
			In a generated world, which uses half of the space, you can expect about half of this number to spawn.	*/
		for(i = 0; i < amount; i++) { //dummy for to break
			// random x between 1 and width-1
			var x = Math.floor(Math.random()*(width-1))+1;
			// random y between 1 and height
			var y = Math.floor(Math.random()*height-1)+1;
			if (isEmpty(x,y)) {
				// random element from the list of spawnable zombies
				var element = spawnZombies[Math.floor(Math.random()*spawnZombies.length)];
				// if element is an array, choose a random element from the array
				if (Array.isArray(element)) {
					element = element[Math.floor(Math.random()*element.length)];
				}
				createPixel(element,x,y);
			};
		};
	};

	var style = document.createElement('style'); //Initialize CSS for skeleton spawning's status indicator
	style.type = 'text/css';
	style.id = 'skeletonStatusStylesheet';
	//initial style conditional branch
	if(typeof(settings.skeletonSpawning) === "undefined") { //undefined (falsy but it needs special handling)
		style.innerHTML = '.skeletonStatus { color: #E11; text-decoration: none; }';
	} else {
		if(!settings.skeletonSpawning) { //falsy: red
			style.innerHTML = '.skeletonStatus { color: #E11; text-decoration: none; }';
		} else if(settings.skeletonSpawning) { //truthy: green
			style.innerHTML = '.skeletonStatus { color: #1E1; text-decoration: none; }';
		};
	};
	document.getElementsByTagName('head')[0].appendChild(style);

	if(typeof(settings.skeletonSpawning) === "undefined") { //Default skeleton setting
		setSetting("skeletonSpawning",false);
	};

	function updateSkeletonPreferences() { //Skeleton setting handler
		if(settings.skeletonSpawning) { //If the setting is on
			if(typeof(randomEvents.skeleton) !== "function") { //add the event if it's missing
				randomEvents.skeleton = function() {
					var amount = Math.floor((Math.random() * maximumSkeletonTries)+minimumSkeletonTries); //1-3
					//In worldgen worlds, you can expect about half of this because about half of the world is pixels in it.
					for(i = 0; i < amount; i++) { //dummy for to break
						if(settings.skeletonSpawning) { //setting validation
							// random x between 1 and width-1
							var x = Math.floor(Math.random()*(width-1))+1;
							// random y between 1 and height
							var y = Math.floor(Math.random()*height-1)+1;
							if (isEmpty(x,y)) {
								// random element from the list of spawnable skeletons
								var element = spawnSkeletons[Math.floor(Math.random()*spawnSkeletons.length)];
								// if element is an array, choose a random element from the array
								if (Array.isArray(element)) {
									element = element[Math.floor(Math.random()*element.length)];
								}
								createPixel(element,x,y);
							};
						} else { //if false (this function is never supposed to fire with the setting false)
							delete randomEvents.skeleton; //self-disable
							//substitute event
							var event = randomEvents[Object.keys(randomEvents)[Math.floor(Math.random()*Object.keys(randomEvents).length)]];
							event();
							break;
						};
					};
				};
			};
		} else if(!settings.skeletonSpawning) { //and if it's off
			if(randomEvents.skeleton) { delete randomEvents.skeleton }; //delete it if it exists.
		};
	};

	function toggleSkeletonSpawning() { //Skeleton toggle handler
		if(settings.skeletonSpawning != true) { //If it's false
			setSetting("skeletonSpawning",true); //make it true and update the status display CSS
			updateSkeletonPreferences(); //apply
			document.getElementById("skeletonStatusStylesheet").innerHTML = '.skeletonStatus { color: #1E1; text-decoration: underline; }'; //Displayed info doen't update until it's pulled up again, so I'm using CSS to dynamically change the color of an element, like with find.js (RIP).
		} else { //and the inverse if it's true
			setSetting("skeletonSpawning",false);
			updateSkeletonPreferences();
			document.getElementById("skeletonStatusStylesheet").innerHTML = '.skeletonStatus { color: #E11; text-decoration: none; }';
		};
	};

	spawnSkeletons = ["skeleton"];

	if(settings.skeletonSpawning) { //skeleton spawning option
		randomEvents.skeleton = function() {
			var amount = Math.floor((Math.random() * maximumSkeletonTries)+minimumSkeletonTries); //1-3
			for(i = 0; i < amount; i++) { //dummy for to break
				if(settings.skeletonSpawning) { //setting validation
					// random x between 1 and width-1
					var x = Math.floor(Math.random()*(width-1))+1;
					// random y between 1 and height
					var y = Math.floor(Math.random()*height-1)+1;
					if (isEmpty(x,y)) {
						// random element from the list of spawnable skeletons
						var element = spawnSkeletons[Math.floor(Math.random()*spawnSkeletons.length)];
						// if element is an array, choose a random element from the array
						if (Array.isArray(element)) {
							element = element[Math.floor(Math.random()*element.length)];
						}
						createPixel(element,x,y);
					};
				} else { //if false (this function is never supposed to fire with the setting false)
					delete randomEvents.skeleton; //self-disable
					//substitute event
					var event = randomEvents[Object.keys(randomEvents)[Math.floor(Math.random()*Object.keys(randomEvents).length)]];
					event();
					break;
				};
			};
		};
	};

	standaloneSpawnSkeleton = function(amount=1) {
		/*	The amount is the maximum amount of *attempts*. Often, less skeletons will spawn due to things in the way.
			In a generated world, which uses half of the space, you can expect about half of this number to spawn.	*/
		for(i = 0; i < amount; i++) { //dummy for to break
			// random x between 1 and width-1
			var x = Math.floor(Math.random()*(width-1))+1;
			// random y between 1 and height
			var y = Math.floor(Math.random()*height-1)+1;
			if (isEmpty(x,y)) {
				// random element from the list of spawnable skeletons
				var element = spawnSkeletons[Math.floor(Math.random()*spawnSkeletons.length)];
				// if element is an array, choose a random element from the array
				if (Array.isArray(element)) {
					element = element[Math.floor(Math.random()*element.length)];
				}
				createPixel(element,x,y);
			};
		};
	};

	/*Start Main Zombie
		..................
		.........###......
		.......#######....
		......#####OOOOO..
		....######OOOOOOO.
		...########OOOOO..
		...###########....
		...###########....
		...###########....
		....##########....
		......########....
		.......##...##....
		.......##...##....
		..................
	*/

	elements.zombie = {
		color: ["#567C44","#199A9A","#41369B"],
		category: "life",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("zombie_body", pixel.x, pixel.y+1);
				pixel.element = "zombie_head";
				pixel.color = pixelColorPick(pixel)
			}
			else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("zombie_head", pixel.x, pixel.y-1);
				pixelMap[pixel.x][pixel.y-1].color = pixel.color;
				pixel.element = "zombie_body";
				pixel.color = pixelColorPick(pixel)
			}
			else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["zombie_body","zombie_head"],
		desc: "<em>I'd rather this be toggleable mid-game than require a reload.</em><br/><br/><span class=\"zombieStatus\">If this text is green or underlined, zombies (all types) can spawn.</span> <span onclick=toggleZombieSpawning() style=\"color: #ff00ff;\";>Click here</span> to toggle zombie spawning. If it's on, zombies can spawn through random events."
	};

	elements.zombie_body = {
		color: "#27719D",
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "rotten_meat",
		tempLow: -30,
		stateLow: "frozen_rotten_meat",
		burn: 10,
		burnTime: 250,
		burnInto: "rotten_meat",
		breakInto: ["zombie_blood","rotten_meat"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","rotten_meat","rotten_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.025 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
		},
		movable: true,
		tick: function(pixel) {
			if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
				if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
					var headPixel = pixelMap[pixel.x][pixel.y-2];
					if (headPixel.element == "zombie_head") {
						if (isEmpty(pixel.x, pixel.y-1)) {
							movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
						}
						else {
							swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
						}
					}
				}
			}
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 100
				if (pixelTicks-pixel.dead > 100) {
					changePixel(pixel,"rotten_meat");
				};
				return;
			};

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true)) {
				if(pixelMap[pixel.x][pixel.y-1].element == "head") {
					changePixel(pixelMap[pixel.x][pixel.y-1],"zombie_head");
				} else if(pixelMap[pixel.x][pixel.y-1].element == "zombie_head") {
					var head = pixelMap[pixel.x][pixel.y-1];
					if (head.dead) { // If head is dead, kill body
						pixel.dead = head.dead;
					};
				} else {
					var head = null;
				};
			} else { var head = null };

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create zombie blood if decapitated 10% chance
				if (Math.random() < 0.1) {
					createPixel("zombie_blood", pixel.x, pixel.y-1);
					// set dead to true 10% chance
					if (Math.random() < 0.10) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return }
			else if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};
		},
	};

	elements.zombie_head = {
		color: "#567C44",
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "rotten_meat",
		tempLow: -30,
		stateLow: "frozen_rotten_meat",
		burn: 10,
		burnTime: 250,
		burnInto: "rotten_meat",
		breakInto: ["zombie_blood","rotten_meat"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","rotten_meat","rotten_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.025 },
		},
		properties: {
			dead: false,
			following: false,
			dir: 1,
			panic: 0,
		},
		movable: true,
		tick: function(pixel) {
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 100
				if (pixelTicks-pixel.dead > 100) {
					changePixel(pixel,"rotten_meat");
				};
				return;
			};

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true)) {
				if(pixelMap[pixel.x][pixel.y+1].element == "body") {
					changePixel(pixelMap[pixel.x][pixel.y+1],"zombie_body");
				} else if(pixelMap[pixel.x][pixel.y+1].element == "zombie_body") {
					var body = pixelMap[pixel.x][pixel.y+1];
					if (body.dead) { // If body is dead, kill body
						pixel.dead = body.dead;
					};
				} else {
					var body = null;
				};
			} else { var body = null };

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create zombie blood if severed 10% chance
				if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
					createPixel("zombie_blood", pixel.x, pixel.y+1);
					// set dead to true 10% chance
					if (Math.random() < 0.10) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			if(pixelTicks % 2 == 0) { //reduce rate for performance
				/*var directionAdverb = "left";
				if(pixel.dir > 0) {
					directionAdverb = "right";
				};*/
				//console.log(`Looking ${directionAdverb}`)
				if(pixel.dir === -1) {
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = (-1); j > (-35 - 1); j--) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/3) {	//One-third chance to mutilate (changePixel)
												if(Math.random() < 1/3) {	//One-third chance to change to blood
													changePixel(newPixel,"zombie_blood",false); //blood is turned in place
												} else {					//Remaining 2/3 chance to change to rotten flesh
													changePixel(newPixel,"rotten_meat",false);
												};
											} else {					//Remaining 2/3 chance to turn the human
												zombifyHuman(newPixel);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/3) {	//One-third chance to change to blood
											changePixel(newPixel,"zombie_blood",false); //blood is turned in place
										} else {					//Remaining 2/3 chance to change to rotten flesh
											changePixel(newPixel,"rotten_meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				} else if(pixel.dir === 1) {
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = 1; j < 35 + 1; j++) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/3) {	//One-third chance to mutilate (changePixel)
												if(Math.random() < 1/3) {	//One-third chance to change to blood
													changePixel(newPixel,"zombie_blood",false); //blood is turned in place
												} else {					//Remaining 2/3 chance to change to rotten flesh
													changePixel(newPixel,"rotten_meat",false);
												};
											} else {					//Remaining 2/3 chance to turn the human
												zombifyHuman(newPixel);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/3) {	//One-third chance to change to blood
											changePixel(newPixel,"zombie_blood",false); //blood is turned in place
										} else {					//Remaining 2/3 chance to change to rotten flesh
											changePixel(newPixel,"rotten_meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				};
			};
					
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

		//Baby Zombie

	elements.baby_zombie = {
		color: "#199A9A",
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "rotten_meat",
		tempLow: -30,
		stateLow: "frozen_rotten_meat",
		burn: 10,
		burnTime: 250,
		burnInto: "rotten_meat",
		breakInto: ["zombie_blood","rotten_meat"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","rotten_meat","rotten_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.025 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
		},
		movable: true,
		tick: function(pixel) {
			tryMove(pixel, pixel.x, pixel.y+1); // Fall
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 100
				if (pixelTicks-pixel.dead > 100) {
					changePixel(pixel,"rotten_meat");
				};
				return;
			};

			if (Math.random() < 0.15) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],	//dash move
					[1*pixel.dir,-1],	//slash move
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if(tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!pixel.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			var pX = pixel.x;
			var pY = pixel.y;

			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			if(pixelTicks % 2 == 0) { //reduce rate for performance
				/*var directionAdverb = "left";
				if(pixel.dir > 0) {
					directionAdverb = "right";
				};*/
				//console.log(`Looking ${directionAdverb}`)
				if(pixel.dir === -1) {
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = (-1); j > (-35 - 1); j--) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/3) {	//One-third chance to mutilate (changePixel)
												if(Math.random() < 1/4) {	//One-fourth chance to change to blood
													changePixel(newPixel,"zombie_blood",false); //blood is turned in place
												} else {					//Remaining 3/4 chance to change to rotten flesh
													changePixel(newPixel,"rotten_meat",false);
												};
											} else {					//Remaining 2/3 chance to turn the human
												zombifyHuman(newPixel);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/4) {	//One-fourth chance to change to blood
											changePixel(newPixel,"zombie_blood",false); //blood is turned in place
										} else {					//Remaining 3/4 chance to change to rotten flesh
											changePixel(newPixel,"rotten_meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				} else if(pixel.dir === 1) {
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = 1; j < 35 + 1; j++) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/3) {	//One-third chance to mutilate (changePixel)
												if(Math.random() < 1/4) {	//One-fourth chance to change to blood
													changePixel(newPixel,"zombie_blood",false); //blood is turned in place
												} else {					//Remaining 3/4 chance to change to rotten flesh
													changePixel(newPixel,"rotten_meat",false);
												};
											} else {					//Remaining 2/3 chance to turn the human
												zombifyHuman(newPixel);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/4) {	//One-fourth chance to change to blood
											changePixel(newPixel,"zombie_blood",false); //blood is turned in place
										} else {					//Remaining 3/4 chance to change to rotten flesh
											changePixel(newPixel,"rotten_meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				};
			};
					
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
		related: ["zombie"],
		desc: "Baby zombies: smaller, faster, and more annoying.",
	};

	/*Start Main Creeper
		##################
		#########   ######
		#######       ####
		######     OOOOO##
		####      OOOOOOO#
		###        OOOOO##
		###           ####
		###           ####
		###           ####
		####          ####
		######        ####
		#######  ###  ####
		#######  ###  ####
		##################
	*/

	elements.creeper = {
		color: ["#D2D2D2", "#BFDFB9", "#94CE89", "#78D965", "#5ED54C", "#58C546", "#50B143", "#479143", "#559552", "#3F8738", "#5B8B59"],
		category: "life",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("creeper_body", pixel.x, pixel.y+1);
				pixel.element = "creeper_head";
				pixel.color = pixelColorPick(pixel)
			}
			else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("creeper_head", pixel.x, pixel.y-1);
				pixelMap[pixel.x][pixel.y-1].color = pixel.color;
				pixel.element = "creeper_body";
				pixel.color = pixelColorPick(pixel)
			}
			else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["creeper_body","creeper_head"],
		desc: "<em>I'd rather this be toggleable mid-game than require a reload.</em><br/><br/><span class=\"creeperStatus\">If this text is green or underlined, creepers can spawn.</span> <span onclick=toggleCreeperSpawning() style=\"color: #ff00ff;\";>Click here</span> to toggle creeper spawning. If it's on, creepers (all types) can spawn through random events.<br/>To enable automatic creeper generation, set the generateCreepers query parameter."
	};

	elements.creeper_body = {
		color: ["#D2D2D2", "#BFDFB9", "#94CE89", "#78D965", "#5ED54C", "#58C546", "#50B143", "#479143", "#559552", "#3F8738", "#5B8B59"],
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","cooked_meat","gunpowder"],
		breakInto: ["blood","gunpowder"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
				if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
					var headPixel = pixelMap[pixel.x][pixel.y-2];
					if (headPixel.element == "creeper_head") {
						if (isEmpty(pixel.x, pixel.y-1)) {
							movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
						}
						else {
							swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
						}
					}
				}
			}
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
				}
				return
			}

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "creeper_head") {
				var head = pixelMap[pixel.x][pixel.y-1];
				if (head.dead) { // If head is dead, kill body
					pixel.dead = head.dead;
				}
			}
			else { var head = null }

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create blood if decapitated 10% chance
				if (Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y-1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return }
			else if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(head) {
				if(typeof(head.charge) !== "undefined") {
					if(head.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(head.charged) !== "undefined") {
					if(head.charged) {
						pixel.charged = true;
					};
				};
			};

			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 7;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 5;
			};
			
			if(pixel.burning) {
				pixel.hissing = true;
				if(!pixel.hissStart) {
					pixel.hissStart = pixelTicks;
				};
				if(!pixel.burnStart) { //I don't like errors.
					pixel.burnStart = pixel.ticks;
				};
				if(pixelTicks - pixel.burnStart > 30) {
					//console.log("Kaboom?");
					explodeAt(pixel.x,pixel.y,explosionRadius);
					//console.log("Yes, Rico, kaboom.");
				};
			};

			//Head hissing color handler: keeps track of head's hissing for coloring purposes
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.dead || !head || head.dead) { //can't hiss without a head according to the classic creeper anatomy
					//console.log("ss-- oof");
					pixel.hissing = false;
					break;
				};
				if(head.hissing) {
					//console.log("Ssssssss");
					if(!head.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						head.hissStart = pixelTicks;
					};

					//Color code {
						var ticksHissing = pixelTicks - head.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							//console.log("the j");
							luminance = slBound(luminance + 1.176);
							//console.log(luminance);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}
				};
			};
		},
	};

	elements.creeper_head = {
		color: ["#5B8B59", "#3F8738", "#559552", "#479143", "#50B143", "#58C546"],
		category: "life",
		hidden: true,
		density: 1080,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","gunpowder"],
		breakInto: "blood",
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
			"oxygen": { "elem2":"carbon_dioxide", "chance":0.5 },
		},
		properties: {
			dead: false,
			following: false,
			hissing: false,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
					return
				}
			}

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "creeper_body") {
				var body = pixelMap[pixel.x][pixel.y+1];
				if (body.dead) { // If body is dead, kill head
					pixel.dead = body.dead;
				}
			}
			else { var body = null }

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create blood if severed 10% chance
				if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y+1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(body) {
				if(typeof(body.charge) !== "undefined") {
					if(body.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(body.charged) !== "undefined") {
					if(body.charged) {
						pixel.charged = true;
					};
				};
			};
			
			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			var directionAdverb = "left";
			if(pixel.dir > 0) {
				directionAdverb = "right";
			};
			//console.log(`Looking ${directionAdverb}`)
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) { //probably misapplying the tolerance from the MC Wiki line: "Creepers will chase after any player, as long as it is within a 16 block (5%) radius"
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) {
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
									break;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break;
							};
						};
					};
				};
			};
			
			//Pre-explosion handler: keeps track of time before the kaboom
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.hissing) {
					//console.log("Ssssssss");
					if(pixel.dead || !body || body.dead) { //can't explode without a body according to the classic creeper anatomy
						//console.log("ss-- oof");
						pixel.hissing = false;
						break;
					};
					if(!pixel.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						pixel.hissStart = pixelTicks;
					};
					//Color code {
						var ticksHissing = pixelTicks - pixel.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							luminance = slBound(luminance + 1.176);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}

					if(pixelTicks - pixel.hissStart > 30) {
						//console.log("Kaboom?");
						//console.log(`Exploding with radius ${explosionRadius} (charged: ${pixel.charged})`);
						explodeAt(body.x,body.y,explosionRadius);
						//console.log("Yes, Rico, kaboom.");
					};
				};
			};
			
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

	/*End Main Creeper
		##################
		##################
		##################
		#########X#X######
		#########XXX######
		##########X#######
		##########X#######
		### # # # X # ####
		###           ####
		####          ####
		######        ####
		#######  ###  ####
		#######  ###  ####
		##################
	*/

															//Baby Creeper

	elements.baby_creeper = {
		color: ["#D2D2D2", "#BFDFB9", "#94CE89", "#78D965", "#5ED54C", "#58C546", "#50B143", "#479143", "#559552", "#3F8738", "#5B8B59"],
		category: "life",
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","cooked_meat","gunpowder"],
		breakInto: ["blood","gunpowder"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			tryMove(pixel, pixel.x, pixel.y+1); // Fall
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
				}
				return
			}

			if (Math.random() < 0.15) { // Move 15% chance (should be 12.5 but 15 looks better)
				var movesToTry = [
					[1*pixel.dir,0],	//dash move
					[1*pixel.dir,-1],	//slash move
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if(tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!pixel.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charge) {
				pixel.charged = true;
			};
			
			var pX = pixel.x;
			var pY = pixel.y;

			if(pixel.charged) {
				var explosionRadius = 6;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 4; //should be half of the original creeper's radius
			};
			
			if(pixel.burning) {
				pixel.hissing = true;
				if(!pixel.hissStart) {
					pixel.hissStart = pixelTicks;
				};
				if(!pixel.burnStart) { //I don't like errors.
					pixel.burnStart = pixel.ticks;
				};
				if(pixelTicks - pixel.burnStart > 15) {
					//console.log("Kaboom?");
					explodeAt(pixel.x,pixel.y,explosionRadius);
					//console.log("Yes, Rico, kaboom.");
				};
			};

			//Pre-explosion handler: keeps track of time before the kaboom
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.hissing) {
					//console.log("Ssssssss");
					if(pixel.dead) {
						//console.log("ss-- oof");
						pixel.hissing = false;
						break;
					};
					if(!pixel.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						pixel.hissStart = pixelTicks;
					};
					//Color code {
						var ticksHissing = pixelTicks - pixel.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + (2 * ticksHissing));
							green = rgbColorBound(green + (2 * ticksHissing));
							blue = rgbColorBound(blue + (2 * ticksHissing));
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							luminance = slBound(luminance + (2 * 1.176));
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}

					if(pixelTicks - pixel.hissStart > 15) {
						//console.log("Kaboom?");
						//console.log(`Exploding with radius ${explosionRadius} (charged: ${pixel.charged})`);
						explodeAt(pixel.x,pixel.y,explosionRadius);
						//console.log("Yes, Rico, kaboom.");
					};
				};
			};
			
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};

			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			var directionAdverb = "left";
			if(pixel.dir > 0) {
				directionAdverb = "right";
			};
			//console.log(`Looking ${directionAdverb}`)
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) { //probably misapplying the tolerance from the MC Wiki line: "Creepers will chase after any player, as long as it is within a 16 block (5%) radius"
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) {
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
									break;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break;
							};
						};
					};
				};
			};
		},
		related: ["creeper"],
	};

															//Angelic Creeper

	elements.angelic_creeper = { //let's get this one out of the way first
		color: ["#f5ef56", "#fcbddf", "#de8aa8", "#e35d95", "#eb4974", "#ed3ea7", "#d645a3", "#a84556", "#9e4f6c", "#91315b", "#8c4963"],
		category: "life",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("angelic_creeper_body", pixel.x, pixel.y+1);
				pixel.element = "angelic_creeper_head";
				pixel.color = pixelColorPick(pixel)
			}
			else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("angelic_creeper_head", pixel.x, pixel.y-1);
				pixelMap[pixel.x][pixel.y-1].color = pixel.color;
				pixel.element = "angelic_creeper_body";
				pixel.color = pixelColorPick(pixel)
			}
			else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["angelic_creeper_body","angelic_creeper_head"],
		desc: 'A creeper type from <em>Extra Creeper Types</em> <a href="https://www.curseforge.com/minecraft/mc-mods/extra-creeper-types">(CF)</a>. It sends things upward.'
	};

	elements.angelic_creeper_body = {
		color: ["#d2d2d2", "#fcbddf", "#de8aa8", "#e35d95", "#eb4974", "#ed3ea7", "#d645a3", "#a84556", "#9e4f6c", "#91315b", "#8c4963"],
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","cooked_meat","gunpowder"],
		breakInto: ["blood","blood","gunpowder","gunpowder","feather"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			if(!pixel.hissing) { //If not hissing (it floats when hissing)
				if(Math.random() < 0.2) { //20% chance to fall
					if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
						if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
							var headPixel = pixelMap[pixel.x][pixel.y-2];
							if (headPixel.element == "angelic_creeper_head") {
								if (isEmpty(pixel.x, pixel.y-1)) {
									movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
								} else {
									swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
								};
							};
						};
					};
				};
			} else {
				if((pixelTicks - pixel.start) % 3 == 0) {
					if (!isEmpty(pixel.x, pixel.y-1, true)) { // Find head
						var headPixel = pixelMap[pixel.x][pixel.y-1];
						if (headPixel.element == "angelic_creeper_head") { //Validate head
							if (tryMove(headPixel, pixel.x, pixel.y-2)) { // Float
								if (isEmpty(pixel.x, pixel.y-1)) { //If the head didn't swap with something
									movePixel(pixel, pixel.x, pixel.y-1); //Pull body up
								} else { //If it did swap
									swapPixels(pixel, pixelMap[pixel.x][pixel.y-1]); //Pull body up through other pixel
								};
							};
						};
					};
				};
			};
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
				}
				return
			}

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "angelic_creeper_head") {
				var head = pixelMap[pixel.x][pixel.y-1];
				if (head.dead) { // If head is dead, kill body
					pixel.dead = head.dead;
				}
			}
			else { var head = null }

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create blood if decapitated 10% chance
				if (Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y-1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return }
			else if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(head) {
				if(typeof(head.charge) !== "undefined") {
					if(head.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(head.charged) !== "undefined") {
					if(head.charged) {
						pixel.charged = true;
					};
				};
			};

			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			if(pixel.burning) {
				pixel.hissing = true;
				if(!pixel.hissStart) {
					pixel.hissStart = pixelTicks;
				};
				if(!pixel.burnStart) { //I don't like errors.
					pixel.burnStart = pixel.ticks;
				};
				if(pixelTicks - pixel.burnStart > 30) {
					//console.log("GOTTA YEET YEET YEET!");
					explodeAtPlus(pixel.x,pixel.y,explosionRadius,"fire","smoke",null,angelicUpwardVelocity);	//Special effect: Flings you upwards (extended to all movable tiles because it's easier).
																									//It also floats when hissing, but that will come soon.
					//console.log("Yes, Rico, kaboom.");
				};
			};

			//Head hissing color handler: keeps track of head's hissing for coloring purposes
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.dead || !head || head.dead) { //can't hiss without a head according to the classic creeper anatomy
					//console.log("ss-- oof");
					pixel.hissing = false;
					break;
				};
				if(head.hissing) {
					//console.log("Ssssssss");
					if(!head.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						head.hissStart = pixelTicks;
					};

					//Color code {
						var ticksHissing = pixelTicks - head.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							//console.log("the j");
							luminance = slBound(luminance + 1.176);
							//console.log(luminance);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}
				};
			};
		},
	},

	elements.angelic_creeper_head = {
		color: ["#f5ef56", "#f0ea4f", "#f0ea60"],
		category: "life",
		hidden: true,
		density: 1080,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","gunpowder"],
		breakInto: ["blood","blood","blood","blood","feather"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
			"oxygen": { "elem2":"carbon_dioxide", "chance":0.5 },
		},
		properties: {
			dead: false,
			following: false,
			hissing: false,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
					return
				}
			}

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "angelic_creeper_body") {
				var body = pixelMap[pixel.x][pixel.y+1];
				if (body.dead) { // If body is dead, kill head
					pixel.dead = body.dead;
				}
			}
			else { var body = null }

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create blood if severed 10% chance
				if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y+1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(body) {
				if(typeof(body.charge) !== "undefined") {
					if(body.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(body.charged) !== "undefined") {
					if(body.charged) {
						pixel.charged = true;
					};
				};
			};
			
			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			var directionAdverb = "left";
			if(pixel.dir > 0) {
				directionAdverb = "right";
			};
			//console.log(`Looking ${directionAdverb}`)
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) { //probably misapplying the tolerance from the MC Wiki line: "Creepers will chase after any player, as long as it is within a 16 block (5%) radius"
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) {
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
									break;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break;
							};
						};
					};
				};
			};
			
			//Pre-explosion handler: keeps track of time before the kaboom
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.hissing) {
					//console.log("Ssssssss");
					if(pixel.dead || !body || body.dead) { //can't explode without a body according to the classic creeper anatomy
						//console.log("ss-- oof");
						pixel.hissing = false;
						break;
					};
					if(!pixel.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						pixel.hissStart = pixelTicks;
					};
					//Color code {
						var ticksHissing = pixelTicks - pixel.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							luminance = slBound(luminance + 1.176);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}

					if(pixelTicks - pixel.hissStart > 30) {
						//console.log("GOTTA YEET YEET YEET!");
						//console.log(`Exploding with radius ${explosionRadius} (charged: ${pixel.charged})`);
						explodeAtPlus(body.x,body.y,explosionRadius,"fire","smoke",null,angelicUpwardVelocity);
						//console.log("Yes, Rico, kaboom.");
					};
				};
			};
			
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

																//Bombing Creeper

	elements.bombing_creeper = {
		color: ["#5b8b59", "#3f8738", "#559552", "#479143", "#50b143", "#58c546", "#e83c3c", "#c92a2a", "#f53d3d", "#ad3131"],
		category: "life",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("bombing_creeper_body", pixel.x, pixel.y+1);
				pixel.element = "bombing_creeper_head";
				pixel.color = pixelColorPick(pixel)
			}
			else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("bombing_creeper_head", pixel.x, pixel.y-1);
				pixelMap[pixel.x][pixel.y-1].color = pixel.color;
				pixel.element = "bombing_creeper_body";
				pixel.color = pixelColorPick(pixel)
			}
			else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["bombing_creeper_body","bombing_creeper_head"],
		desc: 'A creeper type from <em>Extra Creeper Types</em> <a href="https://www.curseforge.com/minecraft/mc-mods/extra-creeper-types">(CF)</a>. It spawns more explosives when it explodes.'
	};

	elements.bombing_creeper_body = {
		color: ["#e83c3c", "#c92a2a", "#f53d3d", "#ad3131"],
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","dynamite","gunpowder"],
		breakInto: ["blood","dynamite","dynamite"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
				if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
					var headPixel = pixelMap[pixel.x][pixel.y-2];
					if (headPixel.element == "bombing_creeper_head") {
						if (isEmpty(pixel.x, pixel.y-1)) {
							movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
						}
						else {
							swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
						}
					}
				}
			}
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
				}
				return
			}

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bombing_creeper_head") {
				var head = pixelMap[pixel.x][pixel.y-1];
				if (head.dead) { // If head is dead, kill body
					pixel.dead = head.dead;
				}
			}
			else { var head = null }

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create blood if decapitated 10% chance
				if (Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y-1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return }
			else if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(head) {
				if(typeof(head.charge) !== "undefined") {
					if(head.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(head.charged) !== "undefined") {
					if(head.charged) {
						pixel.charged = true;
					};
				};
			};

			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			if(pixel.burning) {
				pixel.hissing = true;
				if(!pixel.hissStart) {
					pixel.hissStart = pixelTicks;
				};
				if(!pixel.burnStart) { //I don't like errors.
					pixel.burnStart = pixel.ticks;
				};
				if(pixelTicks - pixel.burnStart > 30) {
					//console.log("Kaboom?");
					explodeAt(pixel.x,pixel.y,explosionRadius,"fire,dynamite");	//Effect: Places (originally 5) primed TNT when it explodes (i.e. cluster bomb creeper)
																				//Dynamite is the closest thing we have to powder TNT (i.e. good enough)
					//console.log("Yes, Rico, kaboom.");
				};
			};

			//Head hissing color handler: keeps track of head's hissing for coloring purposes
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.dead || !head || head.dead) { //can't hiss without a head according to the classic creeper anatomy
					//console.log("ss-- oof");
					pixel.hissing = false;
					break;
				};
				if(head.hissing) {
					//console.log("Ssssssss");
					if(!head.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						head.hissStart = pixelTicks;
					};

					//Color code {
						var ticksHissing = pixelTicks - head.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							//console.log("the j");
							luminance = slBound(luminance + 1.176);
							//console.log(luminance);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}
				};
			};
		},
	};

	elements.bombing_creeper_head = {
		color: ["#5B8B59", "#3F8738", "#559552", "#479143", "#50B143", "#58C546"],
		category: "life",
		hidden: true,
		density: 1080,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "cooked_meat",
		tempLow: -30,
		stateLow: "frozen_meat",
		burn: 10,
		burnTime: 250,
		burnInto: ["cooked_meat","cooked_meat","cooked_meat","cooked_meat","cooked_meat","dynamite","gunpowder"],
		breakInto: ["blood","dynamite"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
			"oxygen": { "elem2":"carbon_dioxide", "chance":0.5 },
		},
		properties: {
			dead: false,
			following: false,
			hissing: false,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
					return
				}
			}

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bombing_creeper_body") {
				var body = pixelMap[pixel.x][pixel.y+1];
				if (body.dead) { // If body is dead, kill head
					pixel.dead = body.dead;
				}
			}
			else { var body = null }

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create blood if severed 10% chance
				if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y+1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(body) {
				if(typeof(body.charge) !== "undefined") {
					if(body.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(body.charged) !== "undefined") {
					if(body.charged) {
						pixel.charged = true;
					};
				};
			};
			
			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			var directionAdverb = "left";
			if(pixel.dir > 0) {
				directionAdverb = "right";
			};
			//console.log(`Looking ${directionAdverb}`)
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) { //probably misapplying the tolerance from the MC Wiki line: "Creepers will chase after any player, as long as it is within a 16 block (5%) radius"
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) {
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
									break;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break;
							};
						};
					};
				};
			};
			
			//Pre-explosion handler: keeps track of time before the kaboom
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.hissing) {
					//console.log("Ssssssss");
					if(pixel.dead || !body || body.dead) { //can't explode without a body according to the classic creeper anatomy
						//console.log("ss-- oof");
						pixel.hissing = false;
						break;
					};
					if(!pixel.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						pixel.hissStart = pixelTicks;
					};
					//Color code {
						var ticksHissing = pixelTicks - pixel.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							luminance = slBound(luminance + 1.176);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}

					if(pixelTicks - pixel.hissStart > 30) {
						//console.log("Kaboom?");
						//console.log(`Exploding with radius ${explosionRadius} (charged: ${pixel.charged})`);
						explodeAt(body.x,body.y,explosionRadius,"fire,dynamite");
						//console.log("Yes, Rico, kaboom.");
					};
				};
			};
			
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

																//Hell Creeper

	elements.hell_creeper = {
		color: ["#D2D2D2", "#ff141e", "#fc3232", "#DFAFAF", "#e84a4a", "#ce7979", "#d95555", "#d53c3c", "#c53636", "#b13333", "#913535", "#954242", "#872828", "#8b4949", "#2b0304"],
		category: "life",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("hell_creeper_body", pixel.x, pixel.y+1);
				pixel.element = "hell_creeper_head";
				pixel.color = pixelColorPick(pixel)
			}
			else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("hell_creeper_head", pixel.x, pixel.y-1);
				pixelMap[pixel.x][pixel.y-1].color = pixel.color;
				pixel.element = "hell_creeper_body";
				pixel.color = pixelColorPick(pixel)
			}
			else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["hell_creeper_body","hell_creeper_head"],
		desc: 'A creeper type from <em>Extra Creeper Types</em> <a href="https://www.curseforge.com/minecraft/mc-mods/extra-creeper-types">(CF)</a>. It has a small explosion radius, but spawns a lot of fire around its explosion.'
	};

	elements.hell_creeper_body = {
		color: ["#D2D2D2", "#ff141e", "#fc3232", "#DFAFAF", "#e84a4a", "#ce7979", "#d95555", "#d53c3c", "#c53636", "#b13333", "#913535", "#954242", "#872828", "#8b4949", "#2b0304"],
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 2000, //they are immune to lava, and minecraft's lava is presumably mafic, so at least 1200*C
		stateHigh: "ash",
		breakInto: ["blood","gunpowder","fire"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
				if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
					var headPixel = pixelMap[pixel.x][pixel.y-2];
					if (headPixel.element == "hell_creeper_head") {
						if (isEmpty(pixel.x, pixel.y-1)) {
							movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
						}
						else {
							swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
						}
					}
				}
			}
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
				}
				return
			}

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "hell_creeper_head") {
				var head = pixelMap[pixel.x][pixel.y-1];
				if (head.dead) { // If head is dead, kill body
					pixel.dead = head.dead;
				}
			}
			else { var head = null }

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create blood if decapitated 10% chance
				if (Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y-1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return }
			else if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(head) {
				if(typeof(head.charge) !== "undefined") {
					if(head.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(head.charged) !== "undefined") {
					if(head.charged) {
						pixel.charged = true;
					};
				};
			};

			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			if(pixel.burning) {
				pixel.hissing = true;
				if(!pixel.hissStart) {
					pixel.hissStart = pixelTicks;
				};
				if(!pixel.burnStart) { //I don't like errors.
					pixel.burnStart = pixel.ticks;
				};
				if(pixelTicks - pixel.burnStart > 30) {
					//console.log("Kaboom?");
					explodeAtPlus(pixel.x,pixel.y,explosionRadius,"fire","fire",null,hellExplosionFire);
					//console.log("Yes, Rico, kaboom.");
				};
			};

			//Head hissing color handler: keeps track of head's hissing for coloring purposes
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.dead || !head || head.dead) { //can't hiss without a head according to the classic creeper anatomy
					//console.log("ss-- oof");
					pixel.hissing = false;
					break;
				};
				if(head.hissing) {
					//console.log("Ssssssss");
					if(!head.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						head.hissStart = pixelTicks;
					};

					//Color code {
						var ticksHissing = pixelTicks - head.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							//console.log("the j");
							luminance = slBound(luminance + 1.176);
							//console.log(luminance);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}
				};
			};
		},
	};

	elements.hell_creeper_head = {
		color: ["#D2D2D2", "#ff141e", "#fc3232", "#e84a4a", "#b13333", "#913535", "#954242", "#872828", "#8b4949", "#2b0304", "#111111", "#faae3c", "#f5e131"],
		category: "life",
		hidden: true,
		density: 1080,
		state: "solid",
		conduct: 25,
		tempHigh: 2000,
		stateHigh: "ash",
		tempLow: -30,
		stateLow: "frozen_meat",
		breakInto: ["blood","fire"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
			"oxygen": { "elem2":"carbon_dioxide", "chance":0.5 },
		},
		properties: {
			dead: false,
			following: false,
			hissing: false,
			charged: false,
			didChargeBlueTinted: false,
		},
		movable: true,
		tick: function(pixel) {
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into rotten_meat if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					Math.random() < 0.1 ? changePixel(pixel,"gunpowder") : changePixel(pixel,"rotten_meat");
					return
				}
			}

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "hell_creeper_body") {
				var body = pixelMap[pixel.x][pixel.y+1];
				if (body.dead) { // If body is dead, kill head
					pixel.dead = body.dead;
				}
			}
			else { var body = null }

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create blood if severed 10% chance
				if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y+1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			if(pixel.charge) {
				pixel.charged = true;
			};
			
			if(body) {
				if(typeof(body.charge) !== "undefined") {
					if(body.charge) {
						pixel.charged = true;
					};
				};
				if(typeof(body.charged) !== "undefined") {
					if(body.charged) {
						pixel.charged = true;
					};
				};
			};
			
			if(typeof(pixel.charged) === "undefined") {
				pixel.charged = false;
			};

			if(pixel.charged) {
				var explosionRadius = 10;
				if(!pixel.didChargeBlueTinted) { //do once, on initial charge
					//console.log("something something halsey lyric");
					var color = pixel.color;
					if(color.startsWith("rgb")) {
						//console.log("rgb detected");
						color = color.split(","); //split color for addition
						var red = parseFloat(color[0].substring(4));
						var green = parseFloat(color[1]);
						var blue = parseFloat(color[2].slice(0,-1));
						red = rgbColorBound(red + 51);
						green = rgbColorBound(green + 51);
						blue = rgbColorBound(blue + 102);
						color = `rgb(${red},${green},${blue})`;
						pixel.color = color;
						//console.log("color set");
					} else if(color.startsWith("hsl")) {
						//console.log("hsl detected");
						color = color.split(","); //split color for addition
						var hue = parseFloat(color[0].substring(4));
						var saturation = parseFloat(color[1].slice(0,-1));
						var luminance = parseFloat(color[2].slice(0,-2));
						hue = hue % 360; //piecewise hue shift
						if(hue <= 235 && hue >= 135) {
							hue = 185;
						} else if(hue < 135) {
							hue += 50;
						} else if(hue > 235 && hue < 360) {
							hue -= 50;
						};
						saturation = slBound (saturation + 10);
						luminance = slBound(luminance + 20);
						color = `hsl(${hue},${saturation}%,${luminance}%)`;
						pixel.color = color;
						//console.log("color set");
					};
					pixel.didChargeBlueTinted = true;
				};
			} else {
				var explosionRadius = 7;
			};
			
			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			var directionAdverb = "left";
			if(pixel.dir > 0) {
				directionAdverb = "right";
			};
			//console.log(`Looking ${directionAdverb}`)
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) { //probably misapplying the tolerance from the MC Wiki line: "Creepers will chase after any player, as long as it is within a 16 block (5%) radius"
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									//console.log(`Human detected at (${nX},${nY})`)
									//Start "hissing" if a human is close enough
									if(coordPyth(pX,pY,nX,nY) <= 3.15) {
										pixel.hissing = true;
										if(!pixel.hissStart) {
											pixel.hissStart = pixelTicks;
										};
									};
									break;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break;
							};
						};
					};
				};
			};
			
			//Pre-explosion handler: keeps track of time before the kaboom
			for(i = 0; i < 1; i++) { //dummy for loop
				if(pixel.hissing) {
					//console.log("Ssssssss");
					if(pixel.dead || !body || body.dead) { //can't explode without a body according to the classic creeper anatomy
						//console.log("ss-- oof");
						pixel.hissing = false;
						break;
					};
					if(!pixel.hissStart) {
						//console.log("t-30 ticks or whatever it was");
						pixel.hissStart = pixelTicks;
					};
					//Color code {
						var ticksHissing = pixelTicks - pixel.hissStart;
						var color = pixel.color; //do on each hissing tick
						if(color.startsWith("rgb")) {
							//console.log("rgb detected");
							color = color.split(","); //split color for addition
							var red = parseFloat(color[0].substring(4));
							var green = parseFloat(color[1]);
							var blue = parseFloat(color[2].slice(0,-1));
							red = rgbColorBound(red + ticksHissing);
							green = rgbColorBound(green + ticksHissing);
							blue = rgbColorBound(blue + ticksHissing);
							color = `rgb(${red},${green},${blue})`;
							pixel.color = color;
							//console.log("color set");
						} else if(color.startsWith("hsl")) {
							//console.log("hsl detected");
							color = color.split(","); //split color for addition
							var hue = parseFloat(color[0].substring(4));
							var saturation = parseFloat(color[1].slice(0,-1));
							var luminance = parseFloat(color[2].slice(0,-2));
							luminance = slBound(luminance + 1.176);
							color = `hsl(${hue},${saturation}%,${luminance}%)`;
							pixel.color = color;
							//console.log("color set");
						};
					//}

					if(pixelTicks - pixel.hissStart > 30) {
						//console.log("Kaboom?");
						//console.log(`Exploding with radius ${explosionRadius} (charged: ${pixel.charged})`);
						explodeAtPlus(pixel.x,pixel.y,explosionRadius,"fire","fire",null,hellExplosionFire);
						//console.log("Yes, Rico, kaboom.");
					};
				};
			};
			
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

	/* +-----------------------------------+
	   | Nothing There                     |
	   |                                   |
	   | amogus                            |
	   |                                   |
	   | red imposter                      |
	   |                                   |
	   |                                   |
	   |                                   |
	   |                                   |
	   |                                   |
	   |                                   |
	   |                                   |
	   +-----------------------------------+ */

	elements.nothing_there_bullet = {
		flippableX: true,
		movable: true,
		density: 10000,
		desc: "A hypersonic bullet made of Nothing There's flesh. I don't remember if it can turn humans into red clouds.",
		color: "#a3281a",
		related: ["nothing_there_phase_3_body","nothing_there_phase_3_head"],
		movable: true,
		tick: function(pixel) {
			if(typeof(pixel.flipX) == undefined) {
				pixel.flipX = !!Math.floor(Math.random() * 2);
			};
			var dir = pixel.flipX ? -1 : 1;
			for(i = 0; i < 6; i++) {
				if(outOfBounds(pixel.x+dir,pixel.y)) {
					deletePixel(pixel.x,pixel.y);
					break;
				};
				if(!nothingThereBulletMovement(pixel,pixel.x+dir,pixel.y)) {
					return true;
				};
			};
		},
	};

	elements.nothing_there_mace = {
		movable: true,
		density: 10000,
		desc: "A spiky mace attached to Nothing There, which can turn humans into red clouds.",
		color: "#fa4632",
		properties: {
			counter: 2,
		},
		related: ["nothing_there_phase_3_body","nothing_there_phase_3_head"],
		movable: true,
		tick: function(pixel) {
			if(outOfBounds(pixel.x,pixel.y + 1)) {
				deletePixel(pixel.x,pixel.y);
				return false;
			};
			if(!tryMove(pixel,pixel.x,pixel.y + 1)) {
				var newPixel = pixelMap[pixel.x][pixel.y + 1];
				var newElement = newPixel.element;
				var newInfo = elements[newElement];
				if(newElement !== pixel.element) {
					if(newInfo.state === "gas") {
						swapPixels(pixel,newPixel);
					} else {
						if(pixel.counter > 0) {
							explodeAtPlus(pixel.x,pixel.y + 1,5,null,null);
							pixel.counter--;
						} else {
							deletePixel(pixel.x,pixel.y);
							return true;
						};
					};
				};
			};
		},
	};

	elements.nothing_there_cleaver = {
		movable: true,
		density: 10000,
		desc: "A very sharp blade attached to Nothing There, which can turn humans into red clouds.",
		color: "#a33c3c",
		properties: {
			counter: 4,
		},
		related: ["nothing_there_phase_3_body","nothing_there_phase_3_head"],
		movable: true,
		tick: function(pixel) {
			if(outOfBounds(pixel.x,pixel.y + 1)) {
				deletePixel(pixel.x,pixel.y);
				return false;
			};
			if(!tryMove(pixel,pixel.x,pixel.y + 1)) {
				var newPixel = pixelMap[pixel.x][pixel.y + 1];
				var newElement = newPixel.element;
				var newInfo = elements[newElement];
				if(!nothingThereBulletExcludedElements.includes(newElement)) {
					if(pixel.counter > 0) {
						swapPixels(pixel,newPixel);
						breakPixel(newPixel,false,false);
						pixel.counter--;
					} else {
						deletePixel(pixel.x,pixel.y);
						return true;
					};
				} else {
					deletePixel(pixel.x,pixel.y);
					return false;
				};
			};
		},
	};

	testSwapArray = ["meat","cooked_meat","rotten_meat","blood","infection","antibody","plague","zombie_blood","frozen_meat","frozen_rotten_meat"];

	elements.nothing_there_phase_1 = {
		color: "#faacac",
		category: "life",
		density: 2000,
		desc: "O-06-20 <span style='color: red;'>(ALEPH)</span><br/>In this phase, it looks like a dog made of misshapen human parts. It can easily turn humans into unrecognizable messes.",
		state: "solid",
		tempHigh: 3000,
		hardness: 0.995,
		stateHigh: "cooked_meat",
		burn: 1,
		burnTime: 250000,
		burnInto: "cooked_meat",
		breakInto: (enabledMods.includes("mods/fey_and_more.js") ? ["blood","meat","magic"] : ["blood","meat"]),
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.00002 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.00004 },
			"plague": { "elem1":"plague", "chance":0.000003 },
		},
		related: ["nothing_there_phase_2", "nothing_there_phase_3_body", "nothing_there_phase_3_head"],
		properties: {
			dead: false,
			dir: 1,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			var pixelBreakInto = elements[pixel.element].breakInto;
			tryMove(pixel, pixel.x, pixel.y+1); // Fall
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Break if pixelTicks-dead > 5
				if (pixelTicks-pixel.dead > 5) {
					changePixel(pixel,pixelBreakInto[Math.floor(Math.random() * pixelBreakInto.length)],false);
				};
				return;
			};

			if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],	//dash move
					[1*pixel.dir,-1],	//cleave move
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if(tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
						break;
					} else { //move through given pixels
						if(!isEmpty(pixel.x+move[0], pixel.y+move[1], true)) {
							var blockingPixel = pixelMap[pixel.x+move[0]][pixel.y+move[1]];
							//console.log(blockingPixel);
							var blockingElement = blockingPixel.element;
							if(testSwapArray.includes(blockingElement)) {
								swapPixels(pixel,blockingPixel);
								break;
							};
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!pixel.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			var pX = pixel.x;
			var pY = pixel.y;

			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};

			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			if(pixelTicks % 2 == 0 && !pixel.dead) { //reduce rate for performance
				/*var directionAdverb = "left";
				if(pixel.dir > 0) {
					directionAdverb = "right";
				};*/
				//console.log(`Looking ${directionAdverb}`)
				if(pixel.dir === -1) {
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = (-1); j > (-35 - 1); j--) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/4) {	//One-fourth chance to change to blood
												changePixel(newPixel,"blood",false);
											} else {					//Remaining 3/4 chance to change to meat
												changePixel(newPixel,"meat",false);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/4) {	//One-fourth chance to change to blood
											changePixel(newPixel,"blood",false);
										} else {					//Remaining 3/4 chance to change to meat
											changePixel(newPixel,"meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				} else if(pixel.dir === 1) {
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = 1; j < 35 + 1; j++) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/4) {	//One-fourth chance to change to blood
												changePixel(newPixel,"blood",false);
											} else {					//Remaining 3/4 chance to change to meat
												changePixel(newPixel,"meat",false);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/4) {	//One-fourth chance to change to blood
											changePixel(newPixel,"blood",false);
										} else {					//Remaining 3/4 chance to change to meat
											changePixel(newPixel,"meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				};
			};

			if(pixelTicks - pixel.start > 300 && (Math.random() < 0.003)) {
				var dir = pixel.dir;
				changePixel(pixel,"nothing_there_phase_2",false);
				pixel.dir = dir;
			};

			//End
		},
	};

	elements.nothing_there_phase_2 = {
		behavior: behaviors.POWDER_OLD,
		color: "#d90b0b",
		category: "life",
		density: 4000,
		desc: "O-06-20 <span style='color: red;'>(ALEPH)</span><br/>In this phase, it looks like a red, fibrous cocoon. It will soon hatch into its third phase.",
		state: "solid",
		tempHigh: 3500,
		hardness: 0.999,
		stateHigh: "cooked_meat",
		burn: 1,
		burnTime: 350000,
		burnInto: "cooked_meat",
		breakInto: (enabledMods.includes("mods/fey_and_more.js") ? ["blood","meat","magic"] : ["blood","meat"]),
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.000001 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.000001 },
			"plague": { "elem1":"plague", "chance":0.000001 },
		},
		related: ["nothing_there_phase_1", "nothing_there_phase_3_body", "nothing_there_phase_3_head"],
		properties: {
			dead: false,
			dir: 1,
			timer: 0,
		},
		movable: true,
		tick: function(pixel) {
			var pixelBreakInto = elements[pixel.element].breakInto;
					doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Break if pixelTicks-dead > 5
				if (pixelTicks-pixel.dead > 5) {
					changePixel(pixel,pixelBreakInto[Math.floor(Math.random() * pixelBreakInto.length)],false);
				};
				return;
			};

			if(pixelTicks - pixel.start > 300) {
				var dir = pixel.dir;
				if (isEmpty(pixel.x, pixel.y+1)) {
					createPixel("nothing_there_phase_3_body", pixel.x, pixel.y+1);
					pixel.element = "nothing_there_phase_3_head";
					pixel.color = pixelColorPick(pixel)
					pixelMap[pixel.x][pixel.y+1].dir = dir;
				}
				else if (isEmpty(pixel.x, pixel.y-1)) {
					createPixel("nothing_there_phase_3_head", pixel.x, pixel.y-1);
					pixelMap[pixel.x][pixel.y-1].color = pixel.color;
					pixel.element = "nothing_there_phase_3_body";
					pixel.color = pixelColorPick(pixel)
					pixel.dir = dir;
				};
			};

			//End
		},
	};

	elements.nothing_there_phase_3 = {
		color: "#fc1e35",
		category: "life",
		desc: "Spawns Nothing There in its humanoid third phase, for when you don't want to wait for it to go through the other phases.",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("nothing_there_phase_3_body", pixel.x, pixel.y+1);
				pixel.element = "nothing_there_phase_3_head";
				pixel.color = pixelColorPick(pixel)
			} else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("nothing_there_phase_3_head", pixel.x, pixel.y-1);
				pixel.element = "nothing_there_phase_3_body";
				pixel.color = pixelColorPick(pixel)
			} else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["nothing_there_phase_3_body","nothing_there_phase_3_head"],
	};

	elements.nothing_there_phase_3_body = {
		color: "#fc1e35",
		category: "life",
		density: 3000,
		desc: "O-06-20 <span style='color: red;'>(ALEPH)</span><br/>In this phase, it looks like a humanoid made of misarranged flesh. It is almost indestructible and has a variety of ways to destroy your canvas and annihilate any humans inside of it.<br/>Let's hope it doesn't learn to blend in and walk among us.",
		state: "solid",
		tempHigh: 3000,
		hardness: 0.9975,
		hidden: true,
		stateHigh: "cooked_meat",
		burn: 1,
		burnTime: 300000,
		burnInto: "cooked_meat",
		breakInto: (enabledMods.includes("mods/fey_and_more.js") ? ["blood","meat","magic"] : ["blood","meat"]),
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.00001 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.00002 },
			"plague": { "elem1":"plague", "chance":0.0000015 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		related: ["nothing_there_phase_1", "nothing_there_phase_2", "nothing_there_mace", "nothing_there_cleaver", "nothing_there_bullet"],
		tick: function(pixel) {
			var pixelBreakInto = elements[pixel.element].breakInto;

			if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
				if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
					var headPixel = pixelMap[pixel.x][pixel.y-2];
					if (headPixel.element == "nothing_there_phase_3_head") {
						if (isEmpty(pixel.x, pixel.y-1)) {
							movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
						}
						else {
							swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
						}
					}
				}
			}
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Break if pixelTicks-dead > 5
				if (pixelTicks-pixel.dead > 5) {
					changePixel(pixel,pixelBreakInto[Math.floor(Math.random() * pixelBreakInto.length)],false);
				};
				return;
			};

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true)) {
				if(pixelMap[pixel.x][pixel.y-1].element == "nothing_there_phase_3_head") {
					var head = pixelMap[pixel.x][pixel.y-1];
					if (head.dead) { // If head is dead, kill body
						pixel.dead = head.dead;
					};
				} else {
					var head = null;
				};
			} else { var head = null };

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create blood if decapitated 30% chance
				if (Math.random() < 0.3) {
					createPixel("blood", pixel.x, pixel.y-1);
					// set dead to true 10% chance
					if (Math.random() < 0.1) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return } //do not proceed if headless
			else if (Math.random() < 0.08) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};
		},
	};

	elements.nothing_there_phase_3_head = {
		color: "#ff3046",
		category: "life",
		density: 3000,
		desc: "O-06-20 <span style='color: red;'>(ALEPH)</span><br/>In this phase, it looks like a humanoid made of misarranged flesh. It is almost indestructible and has a variety of ways to destroy your canvas and annihilate any humans inside of it.<br/>Let's hope it doesn't learn to blend in and walk among us.",
		state: "solid",
		tempHigh: 3000,
		hardness: 0.9975,
		hidden: true,
		stateHigh: "cooked_meat",
		burn: 1,
		burnTime: 300000,
		burnInto: "cooked_meat",
		breakInto: (enabledMods.includes("mods/fey_and_more.js") ? ["blood","meat","magic"] : ["blood","meat"]),
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.00001 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.00002 },
			"plague": { "elem1":"plague", "chance":0.0000015 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		related: ["nothing_there_phase_1", "nothing_there_phase_2", "nothing_there_mace", "nothing_there_cleaver", , "nothing_there_bullet"],
		tick: function(pixel) {
			var pixelBreakInto = elements[pixel.element].breakInto;
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Break if pixelTicks-dead > 5
				if (pixelTicks-pixel.dead > 5) {
					changePixel(pixel,pixelBreakInto[Math.floor(Math.random() * pixelBreakInto.length)],false);
				};
				return;
			};

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true)) {
				if(pixelMap[pixel.x][pixel.y+1].element == "nothing_there_phase_3_body") {
					var body = pixelMap[pixel.x][pixel.y+1];
					if (body.dead) { // If body is dead, kill body
						pixel.dead = body.dead;
					};
				} else {
					var body = null;
				};
			} else { var body = null };

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create blood if severed 30% chance
				if (isEmpty(pixel.x, pixel.y+1) && Math.random() < 0.3) {
					createPixel("blood", pixel.x, pixel.y+1);
					// set dead to true 10% chance
					if (Math.random() < 0.10) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			//Human detection loop
			if(pixelTicks % 2 == 0 && !pixel.dead) { //reduce rate for performance
				/*var directionAdverb = "left";
				if(pixel.dir > 0) {
					directionAdverb = "right";
				};*/
				//console.log(`Looking ${directionAdverb}`)
				if(pixel.dir === -1) {
					//do action every 40 ticks
					var bulletPositions = [[-1, -1], [-1, 0]];
					var bulletPosition = bulletPositions[Math.floor(Math.random() * 2)];
					
					var smashPosition = [-1, -1];
					
					var cleavePositions = [[-1, -1], [-2, -1], [-3, -1]];
					
					var start = 2 * Math.floor(pixel.start/2);
					if((pixelTicks - start) % 40 == 0) {
						var action = Math.floor(Math.random() * 3);
						if(action == 0) { //bullet
							var bX = pX + bulletPosition[0];
							var bY = pY + bulletPosition[1];
							
							if(!outOfBounds(bX,bY)) {
								if(isEmpty(bX,bY)) {
									createPixel("nothing_there_bullet",bX,bY);
									pixelMap[bX][bY].flipX = true;
								} else {
									if(!nothingThereBulletExcludedElements.includes(pixelMap[bX][bY].element)) {
										deletePixel(bX,bY);
										createPixel("nothing_there_bullet",bX,bY);
										pixelMap[bX][bY].flipX = true;
									};
								};
							};
						} else if(action == 1) { //smash
							var sX = pX + smashPosition[0];
							var sY = pY + smashPosition[1];
							
							if(!outOfBounds(sX,sY)) {
								if(isEmpty(sX,sY)) {
									createPixel("nothing_there_mace",sX,sY);
								} else {
									if(!nothingThereBulletExcludedElements.includes(pixelMap[sX][sY].element)) {
										deletePixel(sX,sY);
										createPixel("nothing_there_mace",sX,sY);
									};
								};
							};
						} else if(action == 2) { //cleave
							for(cleaverIndex = 0; cleaverIndex < cleavePositions.length; cleaverIndex++) {
								var cX = pX + cleavePositions[cleaverIndex][0];
								var cY = pY + cleavePositions[cleaverIndex][1];
								
								if(!outOfBounds(cX,cY)) {
									if(isEmpty(cX,cY)) {
										createPixel("nothing_there_cleaver",cX,cY);
									} else {
										if(!nothingThereBulletExcludedElements.includes(pixelMap[cX][cY].element)) {
											deletePixel(cX,cY);
											createPixel("nothing_there_cleaver",cX,cY);
										};
									};
								};
							};
						};
					};
					
					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = (-1); j > (-35 - 1); j--) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								////console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/4) {	//One-fourth chance to change to blood
												changePixel(newPixel,"blood",false);
											} else {					//Remaining 3/4 chance to change to meat
												changePixel(newPixel,"meat",false);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/4) {	//One-fourth chance to change to blood
											changePixel(newPixel,"blood",false);
										} else {					//Remaining 3/4 chance to change to meat
											changePixel(newPixel,"meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				} else if(pixel.dir === 1) {
					//do action every 40 ticks
					var bulletPositions = [[1, -1], [1, 0]];
					var bulletPosition = bulletPositions[Math.floor(Math.random() * 2)];
					
					var smashPosition = [1, -1];
					
					var cleavePositions = [[1, -1], [2, -1], [3, -1]];
					
					var start = 2 * Math.floor(pixel.start/2);
					if((pixelTicks - start) % 40 == 0) {
						var action = Math.floor(Math.random() * 3);
						if(action == 0) { //bullet
							var bX = pX + bulletPosition[0];
							var bY = pY + bulletPosition[1];
							
							if(!outOfBounds(bX,bY)) {
								if(isEmpty(bX,bY)) {
									createPixel("nothing_there_bullet",bX,bY);
									pixelMap[bX][bY].flipX = false;
								} else {
									if(!nothingThereBulletExcludedElements.includes(pixelMap[bX][bY].element)) {
										deletePixel(bX,bY);
										createPixel("nothing_there_bullet",bX,bY);
										pixelMap[bX][bY].flipX = false;
									};
								};
							};
						} else if(action == 1) { //smash
							var sX = pX + smashPosition[0];
							var sY = pY + smashPosition[1];
							
							if(!outOfBounds(sX,sY)) {
								if(isEmpty(sX,sY)) {
									createPixel("nothing_there_mace",sX,sY);
								} else {
									if(!nothingThereBulletExcludedElements.includes(pixelMap[sX][sY].element)) {
										deletePixel(sX,sY);
										createPixel("nothing_there_mace",sX,sY);
									};
								};
							};
						} else if(action == 2) { //cleave
							for(cleaverIndex = 0; cleaverIndex < cleavePositions.length; cleaverIndex++) {
								var cX = pX + cleavePositions[cleaverIndex][0];
								var cY = pY + cleavePositions[cleaverIndex][1];
								
								if(!outOfBounds(cX,cY)) {
									if(isEmpty(cX,cY)) {
										createPixel("nothing_there_cleaver",cX,cY);
									} else {
										if(!nothingThereBulletExcludedElements.includes(pixelMap[cX][cY].element)) {
											deletePixel(cX,cY);
											createPixel("nothing_there_cleaver",cX,cY);
										};
									};
								};
							};
						};
					};

					for(i = -4; i < 4+1; i++) {
						var oY = i;
						//console.log(`Starting row look at row ${pY+oY}`)
						for(j = 1; j < 35 + 1; j++) {
							var oX = j;
							var nX = pX+oX;
							var nY = pY+oY;
							if(outOfBounds(nX,nY)) {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
								break;
							};
							if(isEmpty(nX,nY)) {
								//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
								continue;
							};
							if(!isEmpty(nX,nY,true)) {
								var newPixel = pixelMap[nX][nY];
								var newElement = newPixel.element;
								if(enemyHumanoidArray.includes(newElement)) {
									//console.log(`Human part found at (${nX},${nY})`)
									if(!newPixel.dead) { //If not dead
										pixel.following = true;
										//console.log(`Human detected at (${nX},${nY})`)
										//Infect/kill if a human is close enough
										if(coordPyth(pX,pY,nX,nY) <= 1.5) { //approx. sqrt(2)
											if(Math.random() < 1/4) {	//One-fourth chance to change to blood
												changePixel(newPixel,"blood",false);
											} else {					//Remaining 3/4 chance to change to meat
												changePixel(newPixel,"meat",false);
											};
										};
									} else { //Mutilate if dead
										if(Math.random() < 1/4) {	//One-fourth chance to change to blood
											changePixel(newPixel,"blood",false);
										} else {					//Remaining 3/4 chance to change to meat
											changePixel(newPixel,"meat",false);
										};
									};
								} else {
									//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
									break; //can't see through humans
								};
							};
						};
					};
				};
			};
					
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

	runAfterLoad(function() {
		if(typeof(badPixels) === "object") {
			badPixels.nothing_there_phase_1 = { panicIncrease: 1, panicIncreaseChance: 1 } //insta-panic for "aleph" thing and "level 1" humans
			badPixels.nothing_there_phase_2 = { panicIncrease: 1, panicIncreaseChance: 1 }
			badPixels.nothing_there_phase_3_body = { panicIncrease: 1, panicIncreaseChance: 1 }
			badPixels.nothing_there_phase_3_head = { panicIncrease: 1, panicIncreaseChance: 1 }
		}
	});

	/* +-----------------------------------+
	   | End Nothing There elements        |
	   |                                   |
	   |                                   |
	   |                                   |
	   |                                   |
	   |                                   |
	   +-----------------------------------+ */

	/* +++++++++++++++++++++++++++
	   + Start skeleton elements +
	   +++++++++++++++++++++++++++ */

	arrowExcludedElements = ["wall"];

	arrowPlacementExcludedElements = ["skeleton_head", "skeleton_body", "arrow", "wall"];

	elements.rock.hardness = 0.55;

	elements.arrow = {
		cooldown: 2,
		flippableX: true,
		movable: true,
		properties: {
			flipY: false,
			speed: 5,
			fall: 0,
			attached: false,
			attachOffsets: [null, null],
			penetrateCounter: 7,
		},
		density: 2471,
		color: "#cacdcf",
		related: ["skeleton_body","skeleton_head"],
		movable: true,
		burn: 20,
		//burnInto: "flint",
		burnInto: "rock",
		burnTime: 250,
		breakInto: ["gravel","gravel","sawdust","feather"],
		tick: function(pixel) {
			if(pixel.attachOffsets.includes(null)) {
				pixel.attached = false;
			};
			if(pixel.attached) {
				var attachCoords = [pixel.x+pixel.attachOffsets[0], pixel.y+pixel.attachOffsets[1]];
				var attachX = pixel.x + pixel.attachOffsets[0];
				var attachY = pixel.y + pixel.attachOffsets[1];
				if(isEmpty(attachX,attachY,true)) {
					pixel.attached = false;
				} else {
					var attachPixel = pixelMap[attachX][attachY];
					var attachInfo = elements[attachPixel.element];
					var attachState = "solid";
					if(typeof(attachInfo.state) === "string") {
						attachState = attachInfo.state;
					};
					var attachBlacklistStates = ["liquid","gas"];
					if(attachBlacklistStates.includes(attachState)) {
						pixel.attached = false;
					};
				};
			} else { //Move if not attached
				var speedForBreakMult = pythSpeed(pixel.speed,pixel.y);
				var breakMult = speedForBreakMult/5;
				
				if(typeof(pixel.flipX) == undefined) {
					pixel.flipX = !!Math.floor(Math.random() * 2);
				};
				var dir = pixel.flipX ? -1 : 1;
				if(Math.random() < (1/(pixel.speed**1.585))) { //1/0 is Infinity in JavaScript, so this should always be true at 0 speed)
					pixel.fall++;
				};
				//Horizontal movement
				for(i = 0; i < pixel.speed; i++) {
					if(outOfBounds(pixel.x+dir,pixel.y)) {
						deletePixel(pixel.x,pixel.y);
						break;
					};
					if(!isEmpty(pixel.x+dir,pixel.y,true)) {
						var otherPixel = pixelMap[pixel.x+dir][pixel.y];
						var otherElement = otherPixel.element;
						var otherInfo = elements[otherElement];
						if(arrowExcludedElements.includes(otherElement)) {
							pixel.attached = true; //attach
							pixel.speed = 0;
							pixel.fall = 0;
							pixel.attachOffsets = [dir, 0];
							break;
						};
						var otherDensity = (typeof(otherInfo.density) === "undefined" ? 1000 : otherInfo.density);
						var swapChance = 1 - Math.max(0,(otherDensity / 2471));
						if(Math.random() < swapChance && pixel.penetrateCounter > 0) {
							swapPixels(pixel,otherPixel);
							arrowAltTb(otherPixel,breakMult);
							pixel.speed = Math.max(0,--pixel.speed);
							pixel.penetrateCounter--;
						} else {
							if(!arrowAltTb(otherPixel,breakMult)) { //if this didn't break it
								pixel.attached = true; //attach
								pixel.speed = 0;
								pixel.fall = 0;
								pixel.attachOffsets = [dir, 0];
							};
						};
						break;
					} else {
						tryMove(pixel,pixel.x+dir,pixel.y);
					};
				};
				if(Math.random() < 0.1) {
					pixel.speed = Math.max(0,--pixel.speed);
				};
				
				var dirY = 1;
				//Vertical movement
				if(typeof(pixel.flipY) !== "undefined") {
					if(pixel.flipY) {
						pixel.dirY = -1;
					};
				};

				for(j = 0; j < pixel.fall; j++) {
					if(outOfBounds(pixel.x,pixel.y+dirY)) {
						deletePixel(pixel.x,pixel.y);
						break;
					};
					if(!isEmpty(pixel.x,pixel.y+dirY,true)) {
						var otherPixel = pixelMap[pixel.x][pixel.y+dirY];
						var otherElement = otherPixel.element;
						var otherInfo = elements[otherElement];
						if(arrowExcludedElements.includes(otherElement)) {
							pixel.attached = true; //attach
							pixel.speed = 0;
							pixel.fall = 0;
							pixel.attachOffsets = [0, dirY];
							break;
						};
						var otherDensity = (typeof(otherInfo.density) === "undefined" ? 1000 : otherInfo.density);
						var swapChance = 1 - Math.max(0,(otherDensity / 2471));
						if(Math.random() < swapChance && pixel.penetrateCounter > 0) {
							swapPixels(pixel,otherPixel);
							arrowAltTb(otherPixel,breakMult);
							pixel.speed = Math.max(0,--pixel.speed);
							pixel.penetrateCounter--;
						} else {
							if(!arrowAltTb(otherPixel,breakMult)) { //if this didn't break it
								pixel.attached = true; //attach
								pixel.speed = 0;
								pixel.fall = 0;
								pixel.attachOffsets = [0, dirY];
							};
						};
						break;
					} else {
						tryMove(pixel,pixel.x,pixel.y+dirY);
					};
				};

				//End
			};
		},
	};

	elements.skeleton = {
		color: ["#ebebe6", "#cfcfc8"],
		category: "life",
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			following: false,
		},
		movable: true,
		tick: function(pixel) {
			if (isEmpty(pixel.x, pixel.y+1)) {
				createPixel("skeleton_body", pixel.x, pixel.y+1);
				pixel.element = "skeleton_head";
				pixel.color = pixelColorPick(pixel)
			}
			else if (isEmpty(pixel.x, pixel.y-1)) {
				createPixel("skeleton_head", pixel.x, pixel.y-1);
				pixelMap[pixel.x][pixel.y-1].color = pixel.color;
				pixel.element = "skeleton_body";
				pixel.color = pixelColorPick(pixel)
			}
			else {
				deletePixel(pixel.x, pixel.y);
			}
		},
		related: ["skeleton_body","skeleton_head"],
		desc: "<span class=\"skeletonStatus\">If this text is green or underlined, skeletons can spawn.</span> <span onclick=toggleSkeletonSpawning() style=\"color: #ff00ff;\";>Click here</span> to toggle skeleton spawning. If it's on, skeletons (all types) can spawn through random events."
	};

	elements.skeleton_body = {
		color: "#ebebe6",
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "bone",
		burn: 10,
		burnTime: 250,
		burnInto: ["bone","ash","arrow"],
		hardness: 0.55,
		breakInto: ["bone","bone","bone","bone_marrow"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
			chargeCounter: 20,
			shooting: false,
		},
		movable: true,
		tick: function(pixel) {
			if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
				if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
					var headPixel = pixelMap[pixel.x][pixel.y-2];
					if (headPixel.element == "skeleton_head") {
						if (isEmpty(pixel.x, pixel.y-1)) {
							movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
						}
						else {
							swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
						}
					}
				}
			}
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into bone if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					changePixel(pixel,"bone");
				}
				return
			}

			// Find the head
			if (!isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "skeleton_head") {
				var head = pixelMap[pixel.x][pixel.y-1];
				if (head.dead) { // If head is dead, kill body
					pixel.dead = head.dead;
				}
			}
			else { var head = null }

			if (isEmpty(pixel.x, pixel.y-1)) {
				// create blood if decapitated 10% chance (bone marrow)
				if (Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y-1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			else if (head == null) { return }
			else if (Math.random() < 0.1) { // Move 10% chance
				var movesToTry = [
					[1*pixel.dir,0],
					[1*pixel.dir,-1],
				];
				// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
				while (movesToTry.length > 0) {
					var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
					if (isEmpty(pixel.x+move[0], pixel.y+move[1]-1)) {
						if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
							movePixel(head, head.x+move[0], head.y+move[1]);
							break;
						};
					};
				};
				// 15% chance to change direction while not chasing a human
				if(!head.following) {
					if (Math.random() < 0.15) {
						pixel.dir *= -1;
						//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
					};
				}/* else {
					//console.log("*chases cutely*");
				};*/
			};

			if(pixel.shooting) {
				if(pixel.chargeCounter <= 0) {
					var bX = pixel.x + pixel.dir;
					var bY = pixel.y - 1;
					var arrowFlipX = null;
					if(pixel.dir < 0) {
						arrowFlipX = true;
					} else if(pixel.dir > 0) {
						arrowFlipX = false;
					};
					if(!outOfBounds(bX,bY)) {
						if(isEmpty(bX,bY)) {
							createPixel("arrow",bX,bY);
							pixelMap[bX][bY].flipX = arrowFlipX;
						} else {
							if(!arrowExcludedElements.includes(pixelMap[bX][bY].element) && !arrowPlacementExcludedElements.includes(pixelMap[bX][bY].element)) {
								deletePixel(bX,bY);
								createPixel("arrow",bX,bY);
								pixelMap[bX][bY].flipX = arrowFlipX;
							};
						};
					};
					pixel.chargeCounter = 20;
				};
				if(pixel.chargeCounter > 0) {
					pixel.chargeCounter--;
				};
			};
		},
	};

	elements.skeleton_head = {
		color: ["#ebebe6", "#cfcfc8"],
		category: "life",
		hidden: true,
		density: 1500,
		state: "solid",
		conduct: 25,
		tempHigh: 250,
		stateHigh: "bone",
		burn: 10,
		burnTime: 250,
		burnInto: ["bone","ash","arrow"],
		hardness: 0.55,
		breakInto: ["bone","bone","bone","bone_marrow"],
		reactions: {
			"cancer": { "elem1":"cancer", "chance":0.005 },
			"radiation": { "elem1":["ash","meat","rotten_meat","cooked_meat"], "chance":0.4 },
			"plague": { "elem1":"plague", "chance":0.05 },
		},
		properties: {
			dead: false,
			dir: 1,
			panic: 0,
		},
		movable: true,
		tick: function(pixel) {
			doHeat(pixel);
			doBurning(pixel);
			doElectricity(pixel);
			if (pixel.dead) {
				// Turn into bone if pixelTicks-dead > 500
				if (pixelTicks-pixel.dead > 200) {
					changePixel(pixel,"bone");
				}
				return
			}

			// Find the body
			if (!isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "skeleton_body") {
				var body = pixelMap[pixel.x][pixel.y+1];
				if (body.dead) { // If body is dead, kill head
					pixel.dead = body.dead;
				}
			}
			else { var body = null }

			if(body) {
				if(body.dir !== pixel.dir) { //hacky workaround: lock head dir to body dir
					pixel.dir = body.dir;
				};
			};

			if (isEmpty(pixel.x, pixel.y+1)) {
				tryMove(pixel, pixel.x, pixel.y+1);
				// create blood if severed 10% chance
				if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
					createPixel("blood", pixel.x, pixel.y+1);
					// set dead to true 15% chance
					if (Math.random() < 0.15) {
						pixel.dead = pixelTicks;
					}
				}
			}
			
			//start of most new code
			var pX = pixel.x;
			var pY = pixel.y;
			
			//Human detection loop (looks ahead according to direction and sets the "following" variable to true, telling the body to lock the direction)
			var directionAdverb = "left";
			if(pixel.dir > 0) {
				directionAdverb = "right";
			};
			//console.log(`Looking ${directionAdverb}`)
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									if(body) body.shooting = true;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(enemyHumanoidArray.includes(newElement)) {
								//console.log(`Human part found at (${nX},${nY})`)
								if(!newPixel.dead) {
									pixel.following = true;
									if(body) body.shooting = true;
								};
							} else {
								//console.log(`Stopping row look at pixel (${nX},${nY}) due to non-human pixel in the way`)
								break;
							};
						};
					};
				};
			};
			
			if(Math.random() < 0.01) { //1% chance each tick to lose interest
				pixel.following = false;
				//console.log("Meh.");
			};
		},
	};

	/* -------------------------
	   - End skeleton elements -
	   ------------------------- */
	mobsLoaded = true;
});
} else {
	if(!enabledMods.includes(runAfterAutogenMod))	{ enabledMods.splice(enabledMods.indexOf(modName),0,runAfterAutogenMod) };
	if(!enabledMods.includes(explodeAtPlusMod))		{ enabledMods.splice(enabledMods.indexOf(modName),0,explodeAtPlusMod) };
	if(!enabledMods.includes(libraryMod))			{ enabledMods.splice(enabledMods.indexOf(modName),0,libraryMod) };
	alert(`The "${runAfterAutogenMod}", "${libraryMod}", and "${explodeAtPlusMod}" mods are all required; any missing mods in this list have been automatically inserted (reload for this to take effect).`)
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
};
elements.sakura_wood = {
    color: "#632e1f",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.sakura_branch = {
    color: "#632e1f",
    behavior: [
        "CR:sakura,sakura_branch%2|CR:sakura,sakura,sakura,sakura_branch%2|CR:sakura,sakura_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "sakura_wood",
    tempLow: -30,
    stateLow: "sakura_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
    seed: "sakura_seed"
}
elements.sakura = {
    color: ["#ff7ad3","#ff94db","#ffa6f0"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:sakura_blossom%0.25|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    seed: "sakura_seed",
    hidden: true
}
elements.sakura_blossom = {
    color: ["#ff7ad3","#ff94db","#ffa6f0"],
    behavior: [
        "XX|XX|XX",
        "XX|FX%0.25 AND DL%0.65|XX",
        "M2%10|M1%10|M1%10",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    seed: "sakura_seed",
    hidden: true
}

elements.sakura_seed = {
    color: ["#ff7ad3","#ff94db","#ffa6f0"],
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "sakura_wood" : "sakura_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"sakura_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true
};


/* Beehive deprecated, Hive exists in base game
elements.beehive = {
    color: ["#ab985e","#948454"],
    tick: function(pixel){
        if (!pixel.pollen) { return; }
        if (isEmpty(pixel.x,pixel.y+1)) {
            if (Math.random() < 0.25) {
                createPixel("honey",pixel.x,pixel.y+1);
                pixel.pollen--;
            }
        }
        else {
            if (!outOfBounds(pixel.x,pixel.y+1) && pixelMap[pixel.x][pixel.y+1].element === "beehive") {
                pixelMap[pixel.x][pixel.y+1].pollen += pixel.pollen;
                pixel.pollen = 0;
            }
        }
        doDefaults(pixel);
    },
    properties: {
        "pollen": 0,
    },
    tempHigh: 248,
    stateHigh: ["fire","fire","ash"],
    burn: 70,
    burnTime: 300,
    burnInto: "ash",
    category: "life",
    state: "solid",
    density: 1201
}
elements.bee.reactions.beehive = {
    func: function(bee,hive) {
        if (bee.pollen) {
            hive.pollen++;
        }
        bee.pollen = null;
    }
}
*/

elements.dollar = {
    color: ["#324a26","#4e8732","#54803d","#698a58","#8aa87b"],
    behavior: [
        "XX|XX|XX",
        "XX|FX%0.25|XX",
        "M2%10|M1%10|M1%10",
    ],
    category: "powders",
    tempHigh: 400,
    stateHigh: ["ash","smoke","smoke","smoke"],
    burn:50,
    burnTime:200,
    burnInto: ["ash","smoke","smoke","smoke"],
    state: "solid",
    density: 500
}

elements.butterfly = {
    color: ["#ff562b","#ff7226","#ffdf2b","#2bfbff","#2134ff","#c226ff"],
    tick: behaviors.FLY,
    reactions: {
        "sugar_water": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "honey": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "sap": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "sugar": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "soda": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "caramel": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "juice": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
    },
    foodNeed: 5,
    tempHigh: 100,
    stateHigh: "ash",
    tempLow: 0,
    stateLow: "dead_bug",
    breakInto: "dead_bug",
    category:"life",
    burn:95,
    burnTime:25,
    state: "solid",
    density: 600,
    conduct: 1,
    baby: "caterpillar",
}
elements.caterpillar = {
    color: "#4b7847",
    behavior: [
        "XX|XX|XX",
        "XX|FX%8|M2%1 AND BO",
        "XX|M1|XX",
    ],
    tick: function(pixel) {
        if (pixelTicks - pixel.start > 500) {
            changePixel(pixel,"butterfly");
        }
    },
    reactions: {
        "plant": { elem2:null, chance:0.1 },
        "grass": { elem2:null, chance:0.1 },
        "dead_plant": { elem2:null, chance:0.1 },
        "sapling": { elem2:null, chance:0.1 },
        "sakura": { elem2:null, chance:0.1 },
        "sakura_seed": { elem2:null, chance:0.1 },
        "sakura_blossom": { elem2:null, chance:0.1 },
        "petal": { elem2:null, chance:0.1 },
        "flower_seed": { elem2:null, chance:0.1 },
        "wheat": { elem2:null, chance:0.1 },
        "vine": { elem2:null, chance:0.1 },
        "bamboo": { elem2:null, chance:0.1 },
        "bamboo_plant": { elem2:null, chance:0.1 },
        "evergreen": { elem2:null, chance:0.1 },
    },
    tempHigh: 100,
    stateHigh: "ash",
    tempLow: 0,
    stateLow: "dead_bug",
    breakInto: "dead_bug",
    category:"life",
    burn:95,
    burnTime:25,
    state: "solid",
    density: 500,
    conduct: 0.15
}

worldgentypes.spring = {
    layers: [
        [0.85, "dirt"],
        [0.05, "rock"],
        [0, "basalt"],
    ],
    decor: [
        ["sakura_seed", 0.04, 20],
        ["sapling", 0.04, 20],
        ["pinecone", 0.04, 20],
        ["grass", 0.25, 30],
        ["butterfly", 0.02, 25],
        ["bee", 0.02, 25],
        ["firefly", 0.02, 25],
        ["rain_cloud", 1, 2],
        ["rain_cloud", 1, 6],
        ["rain_cloud", 1, 10],
    ],
    baseHeight: 0.25
}

//if (!settings.bg) {settings.bg = "#00bfff";}
// CreateTree function made by nousernamefound.
function createTree(treeName, leafColor, woodName){
    let woodColor = elements[woodName].color
    elements[treeName + "_sapling"] = {
        color: leafColor,
        tick: function(pixel) {
            if (!tryMove(pixel,pixel.x,pixel.y+1)) {
                if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                    if (!outOfBounds(pixel.x,pixel.y+1)) {
                        var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                        if (dirtPixel && (eLists.SOIL.indexOf(dirtPixel.element) !== -1 || dirtPixel.element === "grass")) {
                            changePixel(dirtPixel,"root");
                        }
                    }
                    if (isEmpty(pixel.x,pixel.y-1)) {
                        if (!pixel.wc) {
                            pixel.wc = woodColor;
                            pixel.lc = leafColor;
                        }
                        movePixel(pixel,pixel.x,pixel.y-1);
                        createPixel(Math.random() > 0.5 ? woodName : (treeName + "_branch"),pixel.x,pixel.y+1);
                        pixelMap[pixel.x][pixel.y+1].wc = pixel.wc;
                        pixelMap[pixel.x][pixel.y+1].lc = pixel.lc;
                        pixelMap[pixel.x][pixel.y+1].color = pixelColorPick(pixelMap[pixel.x][pixel.y+1], pixel.wc);
                    }
                }
                else if (pixel.age > 1000 && Math.random() < 0.05) {
                    changePixel(pixel,woodName);
                    pixel.color = pixelColorPick(pixel, pixel.wc);
                }
                pixel.age++;
            }
            doDefaults(pixel);
        },
        properties: {
            "age":0
        },
        tempHigh: 100,
        stateHigh: "dead_plant",
        tempLow: -2,
        stateLow: "frozen_plant",
        burn: 65,
        burnTime: 15,
        category: "life",
        state: "solid",
        density: 1500,
        cooldown: defaultCooldown,
    }
    elements[treeName + "_branch"] = {
      color: woodColor,
      tick: function(pixel) {
          if (!pixel.burning) {
              if (!pixel.lc) { pixel.lc = leafColor }
              if (!pixel.wc) { pixel.wc = woodColor }
              if (isEmpty(pixel.x-1,pixel.y-1) && Math.random() < 0.02) {
                  if (Math.random() < 0.5) {
                      createPixel("plant",pixel.x-1,pixel.y-1);
                      pixelMap[pixel.x-1][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x-1][pixel.y-1], pixel.lc);
                  }
                  else {
                      createPixel(treeName + "_branch",pixel.x-1,pixel.y-1);
                      pixelMap[pixel.x-1][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x-1][pixel.y-1], pixel.wc);
                      pixelMap[pixel.x-1][pixel.y-1].wc = pixel.wc;
                      pixelMap[pixel.x-1][pixel.y-1].lc = pixel.lc;
                  }
              }
              if (isEmpty(pixel.x+1,pixel.y-1) && Math.random() < 0.02) {
                  if (Math.random() < 0.5) {
                      createPixel("plant",pixel.x+1,pixel.y-1);
                      pixelMap[pixel.x+1][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x+1][pixel.y-1], pixel.lc);
                  }
                  else {
                      createPixel(treeName + "_branch",pixel.x+1,pixel.y-1);
                      pixelMap[pixel.x+1][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x+1][pixel.y-1], pixel.wc);
                      pixelMap[pixel.x+1][pixel.y-1].wc = pixel.wc;
                      pixelMap[pixel.x+1][pixel.y-1].lc = pixel.lc;
                  }
              }
              if (isEmpty(pixel.x,pixel.y-1) && Math.random() < 0.02) {
                  if (Math.random() < 0.75) {
                      createPixel("plant",pixel.x,pixel.y-1);
                      pixelMap[pixel.x][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x][pixel.y-1], pixel.lc);
                  }
                  else {
                      createPixel(treeName + "_branch",pixel.x,pixel.y-1);
                      pixelMap[pixel.x][pixel.y-1].color = pixelColorPick(pixelMap[pixel.x][pixel.y-1], pixel.wc);
                      pixelMap[pixel.x][pixel.y-1].wc = pixel.wc;
                      pixelMap[pixel.x][pixel.y-1].lc = pixel.lc;
                  }
              }
          }
          doDefaults(pixel);
      },
      movable: false,
      tempHigh: 100,
      stateHigh: woodName,
      tempLow: -30,
      stateLow: woodName,
      category: "life",
      burn: 2,
      burnTime: 300,
      burnInto: ["sap","ember","charcoal","smoke"],
      hidden: true,
      state: "solid",
      density: 1500,
      hardness: 0.15,
      breakInto: ["sap","sawdust"],
      seed: treeName + "_sapling",
      forceSaveColor: true
    }
  }

elements.red_wood = {
    density: 450,
    burnTime: 100,
    burn: 15,
    color: "#D4381E",
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.7, // A highly durable wood
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.pine_wood = {
    density: 550,
    burnTime: 125,
    burn: 20,
    color: ["#D59F71", "#BC7852", "B46F4C", "#D59F71"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.4, // Medium hardness
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.oak = {
    density: 700,
    burnTime: 150,
    burn: 30,
    color: ["#ECCCAC", "C2965F", "D29A67", "B07C4F", "CAA06E"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.8, // Exceptionally hard and durable
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.birch = {
    density: 670,
    burnTime: 175,
    burn: 25,
    color: ["#FFFFFF", "#000000", "#FFFFFF"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.6, // Relatively hard
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.cherry_wood = {
    density: 400,
    burnTime: 100,
    burn: 10,
    color: ["#8E3D27", "#A44B2B", "#883B29"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.3, // Relatively soft
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.maple_wood = {
    density: 600,
    burnTime: 175,
    burn: 25,
    color: ["#DAA520", "#C68E17", "#FFD700"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.7, // Durable and dense
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.walnut_wood = {
    density: 750,
    burnTime: 225,
    burn: 30,
    color: ["#5A4522", "#3E2E1F", "#8B5A2B"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.9, // Extremely hard and dense
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.mahogany = {
    density: 800,
    burnTime: 250,
    burn: 35,
    color: ["#C04000", "#7B3F00", "#88441C"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.85, // Very hard and resistant to decay
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.cedar = {
    density: 480,
    burnTime: 150,
    burn: 20,
    color: ["#B8860B", "#CD853F", "#8B4513"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.5, // Moderately hard and lightweight
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.ash_wood = {
    density: 620,
    burnTime: 100,
    burn: 25,
    color: ["#A52A2A", "#D2691E", "#8B4513"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.6, // Hardwood with good shock resistance
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.poplar_wood = {
    density: 420,
    burnTime: 120,
    burn: 15,
    color: ["#9E8040", "#BEBD7F", "#D7D4BB"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.4, // Softwood with low density
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.fir_wood = {
    density: 560,
    burnTime: 130,
    burn: 20,
    color: ["#B4CDCD", "#8B9CA9", "#CED1D9"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.5, // Medium hardness and lightweight
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.teak = {
    density: 660,
    burnTime: 180,
    burn: 30,
    color: ["#B5651D", "#704214", "#8B4513"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.7, // High natural oil content and durability
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.spruce = {
    density: 480,
    burnTime: 110,
    burn: 15,
    color: ["#8B4513", "#B8860B", "#CD853F"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.5, // Moderately hard and lightweight
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.cypress_wood = {
    density: 520,
    burnTime: 140,
    burn: 20,
    color: ["#827A68", "#6B4226", "#A0522D"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.6, // Medium hardness with good decay resistance
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.beech_wood = {
    density: 670,
    burnTime: 160,
    burn: 25,
    color: ["#F0DC82", "#C0C0C0", "#9C661F"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.7, // Hardwood with good strength and wear resistance
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.sapele = {
    density: 670,
    burnTime: 150,
    burn: 25,
    color: ["#8B4513", "#FF4500", "#CD853F"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.8, // Hardwood with good stability and workability
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.pear_wood = {
    density: 670,
    burnTime: 160,
    burn: 20,
    color: ["#FFD700", "#CD853F", "#FF6347"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.6, // Hardwood with fine grain and smooth texture
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.hickory = {
    density: 800,
    burnTime: 200,
    burn: 30,
    color: ["#664C28", "#8B6914", "#8B4513"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.9, // Extremely hard and dense
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.sycamore = {
    density: 530,
    burnTime: 140,
    burn: 20,
    color: ["#F4A460", "#F0E68C", "#A0522D"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.5, // Medium hardness and lightweight
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.willow_wood = {
    density: 380,
    burnTime: 100,
    burn: 10,
    color: ["#C19A6B", "#8B4513", "#CD853F"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.3, // Softwood with low density
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.zebra_wood = {
    density: 800,
    burnTime: 220,
    burn: 30,
    color: ["#F0DC82", "#8B4513", "#FFD700"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.9, // Extremely hard and dense
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.basswood = {
    density: 410,
    burnTime: 110,
    burn: 15,
    color: ["#D2B48C", "#DEB887", "#F5F5DC"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.4, // Softwood with low density
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.larch_wood = {
    density: 590,
    burnTime: 130,
    burn: 20,
    color: ["#C9AE5D", "#E0C49D", "#9C661F"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.6, // Medium hardness with good durability
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.silver_maple = {
    density: 560,
    burnTime: 140,
    burn: 25,
    color: ["#C0C0C0", "#D3D3D3", "#BEBEBE"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.5, // Moderate hardness and lightweight
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.balsam_fir = {
    density: 460,
    burnTime: 120,
    burn: 15,
    color: ["#B4CDCD", "#8B9CA9", "#CED1D9"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.4, // Softwood with moderate hardness
    breakInto: "sawdust",
    burnInto: "ash"
};

elements.elm_wood = {
    density: 560,
    burnTime: 140,
    burn: 20,
    color: ["#8B4513", "#228B22", "#CD5C5C"],
    category: "solids",
    behavior: behaviors.WALL,
    state: "solid",
    hardness: 0.6, // Medium hardness and lightweight
    breakInto: "sawdust",
    burnInto: "ash",
};

createTree("red_wood", "#2E6E4E", "red_wood");
createTree("pine", "#D59F71", "pine_wood");
createTree("oak", "#ECCCAC", "oak");
createTree("birch", "#FFFFFF", "birch");
createTree("cherry_blossom", "#8E3D27", "cherry_wood");
createTree("maple", "#DAA520", "maple_wood");
createTree("walnut", "#5A4522", "walnut_wood");
createTree("mahogany", "#C04000", "mahogany");
createTree("cedar", "#B8860B", "cedar");
createTree("ash_wood", "#A52A2A", "ash_wood");
createTree("poplar_wood", "#9E8040", "poplar_wood");
createTree("fir_wood", "#B4CDCD", "fir_wood");
createTree("teak", "#B5651D", "teak");
createTree("spruce", "#8B4513", "spruce");
createTree("cypress", "#827A68", "cypress_wood");
createTree("beech", "#F0DC82", "beech_wood");
createTree("sapele", "#8B4513", "sapele");
createTree("pear", "#FFD700", "pear_wood");
createTree("hickory", "#664C28", "hickory");
createTree("sycamore", "#F4A460", "sycamore");
createTree("willow", "#C19A6B", "willow_wood");
createTree("zebra_wood", "#F0DC82", "zebra_wood");
createTree("basswood", "#D2B48C", "basswood");
createTree("larch", "#C9AE5D", "larch_wood");
createTree("silver_maple", "#C0C0C0", "silver_maple");
createTree("balsam_fir", "#B4CDCD", "balsam_fir");
createTree("elm", "#8B4513", "elm_wood");
elements.child =  {
    color: "#ffaa55",
    behavior:  [
      "M2|M2|M2",
      "M2|XX|M2",
      "XX|M1|XX"
  ],
    tempHigh: 100,
    stateHigh: "cooked_meat",
    category: "life",
    reactions:  {
      "herb":  { elem1: "blood", elem2: "explosion"}
  },
  };
  elements.dog_food = {
	color: ["#402101", "#1f1001", "#2e1701", "#2b1601", "#261604"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
    tempHigh: 500,
    stateHigh: "ash",
    isFood: true,
};

elements.ice_cube = {
	color: ["#ccf4ff", "#c6e3f5", "#b6d1f2",],
	behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX"
    ],
	category: "food",
	state: "solid",
    temp: -5,
    tempHigh: 0,
    stateHigh: "water",
    isFood: true,
};

elements.dog_with_rabies = {
	color: ["#c7a950", "#f7f6eb", "#152617", "#665d20", "#454420" ],
	behavior: [
        "XX|XX|XX",
        "M2%25|LB:foam%25|M2%25",
        "M2|M1|M2"
    ],
    reactions: {
        "meat": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "egg": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "yolk": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "cheese": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "ice_cube": {elem2:null, chance:0.8, func:behaviors.FEEDPIXEL },
        "cooked_meat": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "chocolate": {elem2:null, chance: 0.2, func:behaviors.FEEDPIXEL, elem1: "rotten_meat"},
        "grape": {elem2:null, chance: 0.2, func:behaviors.FEEDPIXEL, elem1: "rotten_meat"},
        "rat": {elem2:null, chance: 0.3, func:behaviors.FEEDPIXEL },
        "dog_food": {elem2:null, chance: 0.8, func:behaviors.FEEDPIXEL },
        "nut_butter": {elem2:null, chance: 0.5, func:behaviors.FEEDPIXEL },
    },
	category:"life",
	state:"solid",
    tempHigh: 100,
    stateHigh: "cooked_meat",
    breakInto: "rotten_meat",
    tempLow: -20,
    stateLow: "frozen_meat",
    hidden: true,
};

elements.dog = {
	color: ["c78950", "#ffffff", "#262524", "#664120", "#453120" ],
	behavior: [
        "XX|XX|XX",
        "M2%7|XX|M2%7",
        "M2|M1|M2"
    ],
    reactions: {
        "meat": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "egg": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "yolk": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "cheese": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "ice_cube": {elem2:null, chance:0.8, func:behaviors.FEEDPIXEL },
        "cooked_meat": {elem2:null, chance:0.5, func:behaviors.FEEDPIXEL },
        "chocolate": {elem2:null, chance: 0.2, func:behaviors.FEEDPIXEL, elem1: "rotten_meat"},
        "grape": {elem2:null, chance: 0.2, func:behaviors.FEEDPIXEL, elem1: "rotten_meat"},
        "rat": {elem2:null, chance: 0.3, func:behaviors.FEEDPIXEL },
        "dog_food": {elem2:null, chance: 0.8, func:behaviors.FEEDPIXEL },
        "nut_butter": {elem2:null, chance: 0.5, func:behaviors.FEEDPIXEL },
        "infection": {elem1:"dog_with_rabies", chance:0.4 },
        "dog_with_rabies": {elem1:"dog_with_rabies", chance:0.3},
    },
	category:"life",
	state:"solid",
    tempHigh: 100,
    stateHigh: "cooked_meat",
    breakInto: "rotten_meat",
    tempLow: -20,
    stateLow: "frozen_meat",
};
// made by squarescreamyt

elements.cat = {
    color: ["#c05811","#cf7941","#d4ccc5","#ffe7b3","#f7b484","#ef7d51","#c15c37","#8e4024","#5f2612","#3a2930","#6b4540","#9d654f","#c68b68","#e2b98d","#ffe8aa","#292c33","#4b4f55","#76797e","#a5a6a7","#d5cfcd","#fff1e8"],
	state: "solid",
    behavior: [
        "M2%1|M2%2|M2%1",
        "M2%10|XX|M2%10",
        "XX|M1|XX",
    ],
    reactions: {
        "meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "cooked_meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "fish": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "rat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "cat_food": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "alcohol": { elem1:"meat", chance:0.025 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
        "pool_water": { elem1:"rotten_meat", chance:0.005 },
        "vinegar": { elem1:"rotten_meat", chance:0.001 },
    },
    egg: "kitten",
    foodNeed: 10,
    temp: 30,
    tempHigh: 100,
    stateHigh: "cooked_meat",
    tempLow: -18,
    stateLow: "frozen_meat",
    category:"life",
    breakInto: "rotten_meat",
    burn:15,
    burnTime:300,
    state: "solid",
    density: 1450,
    conduct: 0.2
};

elements.kitten = {
    color: ["#c05811","#cf7941","#d4ccc5","#ffe7b3","#f7b484","#ef7d51","#c15c37","#8e4024","#5f2612","#3a2930","#6b4540","#9d654f","#c68b68","#e2b98d","#ffe8aa","#292c33","#4b4f55","#76797e","#a5a6a7","#d5cfcd","#fff1e8"],
	state: "solid",
    behavior: [
        "M2%1|M2%2|M2%1",
        "M2%10|FX%5 AND CH:cat%0.1|M2%10",
        "XX|M1|XX",
    ],
    reactions: {
        "meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "cooked_meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "fish": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "cat_food": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "rat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "alcohol": { elem1:"meat", chance:0.025 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
        "pool_water": { elem1:"rotten_meat", chance:0.005 },
        "vinegar": { elem1:"rotten_meat", chance:0.001 },
    },
    egg: "kitten",
    foodNeed: 10,
    temp: 30,
    tempHigh: 100,
    stateHigh: "cooked_meat",
    tempLow: -18,
    stateLow: "frozen_meat",
    category:"life",
    breakInto: "rotten_meat",
    burn:15,
    burnTime:300,
    state: "solid",
    density: 1450,
    conduct: 0.2
};

elements.cat_food = {
	color: ["#b0853c","#c28e4a","#ab8e38","#b56845","#ab6f44","#b57f38"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 1000,
    stateHigh: ["ash", "smoke"],
    density: 820.33,
    isFood: true
};

if (!elements.batter.reactions) elements.batter.reactions = {};
elements.batter.reactions.meat = { elem1: "cat_food", elem2: "cat_food" }
// by Nekonico

viewInfo[4] = { // Nutrition View
    name: "nutr",
    pixel: function(pixel,ctx) {
        if (elements[pixel.element].isBio === true) {
        var nutrition = pixel.nutrition;
        if (nutrition < 0) {nutrition = 0}
        if (nutrition > 6000) {nutrition = 6000}
        var hue = Math.round(225 - (Math.log(nutrition)/Math.log(6000))*225);
        if (hue < 0) {hue = 0}
        if (hue > 225) {hue = 225}
        drawSquare(ctx,"hsl("+hue+",100%,50%)",pixel.x,pixel.y)
        }
    }
}

viewInfo[5] = { // Oxygen View
    name: "oxy",
    pixel: function(pixel,ctx) {
        if (elements[pixel.element].isBio === true) {
            var oxygen = pixel.oxygen;
            if (oxygen < 0) {oxygen = 0}
            if (oxygen > 6000) {oxygen = 6000}
            var hue = Math.round(225 - (Math.log(oxygen)/Math.log(6000))*225);
            if (hue < 0) {hue = 0}
            if (hue > 225) {hue = 225}
            drawSquare(ctx,"hsl("+hue+",100%,50%)",pixel.x,pixel.y)
        }
    }
}

viewInfo[6] = { // Speed View
    name: "spd",
    pixel: function(pixel,ctx) {
        if (elements[pixel.element].isBio === true) {
            var speed = pixel.speed;
            if (speed < -50) {speed = -50}
            if (speed > 150) {speed = 150}
            var hue = Math.round(225 - (Math.log(speed+50)/Math.log(100+50))*225);
            if (hue < 0) {hue = 0}
            if (hue > 225) {hue = 225}
            drawSquare(ctx,"hsl("+hue+",100%,50%)",pixel.x,pixel.y)
        }
    }
}

viewInfo[7] = { // Illness View
    name: "ill",
    pixel: function(pixel,ctx) {
        if ((elements[pixel.element].id === elements.cyanide_gas.id || elements[pixel.element].id === elements.poison_gas.id || elements[pixel.element].id === elements.poison.id || elements[pixel.element].id === elements.cyanide.id || elements[pixel.element].id === elements.infected_vessel.id || elements[pixel.element].id === elements.infection.id || elements[pixel.element].id === elements.cancer.id || elements[pixel.element].id === elements.plague.id || elements[pixel.element].id === elements.rotten_meat.id) || (elements[pixel.element].isBio === true && ((pixel.speed < -5 || pixel.oxygen < 250 || pixel.nutrition < 250) || pixel.ibupCount > 0 || pixel.poisoned === true || pixel.sick === true || pixel.alcoholic === true)) || ((elements[pixel.element].id === elements.digested_material.id || elements[pixel.element].id === elements.gaseous_material.id) && ((pixel.speed < 0 || pixel.nutrition < 5) || pixel.poisoned === true) && (pixel.immune !== true || !pixel.immune))) {
            var a = (settings.textures !== 0) ? pixel.alpha : undefined;
                    if (((elements[pixel.element].isGas && elements[pixel.element].glow !== false) || elements[pixel.element].glow || pixel.glow) && pixel.glow !== false) {
                        drawPlus(ctx,pixel.color,pixel.x,pixel.y,undefined,a)
                        // if (isEmpty(pixel.x+1,pixel.y) || isEmpty(pixel.x-1,pixel.y) || isEmpty(pixel.x,pixel.y+1) || isEmpty(pixel.x,pixel.y-1)) {}
                    }
                    else {
                        drawSquare(ctx,pixel.color,pixel.x,pixel.y,undefined,a)
                    }
                    if (pixel.charge && view !== 2) { // Yellow glow on charge
                        if (!elements[pixel.element].colorOn) {
                            drawSquare(ctx,"rgba(255,255,0,0.5)",pixel.x,pixel.y);
                        }
                    }
        }
    }
}

var ibuprofenTime = pixelTicks

renderPresets.FLESHBURN = function(pixel,ctx) {
    drawDefault(ctx,pixel);
    if (!viewInfo[view].colorEffects || !pixel.char) { return }
    var max = 20;
    var ratio = ((pixel.char/max*100)|0)/100;
    if (ratio < 0.5) { return }
    if (ratio > 1) { ratio = 1 }
    drawSquare(ctx,"#000000",pixel.x,pixel.y,undefined,Math.min(0.8,(ratio-0.5)*0.8));
},

renderPresets.NERVE = function(pixel,ctx) {
    drawDefault(ctx,pixel)
        if (pixel.darkcharge === true) {
            drawSquare(ctx,"#000000",pixel.x,pixel.y,undefined,Math.min(0.8,0.55));
        }
        if (pixel.darkchargeCD === true) {
            drawSquare(ctx,"#000000",pixel.x,pixel.y,undefined,Math.min(0.8,0.5));
        }
        if (pixel.lightcharge === true) {
            drawSquare(ctx,"#ffffff",pixel.x,pixel.y,undefined,Math.min(0.8,0.55));
        }
        if (pixel.lightchargeCD === true) {
            drawSquare(ctx,"#ffffff",pixel.x,pixel.y,undefined,Math.min(0.8,0.5));
        }
},

behaviorRules.BCF = function() {
    if (btemp.pixel.clone) {
        if (isEmpty(btemp.newCoords.x, btemp.newCoords.y)) {
            createPixel(btemp.pixel.clone, btemp.newCoords.x, btemp.newCoords.y)
            btemp.pixel.nutrition = (btemp.pixel.nutrition - 10)
            btemp.pixel.oxygen = (btemp.pixel.oxygen - 1)
            if (pixelMap[btemp.newCoords.x][btemp.newCoords.y]) {
                pixelMap[btemp.newCoords.x][btemp.newCoords.y].temp = btemp.pixel.temp;
                pixelTempCheck(pixelMap[btemp.newCoords.x][btemp.newCoords.y]);
            }
        }
    }
    else {
        if (!isEmpty(btemp.newCoords.x, btemp.newCoords.y,true)) {
            var newPixel = pixelMap[btemp.newCoords.x][btemp.newCoords.y];
            if (!btemp.pixel.clone && btemp.info.ignore && btemp.info.ignore.indexOf(newPixel.element) !== -1) {
                return;
            }
            if (newPixel.element !== btemp.pixel.element) {
                btemp.pixel.clone = newPixel.element;
                btemp.pixel.temp = newPixel.temp;
            }
            else if (newPixel.clone) {
                btemp.pixel.clone = newPixel.clone;
                btemp.pixel.temp = newPixel.temp;
            }
        }
    }
}

behaviorRules.BCR = function() {
    if (isEmpty(btemp.newCoords.x,btemp.newCoords.y)) {
        if (btemp.arg == null) {
            btemp.arg = btemp.pixel.element;
        }
        else if (btemp.arg.indexOf(",") !== -1) {
            btemp.arg = choose(btemp.arg.split(","));
        }
        if (elements[btemp.arg]) {
            createPixel(btemp.arg,btemp.newCoords.x,btemp.newCoords.y);
            btemp.pixel.nutrition = (btemp.pixel.nutrition - 1)
            if (btemp.info.fireColor && btemp.arg==="fire") {
                pixelMap[btemp.newCoords.x][btemp.newCoords.y].color = pixelColorPick(pixelMap[btemp.newCoords.x][btemp.newCoords.y],btemp.info.fireColor);
            }
            pixelMap[btemp.newCoords.x][btemp.newCoords.y].temp = btemp.pixel.temp
            pixelTempCheck(pixelMap[btemp.newCoords.x][btemp.newCoords.y]);
        }
    }
}

behaviorRules.ADB = function() {
        if (!isEmpty(btemp.newCoords.x,btemp.newCoords.y,true)) {
            // if the pixel at newCoords is the same element as the pixel, ignore
            var newPixel = pixelMap[btemp.newCoords.x][btemp.newCoords.y];
            // if info.ignore exists and newPixel.element is in it
            if (btemp.info.ignore && btemp.info.ignore.indexOf(newPixel.element) !== -1) {
                return;
            }
            if (!(newPixel.element == btemp.pixel.element)) {
                if (btemp.arg != null) { var args = btemp.arg.split(","); }
                if (btemp.arg == null || args.indexOf(newPixel.element) !== -1) {
                    if (!elements[newPixel.element].hardness || Math.random() > elements[newPixel.element].hardness) {
                        if (elements[newPixel.element].isFood === true && !elements[btemp.pixel.element].reactions[newPixel.element]) {
                            changePixel(newPixel,"digested_material");
                            newPixel.nutrition = 10;
                            if (pixelMap[btemp.pixel.x][btemp.pixel.y] != undefined) {
                                deletePixel(btemp.pixel.x,btemp.pixel.y);
                            }
                            btemp.deleted = true;
                            btemp.swapSpots = [];
                        }
                        else if (elements[newPixel.element].isFood != true && !elements[btemp.pixel.element].reactions[newPixel.element]) {
                                if (elements[newPixel.element].hardness < 0.9 || !elements[newPixel.element].hardness) {
                                deletePixel(btemp.newCoords.x,btemp.newCoords.y);
                                if (pixelMap[btemp.pixel.x][btemp.pixel.y] != undefined) {
                                    deletePixel(btemp.pixel.x,btemp.pixel.y);
                                }
                                btemp.deleted = true;
                                btemp.swapSpots = [];
                            }
                        }
                    }
                }
            }
        }
    },

doBioNorm = function(pixel) {
if ((Math.random() > 0.92 && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() < (pixel.ibupCount / 20) && pixel.ibupCount > 3 && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() < (pixel.fentDepri / 100) && pixel.fenAddict === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() < (pixel.alcoDepri / 100) && pixel.alcoholic === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() > 0.60 && pixel.sick === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() > 0.5 && pixel.poisoned === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.burning === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.temp > 53 && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.temp < -10 && pixel.nutrition > 0 && pixel.oxygen > 0) || Math.random() > 0.85 && Math.random() < (pixel.burnt / 100)) {
    pixel.nutrition -= 0.5
    pixel.oxygen--
}
if (pixel.temp > 42 && pixel.ibupCount > 1) { 
    pixel.temp -= 5 
}
else if (pixel.temp > 37 && pixel.ibupCount > 0) { 
    pixel.temp-- 
}
if (Math.random() > 0.5 && (pixel.nutrition < 1 || pixel.oxygen < 1 || pixel.speed < -100)) {
    if (elements[pixel.element].isMultiDie === true) {
        if (pixel.temp > 95) {
            if (Math.random() < 0.75) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].heatDie); 
            }
        }
        else if (pixel.temp < -15) {
            if (Math.random() < 0.75) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].coldDie); 
            }
        }
        else {
            if (Math.random() < 0.999) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].roomDie); 
            }
        }
        }
        else if (elements[pixel.element].isMultiDie === false) {
            if (Math.random() < 0.75) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].otherDie); 
            }
        }
}
if (pixel.nutrition === null || isNaN(pixel.nutrition)) {
    pixel.nutrition = 500
}
if (pixel.oxygen === null || isNaN(pixel.oxygen)) {
    pixel.oxygen = 500
}
if (pixel.speed === null || isNaN(pixel.speed)) {
    pixel.speed = 0
}
if ((pixel.alcoDepri || pixel.alcoDepri === 0) && pixel.alcoholic === true) {
    pixel.alcoDepri += 1
}
if (pixel.alcoTime < (pixelTicks - 10000) && pixel.alcoholic === true && Math.random() > 0.999 || pixel.alcoRecover === true) {
    pixel.alcoDepri = undefined
    pixel.alcoTime = undefined
    pixel.alcoholic = false
    pixel.alcoRecover = true
}
if ((pixel.fentDepri || pixel.fentDepri === 0) && pixel.fenAddict === true) {
    pixel.fentDepri += 1
}
if (pixel.poisonImmune === true) {
    pixel.fentDepri = undefined
    pixel.fenAddict = false
}
if (pixel.poisonImmune === true && pixel.poisoned != false) {
    pixel.poisoned = false
}
if ((pixel.poisonImmune === true || pixel.immune === true) && pixel.sick != false) {
    pixel.sick = false
}
if (ibuprofenTime < pixelTicks - 1000 && (pixel.ibup || pixel.ibupCount > 0)) {
    pixel.ibup = false
    pixel.ibupCount = false
}
if ((pixel.temp > 124.55 || pixel.burning) && Math.random() > 0.5) {
    if (!pixel.burnt) { pixel.burnt = 1 }
    else { pixel.burnt ++ }
}
if (pixel.char != pixel.burnt && pixel.burnt > pixel.char || !pixel.char) {
    pixel.char = pixel.burnt
}
if (!isEmpty(pixel.x, pixel.y-1, true)) {
    var hitPixel = pixelMap[pixel.x][pixel.y-1]
    if (elements[hitPixel.element].isBio === true) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
    else if (hitPixel.burning && Math.random() > 0.9) {
        if (!pixel.burnt) { pixel.burnt = 1 }
        else { pixel.burnt ++ }
    }
}
if (!isEmpty(pixel.x, pixel.y+1, true)) {
    var hitPixel = pixelMap[pixel.x][pixel.y+1]
    if (elements[hitPixel.element].isBio === true) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
    else if (hitPixel.burning && Math.random() > 0.9) {
        if (!pixel.burnt) { pixel.burnt = 1 }
        else { pixel.burnt ++ }
    }
}
if (!isEmpty(pixel.x-1, pixel.y, true)) {
    var hitPixel = pixelMap[pixel.x-1][pixel.y]
    if (elements[hitPixel.element].isBio === true) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
    else if (hitPixel.burning && Math.random() > 0.9) {
        if (!pixel.burnt) { pixel.burnt = 1 }
        else { pixel.burnt ++ }
    }
}
if (!isEmpty(pixel.x+1, pixel.y, true)) {
    var hitPixel = pixelMap[pixel.x+1][pixel.y]
    if (elements[hitPixel.element].isBio === true) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
    else if (hitPixel.burning && Math.random() > 0.9) {
        if (!pixel.burnt) { pixel.burnt = 1 }
        else { pixel.burnt ++ }
    }
}
}

doBioBlood = function(pixel) {
if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.001) {
    for (var i = 0; i < squareCoords.length; i++) {
        var coords = squareCoords[i];
        var x = pixel.x + coords[0];
        var y = pixel.y + coords[1];
        if (isEmpty(x,y)) {
            createPixel("flesh",x,y);
        }
    }
}
if ((Math.random() > (elements[pixel.element].ageRate) && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() < (pixel.alcoDepri / 100) && pixel.alcoholic === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() > 0.60 && pixel.sick === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() > 0.5 && pixel.poisoned === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.burning === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.temp > 53 && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.temp < -10 && pixel.nutrition > 0 && pixel.oxygen > 0) || Math.random() > 0.85 && Math.random() < (pixel.burnt / 100) ) {
    pixel.nutrition -= 0.5
    pixel.oxygen--
}
if (pixel.temp > 42 && pixel.ibupCount > 0) { 
    pixel.temp -= 5 
    pixel.ibupCount--
}
else if (pixel.temp > 37 && pixel.ibupCount > 0) { 
    pixel.temp-- 
    pixel.ibupCount--
}
if (Math.random() > 0.5 && (pixel.nutrition < 1 || pixel.oxygen < 1 || pixel.speed < -100)) {
    if (pixel.poisoned === true || pixel.sick === true) {
        changePixel(pixel,"infection")
    }
    else {
        changePixel(pixel,elements[pixel.element].bleed);
    }
}
if (pixel.nutrition === null || isNaN(pixel.nutrition)) {
    pixel.nutrition = 500
}
if (pixel.oxygen === null || isNaN(pixel.oxygen)) {
    pixel.oxygen = 500
}
if (pixel.speed === null || isNaN(pixel.speed)) {
    pixel.speed = 0
}
if ((pixel.alcoDepri || pixel.alcoDepri === 0) && pixel.alcoholic === true) {
    pixel.alcoDepri += 1
}
if (pixel.alcoTime < (pixelTicks - 10000) && pixel.alcoholic === true && Math.random() > 0.999 || pixel.alcoRecover === true) {
    pixel.alcoDepri = undefined
    pixel.alcoTime = undefined
    pixel.alcoholic = false
    pixel.alcoRecover = true
}
if (pixel.poisonImmune === true && pixel.poisoned != false) {
    pixel.poisoned = false
}
if ((pixel.poisonImmune === true || pixel.immune === true) && pixel.sick != false) {
    pixel.sick = false
}
if (ibuprofenTime < pixelTicks - 1000 && (pixel.ibup || pixel.ibupCount > 0)) {
    pixel.ibup = false
    pixel.ibupCount = false
}
if ((pixel.temp > 124.55 || pixel.burning) && Math.random() > 0.5) {
    if (!pixel.burnt) { pixel.burnt = 1 }
    else { pixel.burnt ++ }
}
if ((pixel.temp > 150 || pixel.burning) && Math.random() > 0.95) {
    if (!pixel.burnt) { pixel.burnt = 1 }
    else { pixel.burnt ++ }
}
if (pixel.char != pixel.burnt && pixel.burnt > pixel.char || !pixel.char) {
    pixel.char = pixel.burnt
}
if (!isEmpty(pixel.x, pixel.y-1, true)) {
    var hitPixel = pixelMap[pixel.x][pixel.y-1]
    if (elements[hitPixel.element].isBio === true) {
        if (hitPixel.oxygen < pixel.oxygen) {
            if (pixel.heartAttached === true) {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans + 10)
                pixel.oxygen -= (elements[pixel.element].oxygTrans + 9)
            }
            else {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans)
                pixel.oxygen -= (elements[pixel.element].oxygTrans)
            }
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            if (pixel.heartAttached === true) {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans + 10)
                pixel.nutrition -= (elements[pixel.element].nutrTrans + 10)
            }
            else {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans)
                pixel.nutrition -= (elements[pixel.element].nutrTrans)
            }
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
        if (elements[hitPixel.element].isBlood === true && pixel.heartAttached === true && hitPixel.heartAttached === false && Math.random() > 0.5) {
            hitPixel.heartAttached = true
        }
    }
}
else if (isEmpty(pixel.x, pixel.y-1) && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
    if (Math.random() > 0.95) {
        if (pixel.poisonImmune === true) {
            createPixel("antibody",pixel.x,pixel.y-1)
        }
        else if (pixel.poisoned === true || pixel.sick === true) {
            createPixel("infection",pixel.x,pixel.y-1)
        }
        else {
            createPixel(elements[pixel.element].bleed,pixel.x,pixel.y-1)
        }
    }
    pixel.oxygen -= 50
    pixel.nutrition -= 50
}
if (!isEmpty(pixel.x, pixel.y+1, true)) {
    var hitPixel = pixelMap[pixel.x][pixel.y+1]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            if (pixel.heartAttached === true) {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans + 10)
                pixel.oxygen -= (elements[pixel.element].oxygTrans + 9)
            }
            else {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans)
                pixel.oxygen -= (elements[pixel.element].oxygTrans)
            }
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            if (pixel.heartAttached === true) {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans + 10)
                pixel.nutrition -= (elements[pixel.element].nutrTrans + 10)
            }
            else {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans)
                pixel.nutrition -= (elements[pixel.element].nutrTrans)
            }
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
        if (elements[hitPixel.element].isBlood === true && pixel.heartAttached === true && hitPixel.heartAttached === false && Math.random() > 0.5) {
            hitPixel.heartAttached = true
        }
    }
}
else if (isEmpty(pixel.x, pixel.y+1) && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
    if (Math.random() > 0.95) {
        if (pixel.poisonImmune === true) {
            createPixel("antibody",pixel.x,pixel.y+1)
        }
        else if (pixel.poisoned === true || pixel.sick === true) {
            createPixel("infection",pixel.x,pixel.y+1)
        }
        else {
            createPixel(elements[pixel.element].bleed,pixel.x,pixel.y+1)
        }
    }
    pixel.oxygen -= 50
    pixel.nutrition -= 50
}
if (!isEmpty(pixel.x-1, pixel.y, true)) {
    var hitPixel = pixelMap[pixel.x-1][pixel.y]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            if (pixel.heartAttached === true) {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans + 10)
                pixel.oxygen -= (elements[pixel.element].oxygTrans + 9)
            }
            else {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans)
                pixel.oxygen -= (elements[pixel.element].oxygTrans)
            }
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            if (pixel.heartAttached === true) {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans + 10)
                pixel.nutrition -= (elements[pixel.element].nutrTrans + 10)
            }
            else {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans)
                pixel.nutrition -= (elements[pixel.element].nutrTrans)
            }
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
        if (elements[hitPixel.element].isBlood === true && pixel.heartAttached === true && hitPixel.heartAttached === false && Math.random() > 0.5) {
            hitPixel.heartAttached = true
        }
    }
}
else if (isEmpty(pixel.x-1, pixel.y) && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
    if (Math.random() > 0.95) {
        if (pixel.poisonImmune === true) {
            createPixel("antibody",pixel.x-1,pixel.y)
        }
        else if (pixel.poisoned === true || pixel.sick === true) {
            createPixel("infection",pixel.x-1,pixel.y)
        }
        else {
            createPixel(elements[pixel.element].bleed,pixel.x-1,pixel.y)
        }
    }
    pixel.oxygen -= 50
    pixel.nutrition -= 50
}
if (!isEmpty(pixel.x+1, pixel.y, true)) {
    var hitPixel = pixelMap[pixel.x+1][pixel.y]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            if (pixel.heartAttached === true) {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans + 10)
                pixel.oxygen -= (elements[pixel.element].oxygTrans + 9)
            }
            else {
                hitPixel.oxygen += (elements[pixel.element].oxygTrans)
                pixel.oxygen -= (elements[pixel.element].oxygTrans)
            }
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            if (pixel.heartAttached === true) {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans + 10)
                pixel.nutrition -= (elements[pixel.element].nutrTrans + 10)
            }
            else {
                hitPixel.nutrition += (elements[pixel.element].nutrTrans)
                pixel.nutrition -= (elements[pixel.element].nutrTrans)
            }
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
        if (elements[hitPixel.element].isBlood === true && pixel.heartAttached === true && hitPixel.heartAttached === false && Math.random() > 0.5) {
            hitPixel.heartAttached = true
        }
    }
}
else if (isEmpty(pixel.x+1, pixel.y) && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
    if (Math.random() > 0.95) {
        if (pixel.poisonImmune === true) {
            createPixel("antibody",pixel.x+1,pixel.y)
        }
        else if (pixel.poisoned === true || pixel.sick === true) {
            createPixel("infection",pixel.x+1,pixel.y)
        }
        else {
            createPixel(elements[pixel.element].bleed,pixel.x+1,pixel.y)
        }
    }
    pixel.oxygen -= 50
    pixel.nutrition -= 50
}
}

doBioBone = function(pixel){
if ((Math.random() > 0.995 && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() < (pixel.alcoDepri / 100) && pixel.alcoholic === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() > 0.60 && pixel.sick === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (Math.random() > 0.5 && pixel.poisoned === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.burning === true && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.temp > 55 && pixel.nutrition > 0 && pixel.oxygen > 0) || (pixel.temp < -10 && pixel.nutrition > 0 && pixel.oxygen > 0) || Math.random() > 0.85 && Math.random() < (pixel.burnt / 100)) {
    pixel.nutrition -= 0.5
    pixel.oxygen--
}
if (pixel.temp > 42 && pixel.ibupCount > 0) { 
    pixel.temp -= 5 
    pixel.ibupCount--
}
else if (pixel.temp > 37 && pixel.ibupCount > 0) { 
    pixel.temp-- 
    pixel.ibupCount--
}
if (Math.random() > 0.5 && (pixel.nutrition < 1 || pixel.oxygen < 1 || pixel.speed < -100)) {
    if (elements[pixel.element].isMultiDie === true) {
        if (pixel.temp > 95) {
            if (Math.random() < 0.75) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].heatDie); 
            }
        }
        else if (pixel.temp < -15) {
            if (Math.random() < 0.75) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].coldDie); 
            }
        }
        else {
            if (Math.random() < 0.999) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].roomDie); 
            }
        }
        }
        else if (elements[pixel.element].isMultiDie === false) {
            if (Math.random() < 0.75) {
                changePixel(pixel,elements[pixel.element].normDie); 
            }
            else {
                changePixel(pixel,elements[pixel.element].otherDie); 
            }
        }
}
if (pixel.nutrition === null || isNaN(pixel.nutrition)) {
    pixel.nutrition = 500
}
if (pixel.oxygen === null || isNaN(pixel.oxygen)) {
    pixel.oxygen = 500
}
if (pixel.speed === null || isNaN(pixel.speed)) {
    pixel.speed = 0
}
if ((pixel.alcoDepri || pixel.alcoDepri === 0) && pixel.alcoholic === true) {
    pixel.alcoDepri += 1
}
if (pixel.alcoTime < (pixelTicks - 10000) && pixel.alcoholic === true && Math.random() > 0.999 || pixel.alcoRecover === true) {
    pixel.alcoDepri = undefined
    pixel.alcoTime = undefined
    pixel.alcoholic = false
    pixel.alcoRecover = true
}
if (pixel.poisonImmune === true && pixel.poisoned != false) {
    pixel.poisoned = false
}
if ((pixel.poisonImmune === true || pixel.immune === true) && pixel.sick != false) {
    pixel.sick = false
}
if (ibuprofenTime < pixelTicks - 1000 && (pixel.ibup || pixel.ibupCount > 0)) {
    pixel.ibup = false
    pixel.ibupCount = false
}
if ((pixel.temp > 124.55 || pixel.burning) && Math.random() > 0.5) {
    if (!pixel.burnt) { pixel.burnt = 1 }
    else { pixel.burnt ++ }
}
if ((pixel.temp > 66 || pixel.burning) && Math.random() > 0.95) {
    if (!pixel.burnt) { pixel.burnt = 1 }
    else { pixel.burnt ++ }
}
if (pixel.char != pixel.burnt && pixel.burnt > pixel.char || !pixel.char) {
    pixel.char = pixel.burnt
}
if (!isEmpty(pixel.x, pixel.y-1, true)) {
    var hitPixel = pixelMap[pixel.x][pixel.y-1]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
}
if (!isEmpty(pixel.x, pixel.y+1, true)) {
    var hitPixel = pixelMap[pixel.x][pixel.y+1]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
}
if (!isEmpty(pixel.x-1, pixel.y, true)) {
    var hitPixel = pixelMap[pixel.x-1][pixel.y]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
}
if (!isEmpty(pixel.x+1, pixel.y, true)) {
    var hitPixel = pixelMap[pixel.x+1][pixel.y]
    if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
        if (hitPixel.oxygen < pixel.oxygen) {
            hitPixel.oxygen += (elements[pixel.element].oxygTrans)
            pixel.oxygen -= (elements[pixel.element].oxygTrans)
        }
        if (hitPixel.nutrition < pixel.nutrition) {
            hitPixel.nutrition += (elements[pixel.element].nutrTrans)
            pixel.nutrition -= (elements[pixel.element].nutrTrans)
        }
        if (hitPixel.speed < pixel.speed) {
            hitPixel.speed += 1
            pixel.speed -= 1
        }
        if (hitPixel.oxygen > pixel.oxygen) {
            hitPixel.oxygen -= (elements[hitPixel.element].oxygTrans)
            pixel.oxygen += (elements[hitPixel.element].oxygTrans)
        }
        if (hitPixel.nutrition > pixel.nutrition) {
            hitPixel.nutrition -= (elements[hitPixel.element].nutrTrans)
            pixel.nutrition += (elements[hitPixel.element].nutrTrans)
        }
        if (hitPixel.speed > pixel.speed) {
            hitPixel.speed -= 1
            pixel.speed += 1
        }
        if (hitPixel.alcoholic !== true && pixel.alcoholic === true && Math.random() > 0.85) {
            hitPixel.alcoholic = true
            hitPixel.alcoTime = pixel.alcoTime
            hitPixel.alcoDepri = 0
        }
        if (hitPixel.alcoDepri > pixel.alcoDepri && pixel.alcoDepri) {
            hitPixel.alcoDepri = pixel.alcoDepri
        }
        if (hitPixel.alcoTime < pixel.alcoTime && pixel.alcoTime) {
            hitPixel.alcoTime = pixel.alcoTime
        }
        if (hitPixel.alcoRecover !== true && pixel.alcoRecover) {
            hitPixel.alcoRecover = true
        }
        if ((hitPixel.fentDepri < pixel.fentDepri || !hitPixel.fentDepri) && pixel.fentDepri) {
            hitPixel.fentDepri = pixel.fentDepri
            hitPixel.fenAddict = true
        }
        if (hitPixel.sick != true && pixel.sick == true && Math.random() > 0.95) {
            hitPixel.sick = true
        }
        if (hitPixel.poisonImmune != true && pixel.poisonImmune == true && Math.random() > 0.75) {
            hitPixel.poisonImmune = true
        }
        if (hitPixel.poisoned != true && pixel.poisoned == true && Math.random() > 0.95) {
            hitPixel.poisoned = true
        }
        if (hitPixel.immune != true && pixel.immune == true && Math.random() > 0.75) {
            hitPixel.immune = true
        }
        if (hitPixel.ibupCount != 0 && hitPixel.ibup != true && pixel.ibup === true && Math.random() < 0.75) {
            hitPixel.ibup = true
            if (!hitPixel.ibupCount) {
                hitPixel.ibupCount = 1
            }
            else {
                hitPixel.ibupCount += 1
            }
            ibuprofenTime = pixelTicks
        }
        if (hitPixel.ibupCount < pixel.ibupCount && Math.random() > 0.995) {
            hitPixel.ibupCount += 1
        }
        if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burnt--
        }
        if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
            hitPixel.burning = false
        }
    }
}
}

elements.flesh = {
	color: ["#9e4839","#ba6449"],
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.epidermis = {
	color: "#f7ead0",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "dust",
    roomDie: "meat",
    coldDie: "dust",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if ((pixel.temp > 40 || pixel.temp < 10) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    if (pixel.temp > 40) {
                        pixel.temp -= 20;
                        createPixel("salt_water",x,y);
                        break;
                    }
                    pixel.temp += 20;
                    break;
                }
            }
        }
        if (pixel.temp < 36.5 && Math.random() < 0.1) {
            pixel.temp += 1;
        }
        else if (pixel.temp > 37 && Math.random() < 0.1) {
            pixel.temp -= 1;
        }
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 3,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat","dust","dust","dust","dust"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.dermis = {
	color: "#CFA08B",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("epidermis",x,y);
                    pixelMap[x][y].nutrition = (Math.round(pixel.nutrition / 2))
                    pixelMap[x][y].oxygen = (Math.round(pixel.oxygen / 2))
                    pixel.nutrition = (Math.round(pixel.nutrition / 2))
                    pixel.oxygen = (Math.round(pixel.oxygen / 2))
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 4,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.cloak_skin = {
	color: "#CFD4A5",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "dust",
    roomDie: "meat",
    coldDie: "dust",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if ((pixel.temp > 40 || pixel.temp < 10) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    if (pixel.temp > 40) {
                        pixel.temp -= 20;
                        createPixel("salt_water",x,y);
                        break;
                    }
                    pixel.temp += 20;
                    break;
                }
            }
        }
        if (pixel.temp < 36.5 && Math.random() < 0.1) {
            pixel.temp += 1;
        }
        else if (pixel.temp > 37 && Math.random() < 0.1) {
            pixel.temp -= 1;
        }
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 3,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat","dust","dust","dust","dust"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.cloak_dermis = {
	color: "#BC9F7B",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("cloak_skin",x,y);
                    pixelMap[x][y].nutrition = (Math.round(pixel.nutrition / 2))
                    pixelMap[x][y].oxygen = (Math.round(pixel.oxygen / 2))
                    pixel.nutrition = (Math.round(pixel.nutrition / 2))
                    pixel.oxygen = (Math.round(pixel.oxygen / 2))
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 4,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.loose_hair = {
    color: "#79554D",
    singleColor: true,
    behavior: behaviors.POWDER,
    category:"powders",
    tempHigh: 223,
    stateHigh: ["smoke","smoke","smoke","ash","ash","stench"],
    burn: 20,
    burnTime: 350,
    burnInto:["smoke","smoke","fire","ash","ash","stench"],
    breakInto: [null,null,null,null,"dust"],
    state: "solid",
    density: 935,
    hidden: true
}

elements.hair_end = {
    color: "#754a41",
	category: "structural",
    behavior: behaviors.WALL,
    tick: function(pixel) {
        if (pixel.dir === "up") {
            if (isEmpty(pixel.x,pixel.y+1)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x,pixel.y+1,true)) {
                if (elements[pixelMap[pixel.x][pixel.y+1].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (pixel.dir === "down") {
            if (isEmpty(pixel.x,pixel.y-1)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x,pixel.y-1,true)) {
                if (elements[pixelMap[pixel.x][pixel.y-1].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (pixel.dir === "left") {
            if (isEmpty(pixel.x+1,pixel.y)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x+1,pixel.y,true)) {
                if (elements[pixelMap[pixel.x+1][pixel.y].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (pixel.dir === "right") {
            if (isEmpty(pixel.x-1,pixel.y)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x-1,pixel.y,true)) {
                if (elements[pixelMap[pixel.x-1][pixel.y].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (!pixel.dir && pixel.age > 10) {
            changePixel(pixel,"loose_hair"); 
        }
        if (pixel.temp < 5 && Math.random() < 0.01) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    pixel.temp += 10;
                    break;
                }
            }
        }
        if (pixel.temp < 10 && Math.random() < 0.1) {
            pixel.temp += 1;
        }
        doDefaults(pixel);
        pixel.age++
    },
    properties: {
        age: 0,
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempLow: -25,
    stateLow: "loose_hair",
    tempHigh: 123,
    stateHigh: "loose_hair",
    burn:15,
    burnTime: 400,
    burnInto:"loose_hair",
    breakInto:"loose_hair",
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:null, chance:0.0005 },
        "radiation": { elem1:["ash","dust"], chance:0.2 },
	},
    isHair: true,
    movable: false,
    hidden: true,
}

elements.attached_hair = {
    color: "#754a41",
	category: "structural",
    behavior: behaviors.WALL,
    tick: function(pixel) {
        if (Math.random() < 0.001) {
            if (pixel.dir === "up") {
                if (isEmpty(pixel.x,pixel.y-1)) {
                    if (Math.random() > 0.25) {
                        createPixel("attached_hair",pixel.x,pixel.y-1)
                        pixelMap[pixel.x][pixel.y-1].dir = "up"
                    }
                    else {
                        createPixel("hair_end",pixel.x,pixel.y-1)
                        pixelMap[pixel.x][pixel.y-1].dir = "up"
                    }
                }
            }
            else if (pixel.dir === "down") {
                if (isEmpty(pixel.x,pixel.y+1)) {
                    if (Math.random() > 0.25) {
                        createPixel("attached_hair",pixel.x,pixel.y+1)
                        pixelMap[pixel.x][pixel.y+1].dir = "down"
                    }
                    else {
                        createPixel("hair_end",pixel.x,pixel.y+1)
                        pixelMap[pixel.x][pixel.y+1].dir = "down"
                    }
                }
            }
            else if (pixel.dir === "left") {
                if (isEmpty(pixel.x-1,pixel.y)) {
                    if (Math.random() > 0.25) {
                        createPixel("attached_hair",pixel.x-1,pixel.y)
                        pixelMap[pixel.x-1][pixel.y].dir = "left"
                    }
                    else {
                        createPixel("hair_end",pixel.x-1,pixel.y)
                        pixelMap[pixel.x-1][pixel.y].dir = "left"
                    }
                }
            }
            else if (pixel.dir === "right") {
                if (isEmpty(pixel.x+1,pixel.y)) {
                    if (Math.random() > 0.25) {
                        createPixel("attached_hair",pixel.x+1,pixel.y)
                        pixelMap[pixel.x+1][pixel.y].dir = "right"
                    }
                    else {
                        createPixel("hair_end",pixel.x+1,pixel.y)
                        pixelMap[pixel.x+1][pixel.y].dir = "right"
                    }
                }
            }
        }
        if (pixel.dir === "up") {
            if (isEmpty(pixel.x,pixel.y+1)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x,pixel.y+1,true)) {
                if (elements[pixelMap[pixel.x][pixel.y+1].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (pixel.dir === "down") {
            if (isEmpty(pixel.x,pixel.y-1)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x,pixel.y-1,true)) {
                if (elements[pixelMap[pixel.x][pixel.y-1].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (pixel.dir === "left") {
            if (isEmpty(pixel.x+1,pixel.y)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x+1,pixel.y,true)) {
                if (elements[pixelMap[pixel.x+1][pixel.y].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (pixel.dir === "right") {
            if (isEmpty(pixel.x-1,pixel.y)) {
                changePixel(pixel,"loose_hair"); 
            }
            else if (!isEmpty(pixel.x-1,pixel.y,true)) {
                if (elements[pixelMap[pixel.x-1][pixel.y].element].isHair != true) {
                    changePixel(pixel,"loose_hair"); 
                }
            }
        }
        else if (!pixel.dir && pixel.age > 10) {
            changePixel(pixel,"loose_hair"); 
        }
        if (pixel.temp < 5 && Math.random() < 0.01) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    pixel.temp += 10;
                    break;
                }
            }
        }
        if (pixel.temp < 10 && Math.random() < 0.1) {
            pixel.temp += 1;
        }
        doDefaults(pixel);
        pixel.age++
    },
    properties: {
        age: 0,
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempLow: -25,
    stateLow: "loose_hair",
    tempHigh: 123,
    stateHigh: "loose_hair",
    burn:15,
    burnTime: 400,
    burnInto:"loose_hair",
    breakInto:"loose_hair",
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:null, chance:0.0005 },
        "radiation": { elem1:["ash","dust"], chance:0.2 },
	},
    isHair: true,
    movable: false,
    hidden: true,
}

elements.hairy_skin = {
	color: "#ECDCC3",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "dust",
    roomDie: "meat",
    coldDie: "dust",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.01) {
                if (isEmpty(pixel.x,pixel.y-1)) {
                    createPixel("attached_hair",pixel.x,pixel.y-1)
                    pixelMap[pixel.x][pixel.y-1].dir = "up"
                }
                if (isEmpty(pixel.x,pixel.y+1)) {
                    createPixel("attached_hair",pixel.x,pixel.y+1)
                    pixelMap[pixel.x][pixel.y+1].dir = "down"
                }

                if (isEmpty(pixel.x-1,pixel.y)) {
                    createPixel("attached_hair",pixel.x-1,pixel.y)
                    pixelMap[pixel.x-1][pixel.y].dir = "left"
                }

                if (isEmpty(pixel.x+1,pixel.y)) {
                    createPixel("attached_hair",pixel.x+1,pixel.y)
                    pixelMap[pixel.x+1][pixel.y].dir = "right"
                }

        }
        if ((pixel.temp > 40 || pixel.temp < 10) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    if (pixel.temp > 40) {
                        pixel.temp -= 20;
                        createPixel("salt_water",x,y);
                        break;
                    }
                    pixel.temp += 20;
                    break;
                }
            }
        }
        if (pixel.temp < 36.5 && Math.random() < 0.1) {
            pixel.temp += 1;
        }
        else if (pixel.temp > 37 && Math.random() < 0.1) {
            pixel.temp -= 1;
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 375,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat","dust","dust","dust","dust"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isHair: true,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.hair_dermis = {
	color: "#C89985",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    if (Math.random() > 0.05) {
                        createPixel("hairy_skin",x,y);
                        pixelMap[x][y].nutrition = (Math.round(pixel.nutrition / 2))
                        pixelMap[x][y].oxygen = (Math.round(pixel.oxygen / 2))
                        pixel.nutrition = (Math.round(pixel.nutrition / 2))
                        pixel.oxygen = (Math.round(pixel.oxygen / 2))
                    }
                    else {
                        createPixel("epidermis",x,y);
                        pixelMap[x][y].nutrition = (Math.round(pixel.nutrition / 2))
                        pixelMap[x][y].oxygen = (Math.round(pixel.oxygen / 2))
                        pixel.nutrition = (Math.round(pixel.nutrition / 2))
                        pixel.oxygen = (Math.round(pixel.oxygen / 2))
                    }
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 360,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isHair: true,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.scales = {
	color: "#6b839a",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: false,
    normDie: "dust",
    otherDie: "calcium",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (pixel.temp > 40 && Math.random() < 0.1) {
            pixel.temp -= 1;
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 210,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.000075 },
        "radiation": { elem1:["calcium","calcium","ash","meat","rotten_meat","cooked_meat","skin","epidermis"], chance:0.1 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.scale_dermis = {
	color: "#CFA08B",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("scales",x,y);
                        pixelMap[x][y].nutrition = (Math.round(pixel.nutrition / 2))
                        pixelMap[x][y].oxygen = (Math.round(pixel.oxygen / 2))
                        pixel.nutrition = (Math.round(pixel.nutrition / 2))
                        pixel.oxygen = (Math.round(pixel.oxygen / 2))
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.bug_dermis = {
	color: "#C6AD5B",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("exoskeleton",x,y);
                        pixelMap[x][y].nutrition = (Math.round(pixel.nutrition / 2))
                        pixelMap[x][y].oxygen = (Math.round(pixel.oxygen / 2))
                        pixel.nutrition = (Math.round(pixel.nutrition / 2))
                        pixel.oxygen = (Math.round(pixel.oxygen / 2))
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.amphib_dermis = {
	color: "#9DAB6A",
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("amphib_skin",x,y);
                    pixelMap[x][y].nutrition = (Math.round(pixel.nutrition - ((pixel.nutrition / 4) * 3)))
                    pixelMap[x][y].oxygen = (Math.round(pixel.oxygen - ((pixel.oxygen / 4) * 3)))
                    pixel.nutrition = (Math.round(pixel.nutrition - (pixel.nutrition / 4)))
                    pixel.oxygen = (Math.round(pixel.oxygen - (pixel.oxygen / 4)))
                }
            }
        }
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat","meat","slime","slime"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","slime","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.acidic_flesh = {
	color: ["#946231","#976E30"],
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "acid",
    coldDie: "acid",
    heatDie: "acid",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: ["acid_gas","cooked_meat","cooked_meat","cooked_meat"],
    tempLow: -25,
    stateLow: ["frozen_meat","acid","acid"],
    burn: 5,
    burnTime: 350,
    burnInto: ["acid_gas","cooked_meat","cooked_meat"],
    breakInto: ["acid","acid","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","acid","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.slimey_flesh = {
	color: ["#8EA714","#96B013"],
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "slime",
    coldDie: "slime",
    heatDie: "slime",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: ["slime","cooked_meat","cooked_meat","cooked_meat"],
    tempLow: -25,
    stateLow: ["frozen_meat","slime_ice","slime_ice"],
    burn: 5,
    burnTime: 350,
    burnInto: ["slime","cooked_meat","cooked_meat"],
    breakInto: ["slime","slime","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","slime","slime","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.cloak_flesh = {
	color: ["#879720","#8C9D1F"],
    grain: 0,
	category: "structural",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].movable) {
                if (pixel.color != hitPixel.color) {
                    pixel.color = hitPixel.color
                }
            }
            if (elements[hitPixel.element].isBio) {
                if (pixel.color != hitPixel.color) {
                    hitPixel.color = pixel.color
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 4,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.adipose = {
	color: ["#C3A375","#B9945A"],
	category: "nutrition",
    behavior: behaviors.WALL,
    nutrTrans: 10,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "grease",
    coldDie: "fat",
    heatDie: "grease",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .03,
    tempHigh: 200,
    stateHigh: ["fat","fat","fat","cooked_meat"],
    tempLow: -25,
    stateLow: ["fat","frozen_meat"],
    burn: 10,
    burnTime: 300,
    burnInto: ["fat","fat","fat","cooked_meat"],
    breakInto: ["fat","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","fat","fat","fat","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1005,
    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.acid_vessel = {
    color: "#BF6B0E",
    behavior: [
        "XX|SW:acid_vessel%1|XX",
        "SW:acid_vessel%1|XX|SW:acid_vessel%1",
        "XX|SW:acid_vessel%1|XX",
    ],
    bleed: "acid",
    nutrTrans: 30,
    oxygTrans: 35,
    isMultiDie: false,
    normDie: "acid",
    otherDie: "acid",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioBlood(pixel);
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    tempHigh: 175,
    stateHigh: ["acid_gas","acid_gas","acid_gas","cooked_meat","cooked_meat"],
    tempLow: -50,
    stateLow: "frozen_meat",
    burn: 20,
    burnTime: 160,
    burnInto: ["acid_gas","acid_gas","acid_gas","acid_gas","cooked_meat"],
    breakInto: "acid",
    category: "circulation",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
}

elements.heart = {
    color: ["#98002e","#532e63","#6f1200","#551900"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    nutrTrans: 40,
    oxygTrans: 45,
    isMultiDie: true,
    normDie: "blood",
    roomDie: "meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.5) {
                hitPixel.heartAttached = true
            }
        }
        else if (isEmpty(pixel.x, pixel.y-1) && Math.random() > 0.75) {
            if (Math.random() > 0.95) {
                createPixel("blood",pixel.x,pixel.y-1)
            }
            pixel.oxygen -= 50
            pixel.nutrition -= 50
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.5) {
                hitPixel.heartAttached = true
            }
        }
        else if (isEmpty(pixel.x, pixel.y+1) && Math.random() > 0.75) {
            if (Math.random() > 0.95) {
                createPixel("blood",pixel.x,pixel.y+1)
            }
            pixel.oxygen -= 50
            pixel.nutrition -= 50
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.5) {
                hitPixel.heartAttached = true
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && Math.random() > 0.75) {
            if (Math.random() > 0.95) {
                createPixel("blood",pixel.x-1,pixel.y)
            }
            pixel.oxygen -= 50
            pixel.nutrition -= 50
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.5) {
                hitPixel.heartAttached = true
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && Math.random() > 0.75) {
            if (Math.random() > 0.95) {
                createPixel("blood",pixel.x+1,pixel.y)
            }
            pixel.oxygen -= 50
            pixel.nutrition -= 50
        }
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
    },
    tempHigh: 175,
    stateHigh: "meat",
    tempLow: -50,
    stateLow: "frozen_meat",
    burn: 20,
    burnTime: 160,
    burnInto: "meat",
    breakInto: ["meat","blood","blood",],
    category: "circulation",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
}

elements.kidney = {
    color: ["#AB1354","#89212E","#74272E"],
    behavior: behaviors.WALL,
    nutrTrans: 40,
    oxygTrans: 45,
    isMultiDie: true,
    normDie: "urine",
    roomDie: "meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBlood === true && Math.random() < 0.025 && (hitPixel.speed < 1 || Math.random() < 0.00025) && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                hitPixel.speed++
                pixel.pee += 1
            }
            if (hitPixel.pee < pixel.pee && elements[hitPixel.element].isKidney === true) {
                hitPixel.pee += 1
                pixel.pee -= 1
            }
        }
        else if (pixel.pee > 4 && Math.random() > 0.95) {
            if (Math.random() > 0.8) {
                createPixel("urine",pixel.x,pixel.y-1)
            }
            pixel.pee -= 5
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBlood === true && Math.random() < 0.025 && (hitPixel.speed < 1 || Math.random() < 0.00025) && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                hitPixel.speed++
                pixel.pee += 1
            }
            if (hitPixel.pee < pixel.pee && elements[hitPixel.element].isKidney === true) {
                hitPixel.pee += 1
                pixel.pee -= 1
            }
        }
        else if (pixel.pee > 4 && Math.random() > 0.95) {
            if (Math.random() > 0.8) {
                createPixel("urine",pixel.x,pixel.y+1)
            }
            pixel.pee -= 5
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBlood === true && Math.random() < 0.025 && (hitPixel.speed < 1 || Math.random() < 0.00025) && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                hitPixel.speed++
                pixel.pee += 1
            }
            if (hitPixel.pee < pixel.pee && elements[hitPixel.element].isKidney === true) {
                hitPixel.pee += 1
                pixel.pee -= 1
            }
        }
        else if (pixel.pee > 4 && Math.random() > 0.95) {
            if (Math.random() > 0.8) {
                createPixel("urine",pixel.x-1,pixel.y)
            }
            pixel.pee -= 5
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBlood === true && Math.random() < 0.025 && (hitPixel.speed < 1 || Math.random() < 0.00025) && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                hitPixel.speed++
                pixel.pee += 1
            }
            if (hitPixel.pee < pixel.pee && elements[hitPixel.element].isKidney === true) {
                hitPixel.pee += 1
                pixel.pee -= 1
            }
        }
        else if (pixel.pee > 4 && Math.random() > 0.95) {
            if (Math.random() > 0.8) {
                createPixel("urine",pixel.x+1,pixel.y)
            }
            pixel.pee -= 5
        }
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
        pee: 0,
    },
    renderer: function(pixel,ctx) {
        drawDefault(ctx,pixel);
        if (!viewInfo[view].colorEffects) { return }
        if (pixel.pee > 0) {
            drawSquare(ctx,"#E9BE3C",pixel.x,pixel.y,undefined,Math.min(0.8,pixel.pee/10));
        }
        if (!viewInfo[view].colorEffects || !pixel.char || pixel.char < 11) { return }
        var max = 25;
        var ratio = ((pixel.char/max*100)|0)/100;
        if (ratio < 0.5) { return }
        if (ratio > 1) { ratio = 1 }
        drawSquare(ctx,"#000000",pixel.x,pixel.y,undefined,Math.min(0.8,(ratio-0.5)*0.8));
    },
    tempHigh: 175,
    stateHigh: "meat",
    tempLow: -50,
    stateLow: "frozen_meat",
    burn: 20,
    burnTime: 160,
    burnInto: "meat",
    breakInto: ["meat","urine","blood"],
    category: "circulation",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    isBio: true,
    isKidney: true,
}

elements.liver = {
    color: ["#6c2e1f","#7B2827","#702B27"],
    behavior: behaviors.WALL,
    nutrTrans: 40,
    oxygTrans: 45,
    isMultiDie: true,
    normDie: "rotten_meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        if (pixel.speed < -1 && Math.random() < (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            pixel.speed += 1
        }
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
    },
    tempHigh: 175,
    stateHigh: "meat",
    tempLow: -50,
    stateLow: "frozen_meat",
    burn: 20,
    burnTime: 160,
    burnInto: "meat",
    breakInto: ["meat","rotten_meat","blood",],
    category: "nutrition",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
}

elements.blood_vessel = {
    color: "#c72114",
    behavior: [
        "SW:blood_vessel%1|SW:blood_vessel%5|SW:blood_vessel%1",
        "SW:blood_vessel%5|XX|SW:blood_vessel%5",
        "SW:blood_vessel%1|SW:blood_vessel%5|SW:blood_vessel%1",
    ],
    ageRate: 0.975,
    nutrTrans: 30,
    oxygTrans: 35,
    isMultiDie: true,
    bleed: "blood",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioBlood(pixel);
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
        heartAttached: false,
    },
    reactions: {
        "dirt": { elem2: "infected_vessel", chance:0.005 },
        "dust": { elem1: null, elem2: "infected_vessel", chance:0.005 },
        "ash": { elem1: null, elem2: "infected_vessel", chance:0.005 },
        "mud": { elem2: "infected_vessel", chance:0.005 },
        "sand": { elem2: "infected_vessel", chance:0.005 },
        "gravel": { elem2: "infected_vessel", chance:0.005 },
        "brick_rubble": { elem2: "infected_vessel", chance:0.005 },
        "glitter": { elem1: null, elem2: "infected_vessel", chance:0.001 },
        "sulfur": { elem2: "infected_vessel", chance:0.005 },
        "rust": { elem1: ["meat","infected_vessel","infected_vessel","infected_vessel","blood","blood"], chance:0.005 },
        "mercury": { elem2: null, elem1: "infected_vessel", func:function(pixel1,pixel2){ if (pixel1.poisoned != true) {
            pixel1.poisoned = true;
        } }, chance:0.005 },
        "vaccine": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.immune != true) {
            pixel1.immune = true;
        } }, chance:0.01 },
        "antibody": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.immune != true) {
            pixel1.immune = true;
        } }, chance:0.0025 },
        "antidote": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.poisonImmune != true) {
            pixel1.poisonImmune = true;
        } }, chance:0.02 },
        "poison": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.poisoned != true) {
            pixel1.poisoned = true;
        } }, chance:0.02 },
        "cyanide": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.poisoned != true) {
            pixel1.poisoned = true;
        } }, chance:0.01 },
    },
    tempHigh: 175,
    stateHigh: ["meat","blood","blood"],
    tempLow: -50,
    stateLow: ["frozen_meat","blood","blood","blood"],
    burn: 20,
    burnTime: 160,
    burnInto: ["meat","blood","blood","blood","blood","blood","blood","steam"],
    breakInto: ["meat","blood","blood","blood","blood","blood","blood","blood"],
    category: "circulation",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    extinguish: true,
    isBio: true,
    isBlood: true,
}

elements.infected_vessel = {
    color: "#BF0347",
    behavior: [
        "XX|SW:blood_vessel%1 AND CH:blood_vessel,white_blood_cell>infected_vessel%1|XX",
        "SW:blood_vessel%1 AND CH:blood_vessel,white_blood_cell>infected_vessel%1|XX|SW:blood_vessel%1 AND CH:blood_vessel,white_blood_cell>infected_vessel%1",
        "XX|SW:blood_vessel%2 AND CH:blood_vessel,white_blood_cell>infected_vessel%1|XX",
    ],
    ageRate: 0.5,
    nutrTrans: 10,
    oxygTrans: 15,
    isMultiDie: true,
    bleed: "infection",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioBlood(pixel);
        if (Math.random() > 0.995 && pixel.sick != true) {
            pixel.sick = true
        }
        if (Math.random() > 0.95 && pixel.immune === true) {
            pixel.element = "blood_vessel"
            pixel.color = elements.blood_vessel.color
        }
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
        heartAttached: false,
    },
    reactions: {
		"bless": { elem1:"blood_vessel"  },
	},
    tempHigh: 175,
    stateHigh: ["meat","infection","infection"],
    tempLow: -50,
    stateLow: ["frozen_meat","infection","infection"],
    burn: 20,
    burnTime: 160,
    burnInto: ["meat","infection","infection"],
    breakInto: "infection",
    category: "circulation",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    extinguish: true,
    isBio: true,
    isBlood: true,
}

elements.white_blood_cell = {
    color: "#F5D7D4",
    behavior: [
        "XX|SW:blood_vessel,white_blood_cell%5|XX",
        "SW:blood_vessel,white_blood_cell%5|XX|SW:blood_vessel,white_blood_cell%5",
        "XX|SW:blood_vessel,white_blood_cell%5|XX",
    ],
    ageRate: 0.995,
    nutrTrans: 35,
    oxygTrans: 40,
    isMultiDie: true,
    bleed: "blood",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioBlood(pixel);
        doDefaults(pixel);
        if (Math.random() > 0.995 && Math.random() < (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) || Math.random() > 0.9995) {
            pixel.element = "blood_vessel"
            pixel.color = elements.blood_vessel.color
        }
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.25) {
                if (elements[hitPixel.element].id === elements.infected_vessel.id) {
                    hitPixel.element = "blood_vessel"
                    hitPixel.color = elements.blood_vessel.color
                }
                if (hitPixel.sick === true && (Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) || Math.random() > 0.995)) {
                    hitPixel.sick = false
                    if (Math.random() > 0.995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                        pixel.immune = true
                    }
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.25) {
                if (elements[hitPixel.element].id === elements.infected_vessel.id) {
                    hitPixel.element = "blood_vessel"
                    hitPixel.color = elements.blood_vessel.color
                }
            }
            if (hitPixel.sick === true && (Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) || Math.random() > 0.995)) {
                hitPixel.sick = false
                if (Math.random() > 0.995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                    pixel.immune = true
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.25) {
                if (elements[hitPixel.element].id === elements.infected_vessel.id) {
                    hitPixel.element = "blood_vessel"
                    hitPixel.color = elements.blood_vessel.color
                }
            }
            if (hitPixel.sick === true && (Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) || Math.random() > 0.995)) {
                hitPixel.sick = false
                if (Math.random() > 0.995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                    pixel.immune = true
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBlood === true && Math.random() > 0.25) {
                if (elements[hitPixel.element].id === elements.infected_vessel.id) {
                    hitPixel.element = "blood_vessel"
                    hitPixel.color = elements.blood_vessel.color
                }
            }
            if (hitPixel.sick === true && (Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) || Math.random() > 0.995)) {
                hitPixel.sick = false
                if (Math.random() > 0.995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                    pixel.immune = true
                }
            }
        }
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
        heartAttached: false,
    },
    reactions: {
            "rust": { elem1: ["meat","infected_vessel","infected_vessel","infected_vessel","blood","blood"], chance:0.005 },
            "mercury": { elem2: null, elem1: "infected_vessel", func:function(pixel1,pixel2){ if (pixel1.poisoned != true) {
                pixel1.poisoned = true;
            } }, chance:0.005 },
            "vaccine": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.immune != true) {
                pixel1.immune = true;
            } }, chance:0.01 },
            "antibody": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.immune != true) {
                pixel1.immune = true;
            } }, chance:0.0025 },
            "antidote": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.poisonImmune != true) {
                pixel1.poisonImmune = true;
            } }, chance:0.02 },
            "poison": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.poisoned != true) {
                pixel1.poisoned = true;
            } }, chance:0.02 },
            "cyanide": { elem2: null, func:function(pixel1,pixel2){ if (pixel1.poisoned != true) {
                pixel1.poisoned = true;
            } }, chance:0.01 },
            "blood": { elem2:"blood_vessel", chance:0.10  },
	},
    tempHigh: 175,
    stateHigh: ["meat","blood","blood","blood"],
    tempLow: -50,
    stateLow: "frozen_meat",
    burn: 20,
    burnTime: 160,
    burnInto: ["meat","blood","blood","blood"],
    breakInto: "blood",
    category: "circulation",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    extinguish: true,
    isBio: true,
    isBlood: true,
}

elements.eye = {
	color: "#451800",
	category: "nervous system",
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: false,
    normDie: "meat",
    otherDie: "salt_water",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doHeat(pixel);
		doBurning(pixel);
		doElectricity(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.light.id) {
                pixel.saw = true
            }
            else if (pixel.saw === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.saw = false
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.light.id && Math.random() > 0.5) {
                pixel.saw = true
            }
            else if (pixel.saw === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.saw = false
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.light.id && Math.random() > 0.5) {
                pixel.saw = true
            }
            else if (pixel.saw === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.saw = false
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.light.id && Math.random() > 0.5) {
                pixel.saw = true
            }
            else if (pixel.saw === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.saw = false
            }
        }
        if (pixel.saw === true && Math.random() > 0.8) {
            pixel.saw = false
        }
    },
    density: 2710,
    state: "solid",
    tempHigh: 200,
    stateHigh: ["cooked_meat","salt_water","blood"],
    tempLow: -25,
    stateLow: ["salt_water","cerebrospinal_fluid","salt_water","blood","frozen_meat"],
    burn: 5,
    burnTime: 350,
    conduct: .001,
    burnInto: ["cooked_meat","salt_water","blood"],
    breakInto: ["blood","blood","blood","blood","cerebrospinal_fluid","cerebrospinal_fluid","salt_water","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        saw: false,
    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.olfactory_bulb = {
	color: "#8A7650",
	category: "nervous system",
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: false,
    normDie: "meat",
    otherDie: "rotten_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doHeat(pixel);
		doBurning(pixel);
		doElectricity(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            doElectricity(hitPixel);
            if ((elements[hitPixel.element].id === elements.smoke.id || elements[hitPixel.element].id === elements.stench.id || elements[hitPixel.element].id === elements.fragrance.id || elements[hitPixel.element].id === elements.methane.id || elements[hitPixel.element].id === elements.ammonia.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 50
                pixel.nutrition -= 50
            }
            else if (pixel.smell === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.smell = false
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            doElectricity(hitPixel);
            if ((elements[hitPixel.element].id === elements.smoke.id || elements[hitPixel.element].id === elements.stench.id || elements[hitPixel.element].id === elements.fragrance.id || elements[hitPixel.element].id === elements.methane.id || elements[hitPixel.element].id === elements.ammonia.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 50
                pixel.nutrition -= 50
            }
            else if (pixel.smell === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.smell = false
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            doElectricity(hitPixel);
            if ((elements[hitPixel.element].id === elements.smoke.id || elements[hitPixel.element].id === elements.stench.id || elements[hitPixel.element].id === elements.fragrance.id || elements[hitPixel.element].id === elements.methane.id || elements[hitPixel.element].id === elements.ammonia.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 50
                pixel.nutrition -= 50
            }
            else if (pixel.smell === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.smell = false
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            doElectricity(hitPixel);
            if ((elements[hitPixel.element].id === elements.smoke.id || elements[hitPixel.element].id === elements.stench.id || elements[hitPixel.element].id === elements.fragrance.id || elements[hitPixel.element].id === elements.methane.id || elements[hitPixel.element].id === elements.ammonia.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                pixel.smell = true
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 50
                pixel.nutrition -= 50
            }
            else if (pixel.smell === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.smell = false
            }
        }
        if (pixel.smell === true && Math.random() > 0.8) {
            pixel.smell = false
        }
    },
    density: 2710,
    state: "solid",
    tempHigh: 200,
    stateHigh: ["cooked_meat","slime","blood"],
    tempLow: -25,
    stateLow: ["slime","slime","blood","frozen_meat"],
    burn: 5,
    burnTime: 350,
    conduct: .001,
    burnInto: ["cooked_meat","slime","blood"],
    breakInto: ["blood","blood","meat","meat","slime","slime","slime","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","slime","ash","slime","slime","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        smell: false,
    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.taste_bud = {
	color: "#DB6767",
	category: "nervous system",
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: false,
    normDie: "meat",
    otherDie: "rotten_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doHeat(pixel);
		doBurning(pixel);
		doElectricity(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            doElectricity(hitPixel);
            if ((
                elements[hitPixel.element].id === elements.sugar.id || elements[hitPixel.element].id === elements.salt.id || elements[hitPixel.element].id === elements.grease.id || elements[hitPixel.element].id === elements.cooked_meat.id || elements[hitPixel.element].id === elements.chocolate.id || elements[hitPixel.element].id === elements.chocolate_powder.id || elements[hitPixel.element].id === elements.cheese.id || elements[hitPixel.element].id === elements.cheese_powder.id || elements[hitPixel.element].id === elements.pickle.id || elements[hitPixel.element].id === elements.herb.id || elements[hitPixel.element].id === elements.juice.id || elements[hitPixel.element].id === elements.gingerbread.id || elements[hitPixel.element].id === elements.ketchup.id || elements[hitPixel.element].id === elements.mayo.id || elements[hitPixel.element].id === elements.sauce.id || elements[hitPixel.element].id === elements.chocolate_milk.id || elements[hitPixel.element].id === elements.grape.id  || elements[hitPixel.element].id === elements.pilk.id || elements[hitPixel.element].id === elements.fruit_milk.id || elements[hitPixel.element].id === elements.nut_milk.id || elements[hitPixel.element].id === elements.soda.id || elements[hitPixel.element].id === elements.sugar_water.id
            ) && Math.random() > 0.5 && hitPixel.tasted != true) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                hitPixel.tasted = false
                }
            }
            else if ((elements[hitPixel.element].id === elements.alcohol.id || elements[hitPixel.element].id === elements.rotten_cheese.id || elements[hitPixel.element].id === elements.rotten_meat.id || elements[hitPixel.element].id === elements.pool_water.id || elements[hitPixel.element].id === elements.poison.id || elements[hitPixel.element].id === elements.bleach.id || elements[hitPixel.element].id === elements.cyanide.id || elements[hitPixel.element].id === elements.infection.id) && Math.random() > 0.5) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                    hitPixel.tasted = false
                }
                pixel.oxygen--
                pixel.nutrition--
            }
            else if (pixel.tasted === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.tasted = false
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            doElectricity(hitPixel);
            if ((
                elements[hitPixel.element].id === elements.sugar.id || elements[hitPixel.element].id === elements.salt.id || elements[hitPixel.element].id === elements.grease.id || elements[hitPixel.element].id === elements.cooked_meat.id || elements[hitPixel.element].id === elements.chocolate.id || elements[hitPixel.element].id === elements.chocolate_powder.id || elements[hitPixel.element].id === elements.cheese.id || elements[hitPixel.element].id === elements.cheese_powder.id || elements[hitPixel.element].id === elements.pickle.id || elements[hitPixel.element].id === elements.herb.id || elements[hitPixel.element].id === elements.juice.id || elements[hitPixel.element].id === elements.gingerbread.id || elements[hitPixel.element].id === elements.ketchup.id || elements[hitPixel.element].id === elements.mayo.id || elements[hitPixel.element].id === elements.sauce.id || elements[hitPixel.element].id === elements.chocolate_milk.id || elements[hitPixel.element].id === elements.grape.id  || elements[hitPixel.element].id === elements.pilk.id || elements[hitPixel.element].id === elements.fruit_milk.id || elements[hitPixel.element].id === elements.nut_milk.id || elements[hitPixel.element].id === elements.soda.id || elements[hitPixel.element].id === elements.sugar_water.id
            ) && Math.random() > 0.5 && hitPixel.tasted != true) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                hitPixel.tasted = false
                }
            }
            else if ((elements[hitPixel.element].id === elements.alcohol.id || elements[hitPixel.element].id === elements.rotten_cheese.id || elements[hitPixel.element].id === elements.rotten_meat.id || elements[hitPixel.element].id === elements.pool_water.id || elements[hitPixel.element].id === elements.poison.id || elements[hitPixel.element].id === elements.bleach.id || elements[hitPixel.element].id === elements.cyanide.id || elements[hitPixel.element].id === elements.infection.id) && Math.random() > 0.5) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                    hitPixel.tasted = false
                }
                pixel.oxygen--
                pixel.nutrition--
            }
            else if (pixel.tasted === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.tasted = false
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            doElectricity(hitPixel);
            if ((
                elements[hitPixel.element].id === elements.sugar.id || elements[hitPixel.element].id === elements.salt.id || elements[hitPixel.element].id === elements.grease.id || elements[hitPixel.element].id === elements.cooked_meat.id || elements[hitPixel.element].id === elements.chocolate.id || elements[hitPixel.element].id === elements.chocolate_powder.id || elements[hitPixel.element].id === elements.cheese.id || elements[hitPixel.element].id === elements.cheese_powder.id || elements[hitPixel.element].id === elements.pickle.id || elements[hitPixel.element].id === elements.herb.id || elements[hitPixel.element].id === elements.juice.id || elements[hitPixel.element].id === elements.gingerbread.id || elements[hitPixel.element].id === elements.ketchup.id || elements[hitPixel.element].id === elements.mayo.id || elements[hitPixel.element].id === elements.sauce.id || elements[hitPixel.element].id === elements.chocolate_milk.id || elements[hitPixel.element].id === elements.grape.id  || elements[hitPixel.element].id === elements.pilk.id || elements[hitPixel.element].id === elements.fruit_milk.id || elements[hitPixel.element].id === elements.nut_milk.id || elements[hitPixel.element].id === elements.soda.id || elements[hitPixel.element].id === elements.sugar_water.id
            ) && Math.random() > 0.5 && hitPixel.tasted != true) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                hitPixel.tasted = false
                }
            }
            else if ((elements[hitPixel.element].id === elements.alcohol.id || elements[hitPixel.element].id === elements.rotten_cheese.id || elements[hitPixel.element].id === elements.rotten_meat.id || elements[hitPixel.element].id === elements.pool_water.id || elements[hitPixel.element].id === elements.poison.id || elements[hitPixel.element].id === elements.bleach.id || elements[hitPixel.element].id === elements.cyanide.id || elements[hitPixel.element].id === elements.infection.id) && Math.random() > 0.5) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                    hitPixel.tasted = false
                }
                pixel.oxygen--
                pixel.nutrition--
            }
            else if (pixel.tasted === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.tasted = false
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            doElectricity(hitPixel);
            if ((
                elements[hitPixel.element].id === elements.sugar.id || elements[hitPixel.element].id === elements.salt.id || elements[hitPixel.element].id === elements.grease.id || elements[hitPixel.element].id === elements.cooked_meat.id || elements[hitPixel.element].id === elements.chocolate.id || elements[hitPixel.element].id === elements.chocolate_powder.id || elements[hitPixel.element].id === elements.cheese.id || elements[hitPixel.element].id === elements.cheese_powder.id || elements[hitPixel.element].id === elements.pickle.id || elements[hitPixel.element].id === elements.herb.id || elements[hitPixel.element].id === elements.juice.id || elements[hitPixel.element].id === elements.gingerbread.id || elements[hitPixel.element].id === elements.ketchup.id || elements[hitPixel.element].id === elements.mayo.id || elements[hitPixel.element].id === elements.sauce.id || elements[hitPixel.element].id === elements.chocolate_milk.id || elements[hitPixel.element].id === elements.grape.id  || elements[hitPixel.element].id === elements.pilk.id || elements[hitPixel.element].id === elements.fruit_milk.id || elements[hitPixel.element].id === elements.nut_milk.id || elements[hitPixel.element].id === elements.soda.id || elements[hitPixel.element].id === elements.sugar_water.id
            ) && Math.random() > 0.5 && hitPixel.tasted != true) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                hitPixel.tasted = false
                }
            }
            else if ((elements[hitPixel.element].id === elements.alcohol.id || elements[hitPixel.element].id === elements.rotten_cheese.id || elements[hitPixel.element].id === elements.rotten_meat.id || elements[hitPixel.element].id === elements.pool_water.id || elements[hitPixel.element].id === elements.poison.id || elements[hitPixel.element].id === elements.bleach.id || elements[hitPixel.element].id === elements.cyanide.id || elements[hitPixel.element].id === elements.infection.id) && Math.random() > 0.5) {
                pixel.tasted = true
                if (Math.random() > 0.5) {
                    hitPixel.tasted = false
                }
                pixel.oxygen--
                pixel.nutrition--
            }
            else if (pixel.tasted === true && elements[hitPixel.element].id === elements.nerve.id && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
                if (!hitPixel.charge) {
                    hitPixel.charge = 0.1
                }
                else if (hitPixel.charge) {
                    hitPixel.charge += 0.1
                }
                pixel.tasted = false
            }
        }
        if (pixel.tasted === true && Math.random() > 0.8) {
            pixel.tasted = false
        }
    },
    density: 2710,
    state: "solid",
    tempHigh: 200,
    stateHigh: ["cooked_meat","meat","blood"],
    tempLow: -25,
    stateLow: ["meat","blood","blood","frozen_meat"],
    burn: 5,
    burnTime: 350,
    conduct: .001,
    burnInto: ["cooked_meat","meat","blood"],
    breakInto: ["blood","blood","meat","meat","meat","meat","blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        taste: false,
    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.brain = {
	color: ["#fce3e3","#deb6c5","#f5ced5","#e87b8f"],
	category: "nervous system",
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && pixel.feel == true && Math.random() > 0.75) { //  electrical signals do this 01101001001000000110011001100101011001010110110000101110001000000110100100100000011000010110110100100000011000010110110001101001011101100110010100101110001000000110100001100101011011000111000000100000011011010110010100101110
                if (!pixel.stage || pixel.stage > 224) {
                    pixel.stage = 1
                }
                else if (pixel.stage) {
                    pixel.stage += 0.25
                }
                pixel.digitToCheck = (Math.floor(pixel.stage))
                pixel.number = "01101001001000000110011001100101011001010110110000101110001000000110100100100000011000010110110100100000011000010110110001101001011101100110010100101110001000000110100001100101011011000111000000100000011011010110010100101110"
                pixel.sentientCheck = pixel.number.toString()[pixel.digitToCheck] === "1"
                if (pixel.sentientCheck === true /* (pixel.stage === 1 || pixel.stage === 2 || pixel.stage === 4 || pixel.stage === 7 || pixel.stage === 10 || pixel.stage === 17 || pixel.stage === 18 || pixel.stage === 21 || pixel.stage === 22 || pixel.stage === 25 || pixel.stage === 26 || pixel.stage === 29 || pixel.stage === 31 || pixel.stage === 33 || pixel.stage === 34 || pixel.stage === 37 || pixel.stage === 39 || pixel.stage === 41 || pixel.stage === 42 || pixel.stage === 44 || pixel.stage === 45 || pixel.stage === 50 || pixel.stage === 52 || pixel.stage === 53 || pixel.stage === 54) */ ) {
                    hitPixel.lightcharge = true 
                }
                if (pixel.sentientCheck !== true) {
                    hitPixel.darkcharge = true                
                }
            }
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (pixel.charge) { 
            pixel.charge = 0;
            pixel.chargeCD = 16; 
        }
    },
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
}

elements.amygdala = {
	color: ["#B33E93","#B33E93","#f5ced5","#e87b8f"],
	category: "nervous system",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.brain.id && Math.random() > 0.75 && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.brain.id && Math.random() > 0.75 && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.brain.id && Math.random() > 0.75 && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].id === elements.brain.id && Math.random() > 0.75 && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (pixel.charge) { 
            pixel.charge = 0;
            pixel.chargeCD = 16; 
        }
    },
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    hidde: true,
    desc: "Makes brains sentient. Don't question it."
}

elements.hypothalamus = { 
	color: ["#B33E93","#B33E93","#f5ced5","#e87b8f"],
	category: "nervous system",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (pixel.temp > 42) { pixel.temp -= 5; }
        else if (pixel.temp < 32) { pixel.temp += 5; }
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            doElectricity(hitPixel);
            if (elements[hitPixel.element].id === elements.nerve.id && Math.random() > 0.75 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed - pixel.alcoDepri) / 2050))) {
                pixel.chargeCD = 16
                hitPixel.charge = 0.5
            }
            if ((elements[hitPixel.element].id === elements.brain.id || elements[hitPixel.element].id === elements.hypothalamus.id) && Math.random() > 0.75 && pixel.feel === true && hitPixel.feel != true) {
                hitPixel.feel = true
            }
        }
        if (pixel.charge) { 
            pixel.charge = 0;
            pixel.chargeCD = 16; 
        }
    },
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Regulates brain temperature."
}

elements.nerve = {
	color: "#B33E93",
	category: "nervous system",
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    conduct: 1,
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.nerve.id && pixel.darkcharge === true && pixel.darkchargeCD !== true) {
                pixel.darkcharge = false
                pixel.darkchargeCD = true
                hitPixel.darkcharge = true
                pixel.darktransmit = true
            }
        }
        if (isEmpty(pixel.x, pixel.y+1) || elements[pixelMap[pixel.x][pixel.y+1].element].id != elements.nerve.id) {
            if (pixel.darkcharge === true) {
                pixel.darkcharge = false
                pixel.darkchargeCD = true
            }
        }
        if (pixel.darkchargeCD === true && pixel.darktransmit !== true) {
            pixel.darkchargeCD = false
        }
        if (pixel.darktransmit === true) {
            pixel.darktransmit = false
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.nerve.id && pixel.lightcharge === true && pixel.lightchargeCD !== true) {
                pixel.lightcharge = false
                pixel.lightchargeCD = true
                hitPixel.lightcharge = true
                pixel.lighttransmit = true
            }
        }
        if (isEmpty(pixel.x, pixel.y+1) || elements[pixelMap[pixel.x][pixel.y+1].element].id != elements.nerve.id) {
            if (pixel.lightcharge === true) {
                pixel.lightcharge = false
                pixel.lightchargeCD = true
            }
        }
        if (pixel.lightchargeCD === true && pixel.lighttransmit !== true) {
            pixel.lightchargeCD = false
        }
        if (pixel.lighttransmit === true) {
            pixel.lighttransmit = false
        }
    },
    density: 2710,
    state: "solid",
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.NERVE,
    movable: false,
    desc: "Basically a biowire, try connecting it to a brain!"
}

elements.throat_lining = {
	color: "#bc6157",
	category: "nutrition",
    behavior: [
        "MX%5|DL:stomach_acid,explosive_acid,carni_acid,herbi_acid%5 AND MX%5|MX%5",
        "MX%7.5 AND DL:stomach_acid,explosive_acid,carni_acid,herbi_acid%5|XX|MX%7.5 AND DL:stomach_acid,explosive_acid,carni_acid,herbi_acid%5",
        "XX|DL:stomach_acid,explosive_acid,carni_acid,herbi_acid%5|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","slime","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Like, flesh but immune to stomach acids! Use it to make throats."
}

elements.intestines = {
	color: "#bc6157",
	category: "nutrition",
    behavior: [
        "MX%25|MX%25|MX%25",
        "MX%0.5|XX|MX%0.5",
        "XX|XX|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
		if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += hitPixel.nutrition;
                hitPixel.nutrition = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                }
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.sick = false
                    pixel.immune = true
                }
                if (hitPixel.sick === true && Math.random() > 0.95) {
                    pixel.sick = true
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    if (pixel.alcoDepri) {
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                    if (Math.random() > 0.95) {
                        pixel.alcoholic = true
                        pixel.alcoTime = pixelTicks
                        pixel.alcoDepri = 0
                    }
                }
                if (hitPixel.fent === true && Math.random() > 0.25) {
                    if (pixel.fentDepri) {
                        pixel.fentDepri = 0
                    }
                    if (Math.random() > 0.5) {
                        pixel.fenAddict = true
                        pixel.fentDepri = 0
                    }
                }
                if (hitPixel.ibup === true) {
                    ibuprofenTime = pixelTicks
                    if (pixel.ibup !== true) {
                        pixel.ibup = true
                        if (!pixel.ibupCount) {
                            pixel.ibupCount = 1
                        }
                        else {
                            pixel.ibupCount += 1
                        }
                    }
                    else {     
                        pixel.ibupCount ++
                    }
                }
                if (hitPixel.alcoholic === true && Math.random() > 0.95) {
                    pixel.alcoholic = true
                    pixel.alcoTime = pixelTicks
                    pixel.alcoDepri = 0
                }
                if (hitPixel.poisonImmune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.sick = false
                    pixel.poisonImmune = true
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Gets nutrition from digested material and makes it into poo."
}

elements.appendix = {
	color: "#B45942",
	category: "nutrition",
    behavior: [
        "XX|CR:intestine_bacteria%0.005|XX",
        "CR:intestine_bacteria%0.005|XX|CR:intestine_bacteria%0.005",
        "XX|CR:intestine_bacteria%0.005|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "stomach_acid",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() < 0.0001 && (pixel.nutrition < 750 || pixel.oxygen < 500)) {
            changePixel(pixel,"stomach_acid");
        }
        doDefaults(pixel);
        doBioNorm(pixel);
		if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += hitPixel.nutrition;
                hitPixel.nutrition = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].id === elements.digested_material.id && Math.random() > 0.99) {
                if (Math.random() > 0.5) {
            		changePixel(hitPixel,"excrement"); 
	            }
		        else {
            		changePixel(hitPixel,"stench"); 
	            }
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
            else if (elements[hitPixel.element].id === elements.gaseous_material.id && Math.random() > 0.99) {
                changePixel(hitPixel,"stench");
                pixel.nutrition += (hitPixel.nutrition * 10);
                hitPixel.nutrition = 0;
                pixel.speed += (hitPixel.speed * 2);
                hitPixel.speed = 0;
                if (hitPixel.poisoned === true && Math.random() > 0.9) {
                    pixel.poisoned = true
                };
                if (hitPixel.immune === true && Math.random() > 0.5) {
                    pixel.poisoned = false
                    pixel.immune = true
                };
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["stomach_acid","blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Like intestine but it can randomly turn into acid, but also creates helpful bacteria!"
}

elements.simple_lung = {
	color: "#EB85D9",
	category: "oxygen",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 20,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        for (var i = 0; i < squareCoords.length; i++) {
            var x = pixel.x+squareCoords[i][0];
            var y = pixel.y+squareCoords[i][1];
            if (isEmpty(x,y)) {
                if (Math.random() < 0.01) { pixel.oxygen += 100 }
                break
            } 
        } 
        doDefaults(pixel);
        doBioNorm(pixel);
		if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Like lung, but no need to hassle with the oxygen element!"
}

elements.lungs = {
	color: "#d4aaab",
	category: "oxygen",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 20,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
		if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Gets oxygen from, well, oxygen! Makes it into carbon-dioxide."
}

elements.amphib_skin = {
	color: "#7E9C33",
	category: "oxygen",
    behavior: [
        "XX|CR:slime%0.001|XX",
        "CR:slime%0.001|XX|CR:slime%0.001",
        "XX|CR:slime%0.001|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 20,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if ((pixel.temp > 35 || pixel.temp < 10) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    if (pixel.temp > 35) {
                        pixel.temp -= 20;
                        if (Math.random() < 0.01) {
                            createPixel("slime",x,y);
                        }
                        break;
                    }
                    pixel.temp += 20;
                    break;
                }
            }
        }
        if (pixel.temp < 15 && Math.random() < 0.1) {
            pixel.temp += 1;
        }
        doDefaults(pixel);
        doBioNorm(pixel);
		if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 220,
    stateHigh: ["cooked_meat","slime"],
    tempLow: -25,
    stateLow: ["frozen_meat","slime_ice","slime_ice"],
    breakInto: ["blood","meat","slime","slime"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.000075 },
        "radiation": { elem1:["slime","slime","ash","meat","rotten_meat","cooked_meat","skin","epidermis"], chance:0.1 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    burn:5,
    burnTime: 100,
    burnInto: ["cooked_meat","calcium","calcium","cooked_meat","calcium","calcium","quicklime"],
    desc: "Epidermis, but immune to acid and breathable!"
}

elements.exoskeleton = {
	color: ["#453a2e","#241d15","#242e23"],
	category: "oxygen",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 20,
    isMultiDie: false,
    normDie: "dust",
    otherDie: "calcium",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (pixel.temp > 40 && Math.random() < 0.1) {
            pixel.temp -= 1;
        }
        doDefaults(pixel);
        doBioNorm(pixel);
		if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].id === elements.oxygen.id && Math.random() > 0.9) {
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"carbon_dioxide");
                }
                pixel.oxygen += 100
            }
            else if ((elements[hitPixel.element].id === elements.chlorine.id || elements[hitPixel.element].id === elements.poison_gas.id  || elements[hitPixel.element].id === elements.acid_gas.id || elements[hitPixel.element].id === elements.cyanide_gas.id || elements[hitPixel.element].id === elements.dioxin.id) && Math.random() > 0.5) {
                deletePixel(hitPixel.x,hitPixel.y)
                pixel.oxygen -= 250
                pixel.nutrition -= 250
                pixel.speed -= 25
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 220,
    stateHigh: ["cooked_meat","calcium","calcium"],
    tempLow: -25,
    stateLow: "frozen_meat",
    breakInto: ["blood","meat","calcium"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.000075 },
        "radiation": { elem1:["calcium","calcium","ash","meat","rotten_meat","cooked_meat","skin","epidermis"], chance:0.1 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    burn:5,
    burnTime: 100,
    burnInto: ["cooked_meat","calcium","calcium","cooked_meat","calcium","calcium","quicklime"],
    desc: "Like scales, but breathable!"
}

elements.gills = {
	color: "#5EBAE3",
	category: "oxygen",
    nutrTrans: 20,
    oxygTrans: 20,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.deoxygenated_water.id && Math.random() > 0.75) {
                if (!tryMove(hitPixel,pixel.x,pixel.y+1)) {
                    if (elements[pixelMap[pixel.x][pixel.y+1].element].state === "liquid") {
                        swapPixels(hitPixel,pixelMap[pixel.x][pixel.y+1])
                    }
                }
            }
            else if (elements[hitPixel.element].id === elements.water.id && Math.random() > 0.75) {
                pixel.oxygen += 100
                if (Math.random() > 0.75) {
                    changePixel(hitPixel,"deoxygenated_water")
                }
                if (!tryMove(hitPixel,pixel.x,pixel.y+1)) {
                    if (elements[pixelMap[pixel.x][pixel.y+1].element].state === "liquid") {
                        swapPixels(hitPixel,pixelMap[pixel.x][pixel.y+1])
                    }
                }
            }
            else if (elements[hitPixel.element].id === elements.salt_water.id && Math.random() > 0.75) {
                pixel.oxygen += 90
                    if (Math.random() > 0.85) {
                    changePixel(hitPixel,"deoxygenated_water")
                }
                if (!tryMove(hitPixel,pixel.x,pixel.y+1)) {
                    if (elements[pixelMap[pixel.x][pixel.y+1].element].state === "liquid") {
                        swapPixels(hitPixel,pixelMap[pixel.x][pixel.y+1])
                    }
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.deoxygenated_water.id && Math.random() > 0.75) {
                if (isEmpty(pixel.x+1, pixel.y)) {
                    tryMove(hitPixel,pixel.x+1,pixel.y);
                }
            }
            else if (elements[hitPixel.element].id === elements.water.id && Math.random() > 0.75) {
                if (isEmpty(pixel.x+1, pixel.y)) {
                    pixel.oxygen += 100
                    if (Math.random() > 0.75) {
                        changePixel(hitPixel,"deoxygenated_water")
                    }
                    tryMove(hitPixel,pixel.x+1,pixel.y);
                }
            }
            else if (elements[hitPixel.element].id === elements.salt_water.id && Math.random() > 0.75) {
                if (isEmpty(pixel.x+1, pixel.y)) {
                    pixel.oxygen += 90
                    if (Math.random() > 0.85) {
                        changePixel(hitPixel,"deoxygenated_water")
                    }
                    tryMove(hitPixel,pixel.x+1,pixel.y);
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Gets oxygen from water passing through!"
}

elements.simple_gill = {
	color: "#75C0E2",
	category: "oxygen",
    nutrTrans: 20,
    oxygTrans: 20,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].id === elements.deoxygenated_water.id && Math.random() > 0.75) {
                if (!tryMove(hitPixel,pixel.x,pixel.y+1)) {
                    if (elements[pixelMap[pixel.x][pixel.y+1].element].state === "liquid") {
                        swapPixels(hitPixel,pixelMap[pixel.x][pixel.y+1])
                    }
                }
            }
            else if (elements[hitPixel.element].id === elements.water.id && Math.random() > 0.75) {
                pixel.oxygen += 75
                if (!tryMove(hitPixel,pixel.x,pixel.y+1)) {
                    if (elements[pixelMap[pixel.x][pixel.y+1].element].state === "liquid") {
                        swapPixels(hitPixel,pixelMap[pixel.x][pixel.y+1])
                    }
                }
            }
            else if (elements[hitPixel.element].id === elements.salt_water.id && Math.random() > 0.75) {
                pixel.oxygen += 75
                if (!tryMove(hitPixel,pixel.x,pixel.y+1)) {
                    if (elements[pixelMap[pixel.x][pixel.y+1].element].state === "liquid") {
                        swapPixels(hitPixel,pixelMap[pixel.x][pixel.y+1])
                    }
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].id === elements.deoxygenated_water.id && Math.random() > 0.75) {
                if (isEmpty(pixel.x+1, pixel.y)) {
                    tryMove(hitPixel,pixel.x+1,pixel.y);
                }
            }
            else if (elements[hitPixel.element].id === elements.water.id && Math.random() > 0.75) {
                if (isEmpty(pixel.x+1, pixel.y)) {
                    pixel.oxygen += 50
                    tryMove(hitPixel,pixel.x+1,pixel.y);
                }
            }
            else if (elements[hitPixel.element].id === elements.salt_water.id && Math.random() > 0.75) {
                if (isEmpty(pixel.x+1, pixel.y)) {
                    pixel.oxygen += 50
                    tryMove(hitPixel,pixel.x+1,pixel.y);
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Gets oxygen from water!"
}

elements.stomach_lining = {
	color: "#be5c4b",
	category: "nutrition",
    behavior: [
        "XX|CR:stomach_acid%1|XX",
        "CR:stomach_acid%1|XX|CR:stomach_acid%1",
        "XX|CR:stomach_acid%1|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Makes stomach acid to digest foods!"
}

elements.herbi_stomach = {
	color: "#B77A3D",
	category: "nutrition",
    behavior: [
        "XX|CR:herbi_acid%5|XX",
        "CR:herbi_acid%5|XX|CR:herbi_acid%5",
        "XX|CR:herbi_acid%5|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Makes a different stomach acid to digest plants!"
}

elements.carni_stomach = {
	color: "#8E2A3E",
	category: "nutrition",
    behavior: [
        "XX|CR:carni_acid%5|XX",
        "CR:carni_acid%5|XX|CR:carni_acid%5",
        "XX|CR:carni_acid%5|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Makes a different stomach acid to digest meat!"
}

elements.explosive_stomach = {
	color: "#AA9167",
	category: "nutrition",
    behavior: [
        "XX|CR:explosive_acid%5|XX",
        "CR:explosive_acid%5|XX|CR:explosive_acid%5",
        "XX|CR:explosive_acid%5|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Makes an efficient yet explosive stomach acid to digest foods!"
}

elements.stomach_valve = {
	color: "#c8846f",
	category: "nutrition",
    behavior: behaviors.WALL,
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    nutrTrans: 45,
    oxygTrans: 50,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].movable == true && (elements[hitPixel.element].isAcid != true || !elements[hitPixel.element].isAcid) && Math.random() > 0.9 && (elements[hitPixel.element].isFood != true || !elements[hitPixel.element].isFood) || (elements[hitPixel.element].id == elements.digested_material.id || elements[hitPixel.element].id == elements.gaseous_material.id)) {
                if (hitPixel.wait || (elements[hitPixel.element].id == elements.digested_material.id || elements[hitPixel.element].id == elements.gaseous_material.id)) {
                    if (hitPixel.wait < 50 && (elements[hitPixel.element].id != elements.digested_material.id || elements[hitPixel.element].id != elements.gaseous_material.id)) {
                        hitPixel.wait += 1
                    }
                    else {
                        if (isEmpty(pixel.x, pixel.y+1)) {
                            tryMove(hitPixel,pixel.x,pixel.y+1);
                        }
                    }
                }
                else {
                    hitPixel.wait = 1
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Blocks acid, lets other things through!"
}

elements.sphincter = {
	color: "#c8846f",
	category: "nutrition",
    nutrTrans: 45,
    oxygTrans: 50,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
	hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if ((elements[hitPixel.element].id === elements.excrement.id || elements[hitPixel.element].id === elements.stench.id || elements[hitPixel.element].id === elements.dirty_water.id || elements[hitPixel.element].id === elements.urine.id || elements[hitPixel.element].id === elements.intestine_bacteria.id || elements[hitPixel.element].id === elements.blood.id || elements[hitPixel.element].id === elements.infection.id) && Math.random() > 0.75) {
                if (isEmpty(pixel.x, pixel.y+1)) {
                    tryMove(hitPixel,pixel.x,pixel.y+1);
                }
            }
            else {
                if (isEmpty(pixel.x, pixel.y+1) && Math.random() > 0.995 && elements[hitPixel.element].id !== elements.digested_material.id && elements[hitPixel.element].id !== elements.gaseous_material.id) {
                    tryMove(hitPixel,pixel.x,pixel.y+1);
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","steam","excrement","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Blocks undigested material, lets other things through!"
}

elements.real_udder = {
    color: "#ecb3f5",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (isEmpty(pixel.x, pixel.y-1) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.nutrition -= 25
                }
                createPixel("milk",pixel.x,pixel.y-1)
            }
        }
        if (isEmpty(pixel.x, pixel.y+1) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.nutrition -= 25
                }
                createPixel("milk",pixel.x,pixel.y+1)
            }
        }
        if (isEmpty(pixel.x-1, pixel.y) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.nutrition -= 20
                }
                createPixel("milk",pixel.x-1,pixel.y)
            }
        }
        if (isEmpty(pixel.x+1, pixel.y) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.nutrition -= 20
                }
                createPixel("milk",pixel.x+1,pixel.y)
            }
        }
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    tempHigh: 175,
    stateHigh: "meat",
    tempLow: -50,
    stateLow: "frozen_meat",
    burn: 20,
    burnTime: 160,
    burnInto: "meat",
    breakInto: ["meat","meat","meat","milk"],
    category: "structural",
    state: "solid",
    density: 1250,
    conduct: .001,
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Turns nutrition into milk!"
}

elements.biotorch = {
    color: ["#856559","#7F6057","#815C50"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "cooked_meat",
    roomDie: "cooked_meat",
    coldDie: "meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doDefaults(pixel);
        doBioNorm(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBio != true && Math.random() > 0.5) {
                if (hitPixel.temp < pixel.temp) {
                    hitPixel.temp++
                    pixel.temp--
                }
                if (hitPixel.temp > pixel.temp) {
                    hitPixel.temp--
                    pixel.temp++
                }
            }
        }
        else if (isEmpty(pixel.x, pixel.y-1) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                pixel.oxygen -= 5
            }
            createPixel("fire",pixel.x,pixel.y-1)
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBio != true && Math.random() > 0.5) {
                if (hitPixel.temp < pixel.temp) {
                    hitPixel.temp++
                    pixel.temp--
                }
                if (hitPixel.temp > pixel.temp) {
                    hitPixel.temp--
                    pixel.temp++
                }
            }
        }
        else if (isEmpty(pixel.x, pixel.y+1) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.oxygen -= 5
                }
                createPixel("fire",pixel.x,pixel.y+1)
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBio != true && Math.random() > 0.5) {
                if (hitPixel.temp < pixel.temp) {
                    hitPixel.temp++
                    pixel.temp--
                }
                if (hitPixel.temp > pixel.temp) {
                    hitPixel.temp--
                    pixel.temp++
                }
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.oxygen -= 5
                }
                createPixel("fire",pixel.x-1, pixel.y)
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBio != true && Math.random() > 0.5) {
                if (hitPixel.temp < pixel.temp) {
                    hitPixel.temp++
                    pixel.temp--
                }
                if (hitPixel.temp > pixel.temp) {
                    hitPixel.temp--
                    pixel.temp++
                }
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && Math.random() > 0.95 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) {
            if (Math.random() > 0.95) {
                if (Math.random() > 0.95) {
                    pixel.oxygen -= 5
                }
                createPixel("fire",pixel.x+1, pixel.y)
            }
        }
        doDefaults(pixel);
    },
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
    },
    tempHigh: 750,
    stateHigh: "cooked_meat",
    tempLow: -20,
    stateLow: "frozen_meat",
    breakInto: ["meat","cooked_meat","cooked_meat","fire"],
    category: "structural",
    state: "solid",
    insulate: true,
    density: 1250,
    conduct: .001,
    movable: false,
    isBio: true,
    desc: "Turns its oxygen into fire, and works as a heat shield!"
}

elements.digested_material = {
    color: "#B5C306",
    behavior: [
        "XX|XX|XX",
        "SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%3 AND M2%5|XX|SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%3 AND M2%5",
        "SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%5 AND M2%75|SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%10 AND M1|SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%5 AND M2%75",
    ],
	properties: {
        nutrition: 100,
	    speed: 0,
    },
    category: "nutrition",
    state: "solid",
    density: 900,
    conduct: 0.25,
    stain: 0.001,
    darkText: true,
    hidden: true,
    tempHigh: 95,
    stateHigh: ["dirty_water","dirty_water","excrement"],
    tempLow: -30,
    stateLow: "dirty_ice",
}

elements.gaseous_material = {
    color: "#B5C306",
    behavior: [
        "XX|XX|XX",
        "SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%3 AND M2%35|XX|SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%3 AND M2%35",
        "SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%5 AND M2%50|SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%10 AND M1|SW:stomach_acid,herbi_acid,carni_acid,explosive_acid%5 AND M2%50",
    ],
	properties: {
        nutrition: 100,
    },
    category: "nutrition",
    state: "solid",
    density: 800,
    conduct: 0.25,
    stain: 0.001,
    darkText: true,
    hidden: true,
    tempHigh: 90,
    stateHigh: ["dirty_water","dirty_water","excrement"],
    tempLow: -35,
    stateLow: "dirty_ice",
}

elements.excrement = {
    color: "#593001",
    behavior: [
        "CR:stench%0.0002|CR:stench%0.001|CR:stench%0.0002",
        "M2%10|XX|M2%10",
        "M2%75|M1|M2%75",
    ],
    reactions: {
        "soap": { elem1:null, chance:0.2 },
        "bleach": { elem1:null, chance:0.5 },
        "pool_water": { elem1:null, elem2:"water", chance:0.05 },
        "water": { elem1:null, elem2:"dirty_water", chance:0.02 },
        "deoxygenated_water": { elem1:null, elem2:"dirty_water", chance:0.0175 },
        "salt_water": { elem1:null, elem2:"dirty_water", chance:0.02 },
        "sugar_water": { elem1:null, elem2:"dirty_water", chance:0.02 },
        "plant": { elem2:"dead_plant", chance:0.02},
    },
    category: "nutrition",
    state: "liquid",
    viscosity: 1000,
    density: 200,
    darkText: true,
    hidden: true,
    isWaste: true,
    tempHigh: 160,
    stateHigh: ["ash","stench","steam","steam","carbon_dioxide"],
    burn: 5,
    burnTime: 30,
    burnInto: ["ash","stench","steam","steam","carbon_dioxide","fire","fire"],
    tempLow: -10,
    stain: 0.005,
    stateLowName: "solid_poop",
}

elements.intestine_bacteria = {
    color: "#955E93",
    behavior: [
        "XX|M2%0.3|M2%3",
        "XX|FX%2 AND DL%0.0005|M2%3 AND BO",
        "XX|M1|M2%3",
    ],
    reactions: {
        "water": { elem1:null, elem2:"dirty_water", chance:0.01 },
        "excrement": { elem2:null, chance:0.01, func:behaviors.FEEDPIXEL  },
        "bacteria": { elem2:null, chance:0.5, func:behaviors.FEEDPIXEL   },
        "intestine_bacteria": { elem2:null, chance:0.001, func:behaviors.FEEDPIXEL   },
        "mercury": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "bleach": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "uranium": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "cyanide": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "chlorine": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "alcohol": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.25 },
        "vinegar": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.01 },
        "mouthwash": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.001 },
    },
    foodNeed: 25,
    egg: "intestine_bacteria",
    tempHigh: 80,
    stateHigh: "dna",
    tempLow: -10,
    stateLow: "dna",
    breakInto: "dna",
    category:"nutrition",
    burn:95,
    burnTime: 100,
    burnInto: "dna",
    state: "solid",
    density: 600,
    stain: -0.005,
    conduct: 0.1,
    isWaste: true
}

elements.stomach_acid = {
    color: ["#b5cf91","#288f2a"],
    behavior: [
        "ADB%5|ADB%5|ADB%5",
        "ADB%10 AND M2|XX|ADB%10 AND M2",
        "ADB%10 AND M2|ADB%15 AND M1|ADB%10 AND M2",
    ],
    ignore: ["amphib_skin","amphib_dermis","acidic_flesh","acid_vessel","throat_lining","explosive_stomach","stomach_lining","stomach_valve","slime","gaseous_material","digested_material","glass","rad_glass","glass_shard","rad_shard","stained_glass","baked_clay","acid_gas","neutral_acid","acid_cloud","water","salt_water","sugar_water","dirty_water","copper","gold","porcelain","plastic","bead","microplastic","molten_plastic","pool_water","chlorine","hydrogen","gold_coin","silver","nickel","calcium","bone","earthquake","tornado","tsunami","liquid_light","sensor"],
    reactions: {
        "bless": { elem1:null, elem2:["gaseous_material",null,null,null,null,null,null,null,null,null,null], attr2:{"nutrition":100, "speed":10, "poisonImmune":true}, chance:0.5 },
        "dirty_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":-5, "speed":-1, "sick":true}, chance:0.02 },
        "water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":0, "speed":2}, chance:0.02 },
        "salt_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "sugar_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":10, "speed":-1}, chance:0.02 },
        "tree_branch": { elem1:null, elem2:"wood", chance:0.02 },
        "sugar": { elem2:"digested_material", attr2:{"nutrition":25, "speed":5}, chance:0.02 },
        "molasses": { elem2:"digested_material", attr2:{"nutrition":10, "speed":8}, chance:0.02 },
        "dead_plant": { elem2:"digested_material", attr2:{"nutrition":15, "speed":1}, chance:0.02 },
        "meat": { elem2:"digested_material", attr2:{"nutrition":30, "speed":-1}, chance:0.02 },
        "cooked_meat": { elem2:"digested_material", attr2:{"nutrition":60}, chance:0.02 },
        "broth": { elem1:null, elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "rotten_meat": { elem2:["digested_material","digested_material","ammonia"], attr2:{"nutrition":-10, "speed":-10, "sick":true}, chance:0.02 },
        "cured_meat": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "cheese": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "rotten_cheese": { elem2:["digested_material"], attr2:{"nutrition":-10, "speed":-10, "sick":true}, chance:0.02 },
        "cheese_powder": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "lettuce": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "herb": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "toast": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "bread": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "hard_yolk": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "yolk": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-2}, chance:0.02 },
        "milk": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "eggnog": { elem2:"digested_material", attr2:{"nutrition":25, "speed":-1}, chance:0.02 },
        "nut_milk": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "chocolate_milk": { elem2:"digested_material", attr2:{"nutrition":25, "speed":1}, chance:0.02 },
        "fruit_milk": { elem2:"digested_material", attr2:{"nutrition":30, "speed":1}, chance:0.02 },
        "pilk": { elem2:"digested_material", attr2:{"nutrition":30, "speed":5}, chance:0.02 },
        "crumb": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "pickle": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "salt": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "worm": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "ant": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "flea": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "fly": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "firefly": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-5, "poisoned":true}, chance:0.02 },
        "stinkbug": { elem2:"gaseous_material", attr2:{"nutrition":4, "speed":-5, "sick":true}, chance:0.02 },
        "bee": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "spider": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "rat": { elem2:"digested_material", attr2:{"nutrition":-10, "speed":-5, "sick":true}, chance:0.01 },
        "bird": { elem2:"digested_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.01 },
        "fish": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.01 },
        "head": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-2}, chance:0.01 },
        "body": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-2}, chance:0.01 },
        "egg": { elem2:"gaseous_material", attr2:{"nutrition":-5, "speed":-2}, chance:0.02 },
        "soda": { elem2:"digested_material", attr2:{"nutrition":20, "speed":2}, chance:0.02 },
        "sap": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":-1}, chance:0.02 },
        "juice": { elem2:"digested_material", attr2:{"nutrition":25, "speed":1}, chance:0.02 },
        "mayo": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "nut_butter": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "ketchup": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "jelly": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "bleach": { elem2:"digested_material", attr2:{"nutrition":-500, "speed":-10, "poisoned":true}, chance:0.02 },
        "poison": { elem2:"digested_material", attr2:{"nutrition":-750, "speed":-10, "poisoned":true}, chance:0.02 },
        "cyanide": { elem2:"digested_material", attr2:{"nutrition":-750, "speed":-10, "poisoned":true}, chance:0.02 },
        "poison_gas": { elem2:"gaseous_material", attr2:{"nutrition":-750, "speed":-10, "poisoned":true}, chance:0.02 },
        "cyanide_gas": { elem2:"gaseous_material", attr2:{"nutrition":-750, "speed":-10, "poisoned":true}, chance:0.02 },
        "soap": { elem2:"digested_material", attr2:{"nutrition":-20, "speed":-10}, chance:0.02 },
        "mercury": { elem2:"digested_material", attr2:{"nutrition":-500, "speed":-10, "poisoned":true}, chance:0.02 },
        "chlorine": { elem2:"gaseous_material", attr2:{"nutrition":-500, "speed":-10, "poisoned":true}, chance:0.02 },
        "pool_water": { elem2:"digested_material", attr2:{"nutrition":-10, "speed":-10}, chance:0.02 },
        "vaccine": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":1, "immune":true}, chance:0.02 },
        "antidote": { elem2:"digested_material", attr2:{"nutrition":1, "speed":1, "poisonImmune":true}, chance:0.02 },
        "coffee": { elem2:"digested_material", attr2:{"nutrition":20, "speed":10}, chance:0.02 },
        "tomato": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "grape": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "beans": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "sauce": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "butter": { elem2:"digested_material", attr2:{"nutrition":15, "speed":-1}, chance:0.02 },
        "melted_cheese": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "melted_chocolate": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "melted_butter": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "chocolate": { elem2:"digested_material", attr2:{"nutrition":35, "speed":2}, chance:0.02 },
        "chocolate_powder": { elem2:"digested_material", attr2:{"nutrition":35, "speed":2}, chance:0.02 },
        "rice": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "dough": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "batter": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "baked_batter": { elem2:"digested_material", attr2:{"nutrition":45, "speed":2}, chance:0.02 },
        "gingerbread": { elem2:"digested_material", attr2:{"nutrition":45, "speed":2}, chance:0.02 },
        "ice_cream": { elem2:"digested_material", attr2:{"nutrition":40, "speed":2}, chance:0.02 },
        "cream": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "caramel": { elem2:"digested_material", attr2:{"nutrition":30, "speed":3}, chance:0.02 },
        "potato": { elem2:"digested_material", attr2:{"nutrition":15, "speed":-1}, chance:0.02 },
        "baked_potato": { elem2:"digested_material", attr2:{"nutrition":45, "speed":1}, chance:0.02 },
        "mashed_potato": { elem2:"digested_material", attr2:{"nutrition":40, "speed":1}, chance:0.02 },
        "yogurt": { elem2:"digested_material", attr2:{"nutrition":35, "speed":1}, chance:0.02 },
        "frozen_yogurt": { elem2:"digested_material", attr2:{"nutrition":35, "speed":2}, chance:0.02 },
        "slush": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "coffee_bean": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":20}, chance:0.02 },
	    "coffee_ground": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":15}, chance:0.02 },
        "yeast": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":-1}, chance:0.02 },
        "alcohol": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-5, "alcoholic": true}, chance:0.02 },
        "honey": { elem2:"digested_material", attr2:{"nutrition":35, "speed":3}, chance:0.02 },
        "blood": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "excrement": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "urine": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "tea": { elem2:"digested_material", attr2:{"nutrition":10, "speed":10}, chance:0.02 },
        "infection": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-5, "sick":true}, chance:0.02 },
        "cancer": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-15, "sick":true}, chance:0.02 },
        "plague": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "glue": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-10}, chance:0.02 },
        "fentanyl": { elem2:"gaseous_material", attr2:{"nutrition":-50, "speed":-20, "fent":true}, chance:0.01 },
        "ibuprofen": { elem2:"gaseous_material", attr2:{"nutrition":1, "speed":1, "ibup":true}, chance:0.02 },
    },
    category: "nutrition",
    tempHigh: 110,
    stateHigh: "acid_gas",
    tempLow: -58.88,
    burn: 30,
    burnTime: 1,
    state: "liquid",
    density: 1550,
    stain: -0.1,
    isAcid: true,
}

elements.herbi_acid = {
    color: ["#A8E54F","#5BC217"],
    behavior: [
        "XX|ADB%5|XX",
        "ADB%5 AND M2|XX|ADB%5 AND M2",
        "ADB%5 AND M2|ADB%5 AND M1|ADB%5 AND M2",
    ],
    ignore: ["amphib_skin","amphib_dermis","acidic_flesh","acid_vessel","throat_lining","explosive_stomach","herbi_stomach","carni_stomach","stomach_lining","stomach_valve","slime","gaseous_material","digested_material","glass","rad_glass","glass_shard","rad_shard","stained_glass","baked_clay","acid_gas","neutral_acid","acid_cloud","water","salt_water","sugar_water","dirty_water","copper","gold","porcelain","plastic","bead","microplastic","molten_plastic","pool_water","chlorine","hydrogen","gold_coin","silver","nickel","calcium","bone","earthquake","tornado","tsunami","liquid_light","sensor"],
    reactions: {
        "bless": { elem1:null, elem2:["gaseous_material",null,null,null,null,null,null,null,null,null,null], attr2:{"nutrition":100, "speed":10, "poisonImmune":true}, chance:0.5 },
        "dirty_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":-5, "speed":-3, "sick":true}, chance:0.02 },
        "water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":0, "speed":5}, chance:0.02 },
        "salt_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "sugar_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":10, "speed":1}, chance:0.02 },
        "plant": { elem2:"digested_material", attr2:{"nutrition":80, "speed":1}, chance:0.02},
        "tree_branch": { elem1:null, elem2:"wood", attr2:{"nutrition":10, "speed":1}, chance:0.02 },
        "sugar": { elem2:"digested_material", attr2:{"nutrition":25, "speed":5}, chance:0.02 },
        "molasses": { elem2:"digested_material", attr2:{"nutrition":10, "speed":8}, chance:0.02 },
        "dead_plant": { elem2:"digested_material", attr2:{"nutrition":75}, chance:0.02 },
        "meat": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "cooked_meat": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":1}, chance:0.02 },
        "broth": { elem1:null, elem2:"digested_material", attr2:{"nutrition":-5}, chance:0.02 },
        "rotten_meat": { elem2:["digested_material","ammonia",null,null,null], attr2:{"nutrition":-25, "speed":-20, "sick":true}, chance:0.02 },
        "cured_meat": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":-1}, chance:0.02 },
        "cheese": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "rotten_cheese": { elem2:["digested_material"], attr2:{"nutrition":-10, "speed":-10, "sick":true}, chance:0.02 },
        "cheese_powder": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "vine": { elem2:"digested_material", attr2:{"nutrition":60}, chance:0.02 },
        "grass": { elem2:"digested_material", attr2:{"nutrition":60}, chance:0.02 },
        "kelp": { elem2:"digested_material", attr2:{"nutrition":60}, chance:0.02 },
        "algae": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "lettuce": { elem2:"digested_material", attr2:{"nutrition":60}, chance:0.02 },
        "herb": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "toast": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "bread": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "hard_yolk": { elem2:"digested_material", attr2:{"nutrition":30}, chance:0.02 },
        "yolk": { elem2:"digested_material", attr2:{"nutrition":10, "speed":5}, chance:0.02 },
        "milk": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "eggnog": { elem2:"digested_material", attr2:{"nutrition":25, "speed":-1}, chance:0.02 },
        "nut_milk": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "chocolate_milk": { elem2:"digested_material", attr2:{"nutrition":35, "speed":1}, chance:0.02 },
        "fruit_milk": { elem2:"digested_material", attr2:{"nutrition":40, "speed":1}, chance:0.02 },
        "pilk": { elem2:"digested_material", attr2:{"nutrition":25, "speed":5}, chance:0.02 },
        "crumb": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "pickle": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "salt": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "worm": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "ant": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "flea": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "fly": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "firefly": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-5, "poisoned":true}, chance:0.02 },
        "stinkbug": { elem2:"gaseous_material", attr2:{"nutrition":-11, "speed":-5}, chance:0.02 },
        "bee": { elem2:"gaseous_material", attr2:{"nutrition":-9}, chance:0.02 },
        "spider": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "rat": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-5, "sick":true}, chance:0.02 },
        "bird": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-1}, chance:0.02 },
        "fish": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-1}, chance:0.02 },
        "head": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-2}, chance:0.02 },
        "body": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-2}, chance:0.02 },
        "egg": { elem2:"digested_material", attr2:{"nutrition":-20}, chance:0.02 },
        "soda": { elem2:"digested_material", attr2:{"nutrition":-5}, chance:0.02 },
        "sap": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "juice": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "mayo": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "nut_butter": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "ketchup": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "jelly": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "bleach": { elem2:"digested_material", attr2:{"nutrition":-500, "speed":-20, "poisoned":true}, chance:0.02 },
        "poison": { elem2:"digested_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "cyanide": { elem2:"digested_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "poison_gas": { elem2:"gaseous_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "cyanide_gas": { elem2:"gaseous_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "soap": { elem2:"digested_material", attr2:{"nutrition":-20, "speed":-10}, chance:0.02 },
        "mercury": { elem2:"digested_material", attr2:{"nutrition":-500, "speed":-20, "poisoned":true}, chance:0.02 },
        "chlorine": { elem2:"gaseous_material", attr2:{"nutrition":-500, "speed":-20, "poisoned":true}, chance:0.02 },
        "pool_water": { elem2:"digested_material", attr2:{"nutrition":-20, "speed":-20}, chance:0.02 },
        "vaccine": { elem2:"digested_material", attr2:{"nutrition":1, "speed":-1, "immune":true}, chance:0.02 },
        "antidote": { elem2:"digested_material", attr2:{"nutrition":-1, "speed":1, "poisonImmune":true}, chance:0.02 },
        "coffee": { elem2:"digested_material", attr2:{"nutrition":20, "speed":10}, chance:0.02 },
        "tomato": { elem2:"digested_material", attr2:{"nutrition":55}, chance:0.02 },
        "grape": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "beans": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "sauce": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "butter": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "melted_cheese": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "melted_chocolate": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "melted_butter": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "chocolate": { elem2:"digested_material", attr2:{"nutrition":20, "speed":2}, chance:0.02 },
        "chocolate_powder": { elem2:"digested_material", attr2:{"nutrition":20, "speed":2}, chance:0.02 },
        "rice": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "dough": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "batter": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "baked_batter": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "gingerbread": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "ice_cream": { elem2:"digested_material", attr2:{"nutrition":30}, chance:0.02 },
        "cream": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "caramel": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "potato": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "baked_potato": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "mashed_potato": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "yogurt": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "frozen_yogurt": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "slush": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "coffee_bean": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":20}, chance:0.02 },
	    "coffee_ground": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":15}, chance:0.02 },
        "yeast": { elem2:"digested_material", attr2:{"nutrition":-5}, chance:0.02 },
        "alcohol": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":-15, "alcoholic": true}, chance:0.02 },
        "honey": { elem2:"digested_material", attr2:{"nutrition":35, "speed":3}, chance:0.02 },
        "blood": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":-1}, chance:0.02 },
        "excrement": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "urine": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "tea": { elem2:"digested_material", attr2:{"nutrition":10, "speed":10}, chance:0.02 },
        "infection": { elem2:"digested_material", attr2:{"nutrition":-20, "speed":-5, "sick":true}, chance:0.02 },
        "cancer": { elem2:"gaseous_material", attr2:{"nutrition":-25, "speed":-15, "sick":true}, chance:0.02 },
        "plague": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "glue": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-10, "sick":true}, chance:0.02 },
        "fentanyl": { elem2:"gaseous_material", attr2:{"nutrition":-50, "speed":-20, "fent":true}, chance:0.01 },
    },
    category: "nutrition",
    tempHigh: 110,
    stateHigh: "acid_gas",
    tempLow: -58.88,
    burn: 30,
    burnTime: 1,
    state: "liquid",
    density: 1550,
    stain: -0.1,
    isAcid: true,
}

elements.carni_acid = {
    color: ["#ADA469","#5B6517"],
    behavior: [
        "XX|ADB%5|XX",
        "ADB%5 AND M2|XX|ADB%5 AND M2",
        "ADB%5 AND M2|ADB%5 AND M1|ADB%5 AND M2",
    ],
    ignore: ["amphib_skin","amphib_dermis","acidic_flesh","acid_vessel","throat_lining","explosive_stomach","stomach_lining","carni_stomach","stomach_valve","slime","gaseous_material","digested_material","glass","rad_glass","glass_shard","rad_shard","stained_glass","baked_clay","acid_gas","neutral_acid","acid_cloud","water","salt_water","sugar_water","dirty_water","copper","gold","porcelain","plastic","bead","microplastic","molten_plastic","pool_water","chlorine","hydrogen","gold_coin","silver","nickel","calcium","bone","earthquake","tornado","tsunami","liquid_light","sensor"],
    reactions: {
        "bless": { elem1:null, elem2:["gaseous_material",null,null,null,null,null,null,null,null,null,null], attr2:{"nutrition":100, "speed":10, "poisonImmune":true}, chance:0.5 },
        "dirty_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":-5, "speed":-2, "sick":true}, chance:0.02 },
        "water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":0, "speed":5}, chance:0.02 },
        "salt_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "sugar_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":10, "speed":1}, chance:0.02 },
        "plant": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-5}, chance:0.02},
        "tree_branch": { elem1:null, elem2:"wood", chance:0.02 },
        "sugar": { elem2:"digested_material", attr2:{"nutrition":10, "speed":3}, chance:0.02 },
        "molasses": { elem2:"digested_material", attr2:{"nutrition":5, "speed":5}, chance:0.02 },
        "dead_plant": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "meat": { elem2:"digested_material", attr2:{"nutrition":70, "speed":5}, chance:0.02 },
        "cooked_meat": { elem2:"digested_material", attr2:{"nutrition":60, "speed":4}, chance:0.02 },
        "broth": { elem1:null, elem2:"digested_material", attr2:{"nutrition":50, "speed":6}, chance:0.02 },
        "rotten_meat": { elem2:["digested_material","ammonia",null,null,null], attr2:{"nutrition":5, "speed":-5, "sick":true}, chance:0.02 },
        "cured_meat": { elem2:"digested_material", attr2:{"nutrition":50, "speed":-1}, chance:0.02 },
        "cheese": { elem2:"digested_material", attr2:{"nutrition":35, "speed":-1}, chance:0.02 },
        "rotten_cheese": { elem2:["digested_material","ammonia",null,null,null], attr2:{"nutrition":-20, "speed":-5, "sick":true}, chance:0.02 },
        "cheese_powder": { elem2:"digested_material", attr2:{"nutrition":35, "speed":-1}, chance:0.02 },
        "lettuce": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "herb": { elem2:"digested_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "toast": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "bread": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "hard_yolk": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "yolk": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "milk": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "eggnog": { elem2:"digested_material", attr2:{"nutrition":20, "speed":-1}, chance:0.02 },
        "nut_milk": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "chocolate_milk": { elem2:"digested_material", attr2:{"nutrition":25, "speed":1}, chance:0.02 },
        "fruit_milk": { elem2:"digested_material", attr2:{"nutrition":30, "speed":1}, chance:0.02 },
        "pilk": { elem2:"digested_material", attr2:{"nutrition":30, "speed":5}, chance:0.02 },
        "crumb": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "pickle": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "salt": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "worm": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "ant": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "bee": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "spider": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "rat": { elem2:"digested_material", attr2:{"nutrition":15, "speed":-5, "sick":true}, chance:0.02 },
        "bird": { elem2:"digested_material", attr2:{"nutrition":15, "speed":1}, chance:0.02 },
        "fish": { elem2:"digested_material", attr2:{"nutrition":15, "speed":1}, chance:0.02 },
        "head": { elem2:"digested_material", attr2:{"nutrition":15, "speed":2}, chance:0.02 },
        "body": { elem2:"digested_material", attr2:{"nutrition":15, "speed":2}, chance:0.02 },
        "flea": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "fly": { elem2:"gaseous_material", attr2:{"nutrition":5, "speed":-1}, chance:0.02 },
        "firefly": { elem2:"gaseous_material", attr2:{"nutrition":4, "speed":-5, "poisoned":true}, chance:0.02 },
        "stinkbug": { elem2:"gaseous_material", attr2:{"nutrition":4, "speed":-5, "sick":true}, chance:0.02 },
        "egg": { elem2:"digested_material", attr2:{"nutrition":25, "speed":1}, chance:0.02 },
        "soda": { elem2:"digested_material", attr2:{"nutrition":10, "speed":-1}, chance:0.02 },
        "sap": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-1}, chance:0.02 },
        "juice": { elem2:"digested_material", attr2:{"nutrition":10, "speed":1}, chance:0.02 },
        "mayo": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "nut_butter": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "ketchup": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "jelly": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "bleach": { elem2:"digested_material", attr2:{"nutrition":-500, "speed":-20, "poisoned":true}, chance:0.02 },
        "poison": { elem2:"digested_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "cyanide": { elem2:"digested_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "poison_gas": { elem2:"gaseous_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "cyanide_gas": { elem2:"gaseous_material", attr2:{"nutrition":-750, "speed":-20, "poisoned":true}, chance:0.02 },
        "soap": { elem2:"digested_material", attr2:{"nutrition":-20, "speed":-15}, chance:0.02 },
        "mercury": { elem2:"digested_material", attr2:{"nutrition":-500, "speed":-20, "poisoned":true}, chance:0.02 },
        "chlorine": { elem2:"gaseous_material", attr2:{"nutrition":-500, "speed":-20, "poisoned":true}, chance:0.02 },
        "pool_water": { elem2:"digested_material", attr2:{"nutrition":-400, "speed":-15}, chance:0.02 },
        "vaccine": { elem2:"digested_material", attr2:{"nutrition":1, "speed":-1, "immune":true}, chance:0.02 },
        "antidote": { elem2:"digested_material", attr2:{"nutrition":-1, "speed":1, "poisonImmune":true}, chance:0.02 },
        "coffee": { elem2:"digested_material", attr2:{"nutrition":10, "speed":5}, chance:0.02 },
        "tomato": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "grape": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "beans": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "sauce": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "butter": { elem2:"digested_material", attr2:{"nutrition":-5}, chance:0.02 },
        "melted_cheese": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "melted_chocolate": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "melted_butter": { elem2:"gaseous_material", attr2:{"nutrition":-10}, chance:0.02 },
        "chocolate": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "chocolate_powder": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "rice": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "dough": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "batter": { elem2:"digested_material", attr2:{"nutrition":-5}, chance:0.02 },
        "baked_batter": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "gingerbread": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "ice_cream": { elem2:"digested_material", attr2:{"nutrition":30, "speed":1}, chance:0.02 },
        "cream": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "caramel": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "potato": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "baked_potato": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "mashed_potato": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "yogurt": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "frozen_yogurt": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "slush": { elem2:"digested_material", attr2:{"nutrition":-1, "speed":1}, chance:0.02 },
        "coffee_bean": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":15}, chance:0.02 },
        "yeast": { elem2:"gaseous_material", attr2:{"nutrition":-10}, chance:0.02 },
        "alcohol": { elem2:"digested_material", attr2:{"nutrition":-15, "speed":-15, "alcoholic": true}, chance:0.02 },
        "honey": { elem2:"digested_material", attr2:{"nutrition":35, "speed":5}, chance:0.02 },
        "blood": { elem2:"digested_material", attr2:{"nutrition":15, "speed":3}, chance:0.02 },
        "excrement": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-5, "sick":true}, chance:0.02 },
        "urine": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10}, chance:0.02 },
        "tea": { elem2:"digested_material", attr2:{"nutrition":5, "speed":10}, chance:0.02 },
        "infection": { elem2:"digested_material", attr2:{"nutrition":-5, "sick":true}, chance:0.02 },
        "cancer": { elem2:"digested_material", attr2:{"nutrition":-5, "speed":-5, "sick":true}, chance:0.02 },
        "plague": { elem2:"gaseous_material", attr2:{"nutrition":-15, "speed":-10, "sick":true}, chance:0.02 },
        "glue": { elem2:"gaseous_material", attr2:{"nutrition":-10, "speed":-15, "sick":true}, chance:0.02 },
        "fentanyl": { elem2:"gaseous_material", attr2:{"nutrition":-50, "speed":-20, "fent":true}, chance:0.01 },
    },
    category: "nutrition",
    tempHigh: 110,
    stateHigh: "acid_gas",
    tempLow: -58.88,
    burn: 30,
    burnTime: 1,
    state: "liquid",
    density: 1550,
    stain: -0.1,
    isAcid: true,
}

elements.explosive_acid = {
    color: ["#E9DC8C","#D0C15A"],
    behavior: [
        "XX|ADB%5|XX",
        "ADB%5 AND M2|XX|ADB%5 AND M2",
        "ADB%5 AND M2|ADB%5 AND M1|ADB%5 AND M2",
    ],
    ignore: ["amphib_skin","amphib_dermis","acidic_flesh","acid_vessel","throat_lining","stomach_lining","explosive_stomach","stomach_valve","slime","gaseous_material","digested_material","glass","rad_glass","glass_shard","rad_shard","stained_glass","baked_clay","acid_gas","neutral_acid","acid_cloud","water","salt_water","sugar_water","dirty_water","copper","gold","porcelain","plastic","bead","microplastic","molten_plastic","pool_water","chlorine","hydrogen","gold_coin","silver","nickel","calcium","bone","earthquake","tornado","tsunami","liquid_light","sensor"],
    reactions: {
        "bless": { elem1:null, elem2:["gaseous_material",null,null,null,null,null,null,null,null,null,null], attr2:{"nutrition":100, "speed":10, "poisonImmune":true}, chance:0.5 },
        "dirty_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":0}, chance:0.02 },
        "water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":0, "speed":10}, chance:0.02 },
        "salt_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "sugar_water": { elem1:null, elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "plant": { elem2:"digested_material", attr2:{"nutrition":10, "speed":5}, chance:0.02},
        "tree_branch": { elem1:null, elem2:"wood", chance:0.02 },
        "sugar": { elem2:"digested_material", attr2:{"nutrition":30, "speed":5}, chance:0.02 },
        "molasses": { elem2:"digested_material", attr2:{"nutrition":15, "speed":8}, chance:0.02 },
        "dead_plant": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "meat": { elem2:"digested_material", attr2:{"nutrition":30, "speed":5}, chance:0.02 },
        "cooked_meat": { elem2:"digested_material", attr2:{"nutrition":60}, chance:0.02 },
        "broth": { elem1:null, elem2:"digested_material", attr2:{"nutrition":55}, chance:0.02 },
        "rotten_meat": { elem2:["digested_material","ammonia",null,null,null], attr2:{"nutrition":30}, chance:0.02 },
        "cured_meat": { elem2:"digested_material", attr2:{"nutrition":50}, chance:0.02 },
        "cheese": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "lettuce": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "herb": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "toast": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "bread": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "hard_yolk": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "yolk": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "milk": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "eggnog": { elem2:"digested_material", attr2:{"nutrition":25, "speed":1}, chance:0.02 },
        "nut_milk": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "chocolate_milk": { elem2:"digested_material", attr2:{"nutrition":25, "speed":1}, chance:0.02 },
        "fruit_milk": { elem2:"digested_material", attr2:{"nutrition":30, "speed":1}, chance:0.02 },
        "pilk": { elem2:"digested_material", attr2:{"nutrition":30, "speed":5}, chance:0.02 },
        "crumb": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "pickle": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "salt": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "worm": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "ant": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "bee": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "spider": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "rat": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "bird": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "fish": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "head": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "body": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "flea": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "fly": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "firefly": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "stinkbug": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "egg": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "soda": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "sap": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "juice": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "mayo": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "nut_butter": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "ketchup": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "jelly": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "bleach": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "poison": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "cyanide": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "poison_gas": { elem2:"gaseous_material", attr2:{"nutrition":10}, chance:0.02 },
        "cyanide_gas": { elem2:"gaseous_material", attr2:{"nutrition":10}, chance:0.02 },
        "soap": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "mercury": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "chlorine": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "pool_water": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "vaccine": { elem2:"digested_material", attr2:{"nutrition":1, "speed":-1, "immune":true}, chance:0.02 },
        "antidote": { elem2:"digested_material", attr2:{"nutrition":-1, "speed":1, "poisonImmune":true}, chance:0.02 },
        "coffee": { elem2:"digested_material", attr2:{"nutrition":20}, chance:0.02 },
        "tomato": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "grape": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "beans": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "sauce": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "butter": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "melted_cheese": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "melted_chocolate": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "melted_butter": { elem2:"digested_material", attr2:{"nutrition":10}, chance:0.02 },
        "chocolate": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "cheese_powder": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "chocolate_powder": { elem2:"digested_material", attr2:{"nutrition":35, "speed":2}, chance:0.02 },
        "rice": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "dough": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "batter": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "baked_batter": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "gingerbread": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "ice_cream": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "cream": { elem2:"digested_material", attr2:{"nutrition":25}, chance:0.02 },
        "caramel": { elem2:"digested_material", attr2:{"nutrition":30}, chance:0.02 },
        "potato": { elem2:"digested_material", attr2:{"nutrition":15}, chance:0.02 },
        "baked_potato": { elem2:"digested_material", attr2:{"nutrition":45}, chance:0.02 },
        "mashed_potato": { elem2:"digested_material", attr2:{"nutrition":40}, chance:0.02 },
        "yogurt": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "frozen_yogurt": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "slush": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "coffee_bean": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "yeast": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "alcohol": { elem2:"digested_material", attr2:{"nutrition":5, "alcoholic": true}, chance:0.02 },
        "honey": { elem2:"digested_material", attr2:{"nutrition":35}, chance:0.02 },
        "blood": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "excrement": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "urine": { elem2:"gaseous_material", attr2:{"nutrition":5}, chance:0.02 },
        "tea": { elem2:"digested_material", attr2:{"nutrition":5, "speed":5}, chance:0.02 },
        "infection": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "cancer": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "plague": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "glue": { elem2:"digested_material", attr2:{"nutrition":5}, chance:0.02 },
        "fentanyl": { elem2:"gaseous_material", attr2:{"nutrition":-5}, chance:0.01 },
    },
    category: "nutrition",
    tempHigh: 600,
    stateHigh: "pop",
    burn: 100,
    burnTime: 1,
    burnInto: "explosion",
    breakInto: ["explosion","pop"],
    viscosity: 36,
    tempLow: -58.88,
    state: "liquid",
    density: 1550,
    isAcid: true,
}

elements.deoxygenated_water = {
    color: "#829BD4",
    behavior: behaviors.LIQUID,
    tempHigh: 100,
    stateHigh: "steam",
    tempLow: 0,
    stateLow: "ice",
    category: "liquids",
    heatCapacity: 4.184,
    reactions: {
        "oxygen": { elem1: "water", elem2: null },
        "dust": { elem1: "dirty_water", elem2: null },
        "ash": { elem1: "dirty_water", elem2: null },
        "cyanide": { elem1: "dirty_water", elem2: null },
        "cyanide_gas": { elem1: "dirty_water", elem2: null },
        "carbon_dioxide": { elem1: "seltzer", elem2: null, oneway:true },
        "sulfur": { elem1: "dirty_water", elem2: null },
        "rat": { elem1: "dirty_water", chance:0.005 },
        "plague": { elem1: "dirty_water", elem2: null },
        "rust": { elem1: "dirty_water", chance:0.005 },
        "lead": { elem1: "dirty_water", chance:0.005 },
        "solder": { elem1: "dirty_water", chance:0.005 },
        "fallout": { elem1: "dirty_water", chance:0.25 },
        "radiation": { elem1: "dirty_water", chance:0.25 },
        "uranium": { elem1: "dirty_water", chance:0.25 },
        "rad_steam": { elem1: "dirty_water", chance:0.02 },
        "rad_glass": { elem1: "dirty_water", chance:0.005 },
        "rad_shard": { elem1: "dirty_water", chance:0.01 },
        "rotten_meat": { elem1: "dirty_water", chance:0.25 },
        "rotten_cheese": { elem1: "dirty_water", chance:0.25 },
        "cancer": { elem1: "dirty_water", chance:0.25 },
        "oil": { elem1: "dirty_water", chance:0.005 },
        "dioxin": { elem1: "dirty_water", chance:0.1 },
        "rock": { elem2: "wet_sand", chance: 0.00035 },
        "limestone": { elem2: "wet_sand", chance: 0.00035 },
        "tuff": { elem2: "wet_sand", color2:"#7a6b5c", chance: 0.00035 },
        "ruins": { elem2: "rock", chance: 0.00035 },
        "mudstone": { elem2: "mud", chance: 0.00035 },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cured_meat": { elem1:"salt_water", elem2:"meat" },
        "water": { elem1:"water", chance:0.005 },
        "salt_water": { elem1:"water", chance:0.005 },
        "deoxygenated_water": { elem2:"bubble", attr2:{"clone":"water"}, chance:0.001, tempMin:85 },
    },
    state: "liquid",
    density: 1100,
    conduct: 0.02,
    stain: -0.5,
    extinguish: true
}

elements.real_bone = {
    color: "#d9d9d9",
    behavior: behaviors.WALL,
    reactions: {
        "water": { elem2:"broth", tempMin:70 },
        "salt_water": { elem2:"broth", tempMin:70 },
        "sugar_water": { elem2:"broth", tempMin:70 },
        "seltzer": { elem2:"broth", tempMin:70 },
    },
    nutrTrans: 10,
    oxygTrans: 15,
    isMultiDie: false,
    normDie: "bone",
    otherDie: "bone",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioBone(pixel);
        doDefaults(pixel);
    },
    category:"structural",
    tempHigh: 260,
    stateHigh: "bone",
    tempLow: -36,
    stateLow: "bone",
    state: "solid",
    density: 1900,
    hardness: 0.5,
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,
    },
    breakInto: ["real_bone_marrow","real_bone_marrow","blood","bone","bone","bone","bone","bone","bone","bone","bone","bone","bone","bone","bone"],
    movable: false,
    isBio: true,
    burn: 1,
    burnTime: 100,
    burnInto: ["bone","bone","bone","bone","quicklime"],
    desc: "Hard organism building material!"
}

elements.real_bone_marrow = {
	color: "#D3A491",
	category: "structural",
    behavior: [
        "SW:real_bone_marrow%0.25|SW:real_bone_marrow%1.25|SW:real_bone_marrow%0.25",
        "SW:real_bone_marrow%1.25|XX|SW:real_bone_marrow%1.25",
        "SW:real_bone_marrow%0.25|SW:real_bone_marrow%1.25|SW:real_bone_marrow%0.25",
    ],
    nutrTrans: 25,
    oxygTrans: 30,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050)) && Math.random() < 0.005) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coords = squareCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("real_bone",x,y);
                }
            }
        }
        doBioNorm(pixel);
        doDefaults(pixel);
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBlood === true) {
                if (Math.random() > 0.9995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2020))) {
                    hitPixel.element = "white_blood_cell";
                    hitPixel.color = elements.white_blood_cell.color;
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBlood === true) {
                if (Math.random() > 0.9995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2020))) {
                    hitPixel.element = "white_blood_cell";
                    hitPixel.color = elements.white_blood_cell.color;
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBlood === true) {
                if (Math.random() > 0.9995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2020))) {
                    hitPixel.element = "white_blood_cell";
                    hitPixel.color = elements.white_blood_cell.color;
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBlood === true) {
                if (Math.random() > 0.9995 && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2020))) {
                    hitPixel.element = "white_blood_cell";
                    hitPixel.color = elements.white_blood_cell.color;
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: .001,
    tempHigh: 350,
    stateHigh: "cooked_meat",
    tempLow: -40,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 400,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
    hardness: 0.2,
    forceSaveColor: true,
	reactions: {
		"cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","meat","rotten_meat","cooked_meat","flesh"], chance:0.2 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    extinguish: true,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Makes bones and white blood cells!"
}

elements.cartilage = {
    color: "#DBDBDB",
    behavior: behaviors.WALL,
    nutrTrans: 10,
    oxygTrans: 15,
    isMultiDie: false,
    normDie: "quicklime",
    otherDie: "water",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioBone(pixel);
        doDefaults(pixel);
    },
    category:"structural",
    tempHigh: 200,
    stateHigh: ["calcium","glue","steam","steam","meat","steam",null],
    tempLow: -36,
    stateLow: ["calcium","calcium","meat","water","water","water",null],
    state: "solid",
    density: 1900,
    hardness: 0.05,
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    breakInto: ["quicklime","calcium","meat","meat","water","water",null],
    movable: false,
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    burn: 1,
    burnTime: 100,
    burnInto: ["bone","bone","bone","bone","quicklime"],
    desc: "Bones but slightly worse!"
}

elements.cerebrospinal_fluid = {
    color: "#CBC3E3",
    behavior: behaviors.LIQUID,
    ageRate: 0.975,
    nutrTrans: 30,
    oxygTrans: 35,
    tick: function(pixel) {
        if (pixel.nutrition === null || isNaN(pixel.nutrition)) {
            pixel.nutrition = 500
        }
        if (pixel.oxygen === null || isNaN(pixel.oxygen)) {
            pixel.oxygen = 500
        }
        if (pixel.speed === null || isNaN(pixel.speed)) {
            pixel.speed = 0
        }
        if (pixel.immune === true && pixel.poisoned != false) {
            pixel.poisoned = false
        }
        if ((pixel.temp > 66 || pixel.burning) && Math.random() > 0.95) {
            if (!pixel.burnt) { pixel.burnt = 1 }
            else { pixel.burnt ++ }
        }
        if (pixel.char != pixel.burnt && pixel.burnt > pixel.char || !pixel.char) {
            pixel.char = pixel.burnt
        }
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 15
                    pixel.oxygen -= 15
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 10
                    pixel.nutrition -= 10
                }
                if (hitPixel.speed < pixel.speed) {
                    hitPixel.speed += 1
                    pixel.speed -= 1
                }
                if (hitPixel.poisoned != true && pixel.poisoned == true) {
                    hitPixel.poisoned = true
                }
                if (hitPixel.immune != true && pixel.immune == true) {
                    hitPixel.poisoned = false
                    hitPixel.immune = true
                }
                if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burnt--
                }
                if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burning = false
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 15
                    pixel.oxygen -= 15
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 10
                    pixel.nutrition -= 10
                }
                if (hitPixel.speed < pixel.speed) {
                    hitPixel.speed += 1
                    pixel.speed -= 1
                }
                if (hitPixel.poisoned != true && pixel.poisoned == true) {
                    hitPixel.poisoned = true
                }
                if (hitPixel.immune != true && pixel.immune == true) {
                    hitPixel.poisoned = false
                    hitPixel.immune = true
                }
                if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burnt--
                }
                if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burning = false
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 15
                    pixel.oxygen -= 15
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 10
                    pixel.nutrition -= 10
                }
                if (hitPixel.speed < pixel.speed) {
                    hitPixel.speed += 1
                    pixel.speed -= 1
                }
                if (hitPixel.poisoned != true && pixel.poisoned == true) {
                    hitPixel.poisoned = true
                }
                if (hitPixel.immune != true && pixel.immune == true) {
                    hitPixel.poisoned = false
                    hitPixel.immune = true
                }
                if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burnt--
                }
                if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burning = false
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 15
                    pixel.oxygen -= 15
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 10
                    pixel.nutrition -= 10
                }
                if (hitPixel.speed < pixel.speed) {
                    hitPixel.speed += 1
                    pixel.speed -= 1
                }
                if (hitPixel.poisoned != true && pixel.poisoned == true) {
                    hitPixel.poisoned = true
                }
                if (hitPixel.immune != true && pixel.immune == true) {
                    hitPixel.poisoned = false
                    hitPixel.immune = true
                }
                if (hitPixel.burnt > 0 && (!pixel.burnt || pixel.burnt < hitPixel.burnt && pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burnt--
                }
                if (hitPixel.burning && (!pixel.burnt || pixel.burnt < 51) && Math.random() > 0.8) {
                    hitPixel.burning = false
                }
            }
        }
    },
    tempHigh: 102,
    stateHigh: ["steam","salt"],
    tempLow: -5,
    category: "nervous system",
    reactions: {
        "dust": { elem1: "dirty_water", elem2: null },
        "ash": { elem1: "dirty_water", elem2: null },
        "carbon_dioxide": { elem1: "dirty_water", elem2: null },
        "sulfur": { elem1: "dirty_water", elem2: null },
        "rat": { elem1: "dirty_water", chance:0.005 },
        "plague": { elem1: "dirty_water", elem2: null },
        "fallout": { elem1: "dirty_water", chance:0.25 },
        "radiation": { elem1: "dirty_water", chance:0.25 },
        "rust": { elem1: "dirty_water", chance:0.005 },
        "lead": { elem1: "dirty_water", chance:0.005 },
        "solder": { elem1: "dirty_water", chance:0.005 },
        "rock": { elem2: "wet_sand", chance: 0.0005 },
        "limestone": { elem2: "wet_sand", chance: 0.0005 },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cancer": { elem1: "dirty_water", chance:0.25 },
        "oil": { elem1: "dirty_water", chance:0.005 },
        "uranium": { elem1: "dirty_water", chance:0.25 },
        "wet_sand": { oneway:true, chance:0.007, func:function(pixel){
            if (isEmpty(pixel.x,pixel.y-1) || isEmpty(pixel.x,pixel.y-2) || isEmpty(pixel.x,pixel.y-3)) {
                changePixel(pixel,"foam");
                pixel.clone = "salt_water";
            }
        }},
        "salt_water": { elem2:"bubble", attr2:{"clone":"salt_water"}, chance:0.001, tempMin:85 },
        // electrolysis:
        "aluminum": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.0025 },
        "zinc": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.015 },
        "steel": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.0125 },
        "iron": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.0125 },
        "tin": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.01 },
        "brass": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.001 },
        "bronze": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.001 },
        "copper": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.0075 },
        "silver": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.0075 },
        "gold": { elem1:["hydrogen","hydrogen","oxygen","chlorine"], charged:true, chance:0.0075 },
    },
    state: "liquid",
    density: 1026,
    stain: -0.01,
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    extinguish: true,
    isBio: true,
    desc: "Liquid that doesnt die but transfers nutrients and oxygen! Part of a secret recipe."
}

elements.urine = {
    color: ["#E9BE3C","#D0B937"],
    behavior: behaviors.LIQUID,
    tempHigh: 102,
    stateHigh: ["steam","steam","steam","salt"],
    tempLow: -2,
    stateLowName: "pee_ice",
    category: "liquids",
    reactions: {
        "sand": { elem1:null, elem2:"wet_sand", chance: 0.02},
        "dust": { elem1: "dirty_water", elem2: null },
        "ash": { elem1: "dirty_water", elem2: null },
        "carbon_dioxide": { elem1: "dirty_water", elem2: null },
        "sulfur": { elem1: "dirty_water", elem2: null },
        "rat": { elem1: "dirty_water", chance:0.005 },
        "plague": { elem1: "dirty_water", elem2: null },
        "fallout": { elem1: "dirty_water", chance:0.25 },
        "radiation": { elem1: "dirty_water", chance:0.25 },
        "rust": { elem1: "dirty_water", chance:0.005 },
        "lead": { elem1: "dirty_water", chance:0.005 },
        "solder": { elem1: "dirty_water", chance:0.005 },
        "rock": { elem2: "wet_sand", chance: 0.0005 },
        "limestone": { elem2: "wet_sand", chance: 0.0005 },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cancer": { elem1: "dirty_water", chance:0.25 },
        "oil": { elem1: "dirty_water", chance:0.005 },
        "uranium": { elem1: "dirty_water", chance:0.25 },
        // electrolysis:
        "aluminum": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.0025 },
        "zinc": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.015 },
        "steel": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.0125 },
        "iron": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.0125 },
        "tin": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.01 },
        "brass": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.001 },
        "bronze": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.001 },
        "copper": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.0075 },
        "silver": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.0075 },
        "gold": { elem1:["hydrogen","hydrogen","oxygen","chlorine","salt"], charged:true, chance:0.0075 },
    },
    state: "liquid",
    density: 1006,
    conduct: 0.1,
    stain: 0.01,
    stainSelf: true,
    isWaste: true,
    extinguish: true,
    desc: "Pee."
}

elements.elixir = {
    color: "#8CB6AA",
    behavior: behaviors.LIQUID,
    reactions: {
        "dirt": { elem2: "mud", elem1: null },
        "dust": { elem1: "dirty_water", elem2: null },
        "ash": { elem1: "dirty_water", elem2: null },
        "carbon_dioxide": { elem1: "dirty_water", elem2: null },
        "sulfur": { elem1: "dirty_water", elem2: null },
        "rat": { elem1: "dirty_water", chance:0.005 },
        "plague": { elem1: "dirty_water", elem2: null },
        "fallout": { elem1: "dirty_water", chance:0.25 },
        "radiation": { elem1: "dirty_water", chance:0.25 },
        "rust": { elem1: "dirty_water", chance:0.005 },
        "lead": { elem1: "dirty_water", chance:0.005 },
        "solder": { elem1: "dirty_water", chance:0.005 },
        "rock": { elem2: "wet_sand", chance: 0.0005 },
        "limestone": { elem2: "wet_sand", chance: 0.0005 },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cancer": { elem1: "dirty_water", chance:0.25 },
        "oil": { elem1: "dirty_water", chance:0.005 },
        "uranium": { elem1: "dirty_water", chance:0.25 },
        "cerebrospinal_fluid": { elem1:"brain_jar_juice", elem2:"brain_jar_juice", chance:0.01 },
    },
    viscosity: 4000,
    tempHigh: 120,
    stateHigh: ["steam","steam","dna","dna","stench","salt",],
    tempLow: 0,
    category:"liquids",
    state: "liquid",
    density: 1450,
    stain: 0.05,
    hidden: true,
    desc: "Part of a secret recipe."
}

elements.brain_jar_juice = {
    color: "#4F8C24",
    behavior: behaviors.LIQUID,
    hidden: true,
    tick: function(pixel) {
        if (pixel.nutrition === null || isNaN(pixel.nutrition)) {
            pixel.nutrition = 500
        }
        if (pixel.oxygen === null || isNaN(pixel.oxygen)) {
            pixel.oxygen = 500
        }
        if (pixel.speed === null || isNaN(pixel.speed)) {
            pixel.speed = 0
        }
        if (pixel.immune === true && pixel.poisoned != false) {
            pixel.poisoned = false
        }
        if ((pixel.temp > 66 || pixel.burning) && Math.random() > 0.95) {
            if (!pixel.burnt) { pixel.burnt = 1 }
            else { pixel.burnt ++ }
        }
        if (pixel.char != pixel.burnt && pixel.burnt > pixel.char || !pixel.char) {
            pixel.char = pixel.burnt
        }
        if (!isEmpty(pixel.x, pixel.y-1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y-1]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 1
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 1
                }
            }
        }
        if (!isEmpty(pixel.x, pixel.y+1, true)) {
            var hitPixel = pixelMap[pixel.x][pixel.y+1]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 1
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 1
                }
            }
        }
        if (!isEmpty(pixel.x-1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x-1][pixel.y]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 1
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 1
                }
            }
        }
        if (!isEmpty(pixel.x+1, pixel.y, true)) {
            var hitPixel = pixelMap[pixel.x+1][pixel.y]
            if (elements[hitPixel.element].isBio === true && Math.random() > 0.5) {
                if (hitPixel.oxygen < pixel.oxygen) {
                    hitPixel.oxygen += 1
                }
                if (hitPixel.nutrition < pixel.nutrition) {
                    hitPixel.nutrition += 1
                }
            }
        }
    },
    tempHigh: 102,
    stateHigh: ["steam","steam","dna","dna","stench","salt",],
    tempLow: -5,
    category: "circulation",
    reactions: {
        "dust": { elem1: "dirty_water", elem2: null },
        "ash": { elem1: "dirty_water", elem2: null },
        "carbon_dioxide": { elem1: "dirty_water", elem2: null },
        "sulfur": { elem1: "dirty_water", elem2: null },
        "rat": { elem1: "dirty_water", chance:0.005 },
        "plague": { elem1: "dirty_water", elem2: null },
        "fallout": { elem1: "dirty_water", chance:0.25 },
        "radiation": { elem1: "dirty_water", chance:0.25 },
        "rust": { elem1: "dirty_water", chance:0.005 },
        "lead": { elem1: "dirty_water", chance:0.005 },
        "solder": { elem1: "dirty_water", chance:0.005 },
        "rock": { elem2: "wet_sand", chance: 0.0005 },
        "limestone": { elem2: "wet_sand", chance: 0.0005 },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cancer": { elem1: "dirty_water", chance:0.25 },
        "oil": { elem1: "dirty_water", chance:0.005 },
        "uranium": { elem1: "dirty_water", chance:0.25 },
        "wet_sand": { oneway:true, chance:0.007, func:function(pixel){
            if (isEmpty(pixel.x,pixel.y-1) || isEmpty(pixel.x,pixel.y-2) || isEmpty(pixel.x,pixel.y-3)) {
                changePixel(pixel,"foam");
                pixel.clone = "salt_water";
            }
        }},
        "brain_jar_juice": { elem2:"bubble", color2:"#81cf63", attr2:{"clone":"brain_jar_juice"}, chance:0.00005 },
    },
    state: "liquid",
    density: 1026,
    stain: -0.01,
    properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    extinguish: true,
    desc: "Made from a secret recipe with crushed fruit, cell slop and brain soup."
}

elements.bacteria = {
    color: "#769356",
    behavior: [
        "XX|SW:excrement,dirty_water,urine,infection%5 AND M2%0.5|M2%5 AND SW:excrement,dirty_water,urine,infection%5",
        "XX|FX%2|M2%5 AND SW:excrement,dirty_water,urine,infection%5 AND BO",
        "XX|M1 AND SW:excrement,dirty_water,urine,infection%5|M2%5 AND SW:excrement,dirty_water,urine,infection%5",
    ],
    reactions: {
        "sphincter": { elem2:null, chance:0.01, func:behaviors.FEEDPIXEL },
        "flesh": { elem2:null, chance:0.02, func:behaviors.FEEDPIXEL },
        "intestine": { elem2:null, chance:0.01, func:behaviors.FEEDPIXEL },
        "blood_vessel": { elem2:null, chance:0.02, func:behaviors.FEEDPIXEL },
        "dermis": { elem2:null, chance:0.02, func:behaviors.FEEDPIXEL },
        "scale_dermis": { elem2:null, chance:0.01, func:behaviors.FEEDPIXEL },
        "bug_dermis": { elem2:null, chance:0.01, func:behaviors.FEEDPIXEL },
        "lungs": { elem2:null, chance:0.02, func:behaviors.FEEDPIXEL },
        "rotten_meat": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "excrement": { elem2:[null,null,null,null,"excrement"], chance:0.05, func:behaviors.FEEDPIXEL },
        "rotten_cheese": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "cheese": { elem2:"rotten_cheese", chance:0.5, func:behaviors.FEEDPIXEL },
        "meat": { elem2:"rotten_meat", chance:0.5, func:behaviors.FEEDPIXEL },
        "cured_meat": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.01 },
        "dead_plant": { elem2:"dirt", chance:0.05, func:behaviors.FEEDPIXEL },
        "dead_bug": { elem2:null, chance:0.02, func:behaviors.FEEDPIXEL },
        "mercury": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "bleach": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "uranium": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "cyanide": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "chlorine": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.1 },
        "alcohol": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.25 },
        "water": { elem1:null, elem2:"dirty_water", chance:0.01 },
        "blood": { elem1:null, elem2:"infection", chance:0.01 },
        "salt_water": { elem1:null, elem2:"dirty_water", chance:0.01 },
        "sugar_water": { elem1:null, elem2:"dirty_water", chance:0.01, func:behaviors.FEEDPIXEL },
        "pool_water": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], elem2:"water", chance:0.005 },
        "vinegar": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.001 },
        "mouthwash": { elem1:[null,null,null,null,null,null,null,null,null,"dna"], chance:0.01 },
    },
    foodNeed: 15,
    egg: "bacteria",
    tempHigh: 100,
    stateHigh: ["dna","dna","dna","dna","dna","dna","carbon_dioxide","steam"],
    tempLow: 0,
    stateLow: "dna",
    breakInto: "dna",
    category:"life",
    burn:95,
    burnTime: 100,
    burnInto: ["dna","dna","dna","dna","dna","smoke","carbon_dioxide","steam"],
    state: "solid",
    density: 600,
    conduct: .1
}

elements.tract = {
    name: "bio-pipe",
    color: ["#7C4941","#83594C"],
    onSelect: function() {
        logMessage("Draw a pipe, wait for walls to appear, then erase the exit hole.");
    },
    nutrTrans: 25,
    oxygTrans: 30,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
        if (!pixel.stage && pixelTicks-pixel.start > 60) {
            for (var i = 0; i < squareCoords.length; i++) {
                var coord = squareCoords[i];
                var x = pixel.x+coord[0];
                var y = pixel.y+coord[1];
                if (!isEmpty(x,y,true) && elements[pixelMap[x][y].element].movable) {
                    deletePixel(x,y)
                }
                if (isEmpty(x,y)) {
                    createPixel("flesh",x,y);
                }
            }
            pixel.stage = 1;
        }
        else if (pixel.stage === 1 && pixelTicks-pixel.start > 70) { //uninitialized
            for (var i = 0; i < squareCoords.length; i++) {
                var coord = squareCoords[i];
                var x = pixel.x+coord[0];
                var y = pixel.y+coord[1];
                if (isEmpty(x,y)) {
                    pixel.stage = 2; //blue
                    pixel.color = pixelColorPick(pixel,"#552D3F");
                    break;
                }
            }
        }
        else if (pixel.stage > 1 && pixelTicks % 3 === pixel.stage-2) { //initialized
            for (var i = 0; i < squareCoords.length; i++) {
                var coord = squareCoords[i];
                var x = pixel.x+coord[0];
                var y = pixel.y+coord[1];
                if (!isEmpty(x,y,true) && pixelMap[x][y].element === "tract") {
                    var newPixel = pixelMap[x][y];
                    if (newPixel.stage === 1) {
                        var newColor;
                        switch (pixel.stage) {
                            case 2: newPixel.stage = 3; newColor = "#554B21"; break; //green
                            case 3: newPixel.stage = 4; newColor = "#66241B"; break; //red
                            case 4: newPixel.stage = 2; newColor = "#552D3F"; break; //blue
                        }
                        newPixel.color = pixelColorPick(newPixel,newColor);
                    }
                }
            }
            var moved = false;
            shuffleArray(squareCoordsShuffle);
            for (var i = 0; i < squareCoordsShuffle.length; i++) {
                var coord = squareCoordsShuffle[i];
                var x = pixel.x+coord[0];
                var y = pixel.y+coord[1];
                if (!isEmpty(x,y,true)) {
                    var newPixel = pixelMap[x][y];
                    if (newPixel.element === "tract") {
                        var nextStage;
                        switch (pixel.stage) {
                            case 2: nextStage = 4; break; //green
                            case 3: nextStage = 2; break; //red
                            case 4: nextStage = 3; break; //blue
                        }
                        if (pixel.con && !newPixel.con && newPixel.stage === nextStage && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) { //transfer to adjacent pipe
                            newPixel.con = pixel.con;
                            newPixel.con.x = newPixel.x;
                            newPixel.con.y = newPixel.y;
                            pixel.con = null;
                            moved = true;
                            break;
                        }
                    }
                    else if (!pixel.con && elements[newPixel.element].movable) { //suck up pixel
                        pixel.con = newPixel;
                        deletePixel(newPixel.x,newPixel.y);
                        pixel.con.x = pixel.x;
                        pixel.con.y = pixel.y;
                        pixel.con.del;
                        moved = true;
                        break;
                    }
                }
            }
            if (pixel.con && !moved && Math.random() > (1 - ((pixel.nutrition + pixel.oxygen + pixel.speed) / 2050))) { // move to same stage if none other
                for (var i = 0; i < squareCoordsShuffle.length; i++) {
                    var coord = squareCoordsShuffle[i];
                    var x = pixel.x+coord[0];
                    var y = pixel.y+coord[1];
                    if (isEmpty(x,y)) {
                        delete pixel.con.del;
                        pixel.con.x = x;
                        pixel.con.y = y;
                        pixelMap[x][y] = pixel.con;
                        currentPixels.push(pixel.con);
                        pixel.con = null;
                        break;
                    }
                    if (!isEmpty(x,y,true) && pixelMap[x][y].element === "tract") {
                        var newPixel = pixelMap[x][y];
                        if (pixel.con && !newPixel.con && newPixel.stage === pixel.stage) {
                            newPixel.con = pixel.con;
                            newPixel.con.x = newPixel.x;
                            newPixel.con.y = newPixel.y;
                            pixel.con = null;
                            break;
                        }
                    }
                }
            }
        }
    },
    category: "structural",
    movable: false,
    canContain: true,
    forceSaveColor: true,
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    desc: "Biological pipe!"
}

elements.biosensor = {
	color: ["#AD6770","#B0707D"],
	category: "nervous system",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        for (var i = 0; i < adjacentCoords.length; i++) {
            var coords = adjacentCoords[i];
            var x = pixel.x + coords[0];
            var y = pixel.y + coords[1];
            if (!isEmpty(x,y,true)) {
                var sensed = pixelMap[x][y];
                if (sensed.con || elements[sensed.element].movable && elements.biosensor.ignore.indexOf(sensed.element) === -1) {
                    pixel.charge = 5;
                    break;
                }
            }
        }
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    ignore: ["flash"],
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Biological sensor!"
}

elements.bioplate = {
	color: ["#AD6770","#B0707D"],
	category: "nervous system",
    behavior: behaviors.WALL,
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        if (!isEmpty(pixel.x, pixel.y-1, true)){
            if (pixel.min && elements[pixelMap[pixel.x][pixel.y-1].element].density < pixel.min) {}
            else if (pixelMap[pixel.x][pixel.y-1].element != "bioplate" || pixelMap[pixel.x][pixel.y-1].on) {
                pixel.on = true;
                var coordsToShock = [
                    [pixel.x, pixel.y+1],
                    [pixel.x+1, pixel.y],
                    [pixel.x-1, pixel.y],
                ]
                for (var i = 0; i < coordsToShock.length; i++) {
                    var x = coordsToShock[i][0];
                    var y = coordsToShock[i][1];
                    if (!isEmpty(x,y,true)) {
                        var newpixel = pixelMap[x][y];
                        if (elements[newpixel.element].conduct) {
                            newpixel.charge = 1;
                        }
                    }
                }
            }
        }
        else if (pixel.on) {
            pixel.on = false;
        }
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    ignore: ["flash"],
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Biological pressure plate!"
}

elements.biocloner = {
	color: ["#BE9247","#C09850"],
	category: "nervous system",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|BCF|XX",
        "BCF|XX|BCF",
        "XX|BCF|XX",
    ],
    nutrTrans: 20,
    oxygTrans: 25,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
        if (pixel.clone) { return }
        for (var i = 0; i < adjacentCoords.length; i++) {
            var coords = adjacentCoords[i];
            var x = pixel.x + coords[0];
            var y = pixel.y + coords[1];
            if (!isEmpty(x,y,true)) {
                pixel.temp = pixelMap[x][y].temp;
                if (pixelMap[x][y].clone) { pixel.clone = pixelMap[x][y].clone; break }
                var element = pixelMap[x][y].element;
                if (element === pixel.element || elements[pixel.element].ignore.indexOf(element) !== -1 && element !== "fuse") { continue }
                pixel.clone = element;
                break;
            }
        }
    },
    ignore: ["cloner","slow_cloner","clone_powder","floating_cloner","wire","ewall","sensor","battery","fuse","nerve","flesh"],
    ignoreConduct:["fuse"],
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Biological e-cloner! Turns its oxygen and nutrients into material through bio-synthesis."
}

elements.valve = {
	color: ["#A9436A","#B64F71"],
	category: "nervous system",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|DL:valve_extension|XX",
        "DL:valve_extension|XX|DL:valve_extension",
        "XX|DL:valve_extension|XX",
    ],
    nutrTrans: 30,
    oxygTrans: 35,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
        if (pixel.charge || !pixel.open) {
            pixel.openAge = 0
            pixel.open = true
        }
        if (pixel.open === true) {
            pixel.openAge++
        }
        if (pixel.openAge > 29) {
            for (var i = 0; i < adjacentCoords.length; i++) {
                var coords = adjacentCoords[i];
                var x = pixel.x + coords[0];
                var y = pixel.y + coords[1];
                if (isEmpty(x,y)) {
                    createPixel("valve_extension",x,y);
                    pixel.openAge = 0;
                    pixel.open = false;
                }
            }
        }
    },
    density: 2710,
    state: "solid",
    conduct: 1,
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    desc: "Power it to open, closes automatically."
}

elements.valve_extension = {
    name: "valve",
	color: ["#9e4839","#ba6449"],
	category: "nervous system",
    behavior: behaviors.WALL,
    nutrTrans: 40,
    oxygTrans: 45,
    isMultiDie: true,
    normDie: "meat",
    roomDie: "rotten_meat",
    coldDie: "frozen_meat",
    heatDie: "cooked_meat",
    hoverStat: function(pixel) {
        return "Ntr:"+pixel.nutrition+" O2:"+pixel.oxygen
    },
    tick: function(pixel) {
        doBioNorm(pixel);
        doDefaults(pixel);
    },
    density: 2710,
    state: "solid",
    tempHigh: 200,
    stateHigh: "cooked_meat",
    tempLow: -25,
    stateLow: "frozen_meat",
    burn: 5,
    burnTime: 350,
    burnInto: "cooked_meat",
    breakInto: ["blood","meat"],
	reactions: {
        "cancer": { elem1:"cancer", chance:0.0005 },
        "radiation": { elem1:["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 },
	},
	properties: {
        oxygen: 1000,
        nutrition: 1000,
        speed: 0,
        poisoned: false,
        immune: false,

    },
    isBio: true,
    renderer: renderPresets.FLESHBURN,
    movable: false,
    hidden: true,
    desc: "Valve gate."
}

elements.revive = {
    color: "#8BE73E",
    hidden: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tool: function(pixel) {
        if (elements[pixel.element].isBio == true) {
            if (pixel.nutrition < 2000 || pixel.oxygen < 2000) {
                if (pixel.nutrition < 2000) {
                    pixel.nutrition += 100
                }
                if (pixel.oxygen < 2000) {
                    pixel.oxygen += 100
                }
            }
            if (pixel.burning) {
                pixel.burning = false
            }
        }
        if (elements[pixel.element].id === elements.cancer.id) {
            changePixel(pixel,"flesh"); 
        }
        else if (elements[pixel.element].id === elements.bone.id) {
            changePixel(pixel,"real_bone"); 
        }
        else if (elements[pixel.element].id === elements.bone_marrow.id) {
            changePixel(pixel,"real_bone_marrow"); 
        }
        else if (elements[pixel.element].id === elements.skin.id) {
            changePixel(pixel,"epidermis"); 
        }
        else if (elements[pixel.element].id === elements.infected_vessel.id) {
            if (Math.random() < 0.95) {
                changePixel(pixel,"blood_vessel"); 
            }
            else {changePixel(pixel,"white_blood_cell"); }
        }
    },
    canPlace: false,
    category: "tools",
    desc: "Secret tool. Give your allies life!"
}

elements.drain_health = {
    color: "#AD1300",
    hidden: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tool: function(pixel) {
        if (elements[pixel.element].isBio == true) {
            if (pixel.nutrition > 10 || pixel.oxygen > 10) {
                if (pixel.nutrition > 10) {
                    pixel.nutrition -= 10
                }
                if (pixel.oxygen > 10) {
                    pixel.oxygen -= 10
                }
            }
        }
    },
    canPlace: false,
    category: "tools",
    desc: "Secret tool. Steal your enemies life!"
}

elements.death_ray = {
    color: ["#C33846","#930C00"],
    tick: function(pixel) {
        var x = pixel.x;
        for (var y = pixel.y+1; y < height+1; y++) {
            if (outOfBounds(x, y)) {
                if (isEmpty(x, y-1)) { 
                    if (Math.random() > 0.95) {
                        createPixel("poison_gas", x, y-1);
                    }
                    else if (Math.random() > 0.5) {
                        createPixel("plague", x, y-1);
                    }
                    else if (Math.random() > 0.25) {
                        createPixel("radiation", x, y-1);
                    }
                    else {
                        createPixel("foam", x, y-1);
                        pixelMap[x][y-1].color = "#930C00";
                    }
                }
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.1) { continue }
                createPixel("flash", x, y);
                pixelMap[x][y].color = "#C33846";
                pixelMap[x][y].delay = (y - pixel.y) / 8;
            }
            else {
                if (elements[pixelMap[x][y].element].id === elements.flash.id) { continue }
                if (elements[pixelMap[x][y].element].id === elements.death_ray.id) { break }
                if (!elements[pixelMap[x][y].element].isGas && isEmpty(x, y-1)) {
                    if (Math.random() > 0.95) {
                        createPixel("poison_gas", x, y-1);
                    }
                    else if (Math.random() > 0.95) {
                        createPixel("plague", x, y-1);
                    }
                    else if (Math.random() > 0.75) {
                        createPixel("radiation", x, y-1);
                    }
                    else {
                        createPixel("foam", x, y-1);
                        pixelMap[x][y-1].color = "#930C00";
                    }
                }
                if (Math.random() > 0.1) { continue }
                elements.drain_health.tool(pixelMap[x][y])
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    category: "energy",
    state: "gas",
    density: 1,
    excludeRandom: true,
    noMix: true,
},

elements.toilet = {
    color: "#e1e4dd",
    behavior: behaviors.WALL,
    category: "machines",
    state: "solid",
    density: 2403,
    hardness: 0.4,
    breakInto: ["porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","urine","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","excrement"],
    noMix: true,
    movable: false,
    tempHigh: 900,
    stateHigh: ["porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","urine","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","water","porcelain_shard","porcelain_shard","porcelain_shard","excrement"],
    tick: function(pixel) {
        var coords = rectCoords(pixel.x-1,pixel.y-1,pixel.x+1,pixel.y+3);
        for (var i = 0; i < coords.length; i++) { // Burn adjacent pixels
            var x = coords[i].x;
            var y = coords[i].y;
            if (!isEmpty(x,y,true)) {
                elements.toilet.tool(pixelMap[x][y]);
            }
        }
    },
    tool: function(pixel) {
        if (elements[pixel.element].isWaste === true || elements[pixel.element].id === elements.water.id) {
            deletePixel(pixel.x,pixel.y)
        }
    },
    canPlace: true,
    hidden: true,
} 

elements.ibuprofen = {
    category: "medicine",
    color: ["#c34a35","#c34a35","#c34a35","#ef866d","#993a2f","#993a2f","#c34a35","#c34a35","#c34a35"],
    state: "solid",
    behavior: behaviors.POWDER,
    tempHigh: 147,
    density: 980,
    stateHigh: ["oxygen","smoke","fire","ash","ash","dust","carbon_dioxide","oxygen","smoke","fire","ash","ash","dust","carbon_dioxide","oxygen","smoke","fire","ash","ash","dust","carbon_dioxide","sugar"],
    desc: "Helps with fevers, don't take more than 3 a day!"
}

elements.fentanyl = {
    category: "medicine",
    color: ["#d5edf3","#BFD3E5"],
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "water": { elem1:null, elem2:"dirty_water", chance:0.05 },
        "salt_water": { elem1:null, elem2:"dirty_water", chance:0.03 },
        "sugar_water": { elem1:null, elem2:"dirty_water", chance:0.03 },
        "seltzer": { elem1:null, elem2:"dirty_water", chance:0.04 },
	},
    tempHigh: 137.5,
    density: 1025,
    stateHigh: ["carbon_dioxide","smoke","smoke","smoke","fire","ash","ash","dust","carbon_dioxide"],
}

if (!elements.cancer.reactions) { elements.cancer.reactions = {} }
elements.cancer.reactions.attached_hair = { elem2: "loose_hair", chance:0.4 };
elements.cancer.reactions.hair_end = { elem2: "loose_hair", chance:0.4 };
elements.cancer.reactions.flesh = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.slimey_flesh = { elem2: ["slime","cancer"], chance:0.004 };
elements.cancer.reactions.acidic_flesh = { elem2: ["acid","cancer"], chance:0.004 };
elements.cancer.reactions.cloak_flesh = { elem2: "cancer", chance:0.004 };
elements.cancer.reactions.adipose = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.blood_vessel = { elem2: ["cancer","infected_vessel","infected_vessel","infected_vessel","infected_vessel"], chance:0.05 };
elements.cancer.reactions.white_blood_cell = { elem2: ["cancer","blood","blood_vessel","blood_vessel","infected_vessel"], chance:0.005 };
elements.cancer.reactions.heart = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.kidney = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.liver = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.dermis = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.amphib_dermis = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.scale_dermis = { elem2: "cancer", chance:0.004 };
elements.cancer.reactions.epidermis = { elem2: "cancer", chance:0.0002 };
elements.cancer.reactions.amphib_skin = { elem2: "cancer", chance:0.0003 };
elements.cancer.reactions.hairy_skin = { elem2: "cancer", chance:0.0003 };
elements.cancer.reactions.hair_dermis = { elem2: "cancer", chance:0.0003 };
elements.cancer.reactions.scales = { elem2: "cancer", chance:0.0001 };
elements.cancer.reactions.real_bone = { elem2: ["bone","bone","cancer"], chance:0.0001 };
elements.cancer.reactions.real_bone_marrow = { elem2: ["bone","cancer","cancer","cancer","cancer","cancer","cancer"], chance:0.0001 };
elements.cancer.reactions.lungs = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.simple_lung = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.gills = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.brain = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.nerve = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.olfactory_bulb = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.eye = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.sphincter = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.digested_material = { elem2: "cancer", chance:0.001 };
elements.cancer.reactions.intestines = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.stomach_valve = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.stomach_lining = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.herbi_stomach = { elem2: "cancer", chance:0.004 };
elements.cancer.reactions.carni_stomach = { elem2: "cancer", chance:0.004 };
elements.cancer.reactions.explosive_stomach = { elem2: ["pop","cancer","cancer","cancer"], chance:0.003 };
elements.cancer.reactions.biotorch = { elem2: ["cooked_meat","cancer","cancer","cancer"], chance:0.003 };
elements.cancer.reactions.biosensor = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.valve = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.valve_extension = { elem2: "cancer", chance:0.005 };
elements.cancer.reactions.throat_lining = { elem2: "cancer", chance:0.005 };

if (!elements.uranium.reactions) { elements.uranium.reactions = {} }
elements.uranium.reactions.attached_hair = { elem2: "loose_hair", chance:0.4 };
elements.uranium.reactions.hair_end = { elem2: "loose_hair", chance:0.4 };
elements.uranium.reactions.flesh = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.slimey_flesh = { elem2: ["ash","slime","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.uranium.reactions.acidic_flesh = { elem2: ["ash","acid","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.uranium.reactions.cloak_flesh = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.uranium.reactions.adipose = { elem2: ["ash","blood","fat","fat","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.blood_vessel = { elem2: ["ash","blood","blood","blood","blood","blood","infected_vessel","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.heart = { elem2: ["ash","blood","blood","blood","blood","blood","infected_vessel","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.kidney = { elem2: ["ash","blood","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.liver = { elem2: ["ash","blood","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.5 };
elements.uranium.reactions.amphib_dermis = { elem2: ["ash","blood","slime","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.5 };
elements.uranium.reactions.scale_dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.5 };
elements.uranium.reactions.bug_dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.5 };
elements.uranium.reactions.epidermis = { elem2: ["cooked_meat","cancer","ash","skin"], chance:0.1 };
elements.uranium.reactions.hairy_skin = { elem2: ["cooked_meat","cancer","ash","skin","hair"], chance:0.1 };
elements.uranium.reactions.hair_dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.5 };
elements.uranium.reactions.amphib_skin = { elem2: ["cooked_meat","cancer","ash","skin","slime"], chance:0.4 };
elements.uranium.reactions.scales = { elem2: ["cooked_meat","cancer","ash","epidermis","skin","dust","calcium"], chance:0.1 };
elements.uranium.reactions.exoskeleton = { elem2: ["cooked_meat","cancer","ash","epidermis","skin","dust","calcium"], chance:0.1 };
elements.uranium.reactions.real_bone = { elem2: ["bone","bone","radiation"], chance:0.01 };
elements.uranium.reactions.gills = { elem2: ["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.lungs = { elem2: ["ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.simple_lung = { elem2: ["ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.brain = { elem2: ["ash","steam","salt","meat","rotten_meat","cooked_meat","flesh","cerebrospinal_fluid"], chance:0.5 };
elements.uranium.reactions.amygdala = { elem2: ["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.nerve = { elem2: ["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.olfactory_bulb = { elem2: ["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.eye = { elem2: ["ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.sphincter = { elem2: ["ash","steam","excrement","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.intestines = { elem2: ["ash","steam","meat","rotten_meat","cooked_meat","flesh","ash","steam","meat","rotten_meat","cooked_meat","flesh","excrement"], chance:0.5 };
elements.uranium.reactions.stomach_valve = { elem2: ["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.stomach_lining = { elem2: ["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.herbi_stomach = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.carni_stomach = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.explosive_stomach = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh","pop"], chance:0.4 };
elements.uranium.reactions.throat_lining = { elem2: ["ash","slime","meat","rotten_meat","cooked_meat","flesh"], chance:0.5 };
elements.uranium.reactions.biotorch = { elem2: ["cancer","ash","steam","cooked_meat","rotten_meat","cooked_meat","flesh","fire"], chance:0.5 };
elements.uranium.reactions.biosensor = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.valve = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.uranium.reactions.valve_extension = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.5 };

if (!elements.radiation.reactions) { elements.radiation.reactions = {} }
elements.radiation.reactions.attached_hair = { elem2: "loose_hair", chance:0.4 };
elements.radiation.reactions.hair_end = { elem2: "loose_hair", chance:0.4 };
elements.radiation.reactions.flesh = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.slimey_flesh = { elem2: ["ash","slime","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.acidic_flesh = { elem2: ["ash","acid","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.cloak_flesh = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.adipose = { elem2: ["ash","blood","fat","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.blood_vessel = { elem2: ["ash","blood","blood","blood","blood","blood","infected_vessel","meat","rotten_meat","cooked_meat"], chance:0.4 };
elements.radiation.reactions.heart = { elem2: ["ash","blood","blood","blood","blood","infected_vessel","blood","meat","rotten_meat","cooked_meat"], chance:0.4 };
elements.radiation.reactions.kidney = { elem2: ["ash","blood","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.radiation.reactions.liver = { elem2: ["ash","blood","meat","rotten_meat","cooked_meat"], chance:0.5 };
elements.radiation.reactions.dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.amphib_dermis = { elem2: ["ash","blood","slime","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.scale_dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.scales = { elem2: ["cooked_meat","cancer","ash","epidermis","skin","dust","calcium"], chance:0.1 };
elements.radiation.reactions.exoskeleton = { elem2: ["cooked_meat","cancer","ash","epidermis","skin","dust","calcium"], chance:0.1 };
elements.radiation.reactions.bug_dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.epidermis = { elem2: ["cooked_meat","cancer","ash","skin"], chance:0.1 };
elements.radiation.reactions.hairy_skin = { elem2: ["cooked_meat","cancer","ash","skin","hair"], chance:0.1 };
elements.radiation.reactions.hair_dermis = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat","cancer","cancer"], chance:0.4 };
elements.radiation.reactions.amphib_skin = { elem2: ["cooked_meat","cancer","ash","skin","slime"], chance:0.1 };
elements.radiation.reactions.real_bone = { elem2: ["bone","bone","radiation"], chance:0.01 };
elements.radiation.reactions.gills = { elem2: ["ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.lungs = { elem2: ["cancer","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.simple_lung = { elem2: ["cancer","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","carbon_dioxide","meat","rotten_meat","cooked_meat","flesh","ash","oxygen","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.brain = { elem2: ["cancer","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh","cerebrospinal_fluid"], chance:0.4 };
elements.radiation.reactions.amygdala = { elem2: ["cancer","ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.nerve = { elem2: ["cancer","ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.olfactory_bulb = { elem2: ["cancer","ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.eye = { elem2: ["cancer","ash","steam","salt","ash","steam","salt","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.sphincter = { elem2: ["cancer","ash","steam","excrement","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.intestines = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh","ash","steam","meat","rotten_meat","cooked_meat","flesh","excrement"], chance:0.4 };
elements.radiation.reactions.stomach_valve = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.stomach_lining = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.herbi_stomach = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.carni_stomach = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.explosive_stomach = { elem2: ["cancer","ash","steam","meat","rotten_meat","cooked_meat","flesh","pop"], chance:0.3 };
elements.radiation.reactions.throat_lining = { elem2: ["cancer","ash","slime","meat","rotten_meat","cooked_meat","flesh"], chance:0.4 };
elements.radiation.reactions.biotorch = { elem2: ["cancer","ash","steam","cooked_meat","rotten_meat","cooked_meat","flesh","fire"], chance:0.4 };
elements.radiation.reactions.biosensor = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 };
elements.radiation.reactions.valve = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 };
elements.radiation.reactions.valve_extension = { elem2: ["ash","blood","fat","meat","rotten_meat","cooked_meat"], chance:0.4 };

if (!elements.plague.reactions) { elements.plague.reactions = {} }
elements.plague.reactions.attached_hair = { elem2: "loose_hair", chance:0.04 };
elements.plague.reactions.hair_end = { elem2: "loose_hair", chance:0.04 };
elements.plague.reactions.flesh = { elem2: ["rotten_meat","plague","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.slimey_flesh = { elem2: ["slime","slime","rotten_meat","plague","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.cloak_flesh = { elem2: ["rotten_meat","plague","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.acidic_flesh = { elem2: ["acid","rotten_meat","steam","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.adipose = { elem2: ["rotten_meat","plague","fat","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.blood_vessel = { elem2: ["rotten_meat","plague","meat","rotten_meat","plague","infected_vessel","infected_vessel","infected_vessel","infected_vessel","infected_vessel","infected_vessel"], chance:0.1 };
elements.plague.reactions.heart = { elem2: ["rotten_meat","plague","meat","rotten_meat","plague","infected_vessel","infection","infection","infection","infection","infection"], chance:0.04 };
elements.plague.reactions.kidney = { elem2: ["rotten_meat","plague","rotten_meat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.liver = { elem2: ["rotten_meat","plague","rotten_meat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.dermis = { elem2: ["rotten_meat","infection","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.hair_dermis = { elem2: ["rotten_meat","infection","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.hairy_skin = { elem2: ["plague","infection","rotten_meat","dust","dust","hair"], chance:0.04 };
elements.plague.reactions.amphib_dermis = { elem2: ["rotten_meat","infection","slime","meat","rotten_meat","plague","infection","infection"], chance:0.01 };
elements.plague.reactions.scale_dermis = { elem2: ["rotten_meat","infection","fat","meat","rotten_meat","plague","infection","infection"], chance:0.04 };
elements.plague.reactions.epidermis = { elem2: ["plague","infection","rotten_meat","dust","dust"], chance:0.01 };
elements.plague.reactions.amphib_skin = { elem2: ["plague","infection","rotten_meat","skin","slime"], chance:0.01 };
elements.plague.reactions.scales = { elem2: ["plague","infection","rotten_meat","dust","skin","calcium"], chance:0.01 };
elements.plague.reactions.real_bone = { elem2: ["bone","bone","infection","plague"], chance:0.01 };
elements.plague.reactions.gills = { elem2: ["infection","steam","meat","rotten_meat","plague","flesh","plague"], chance:0.05 };
elements.plague.reactions.lungs = { elem2: ["infection","rotten_meat","carbon_dioxide","meat","rotten_meat","plague","flesh","rotten_meat","carbon_dioxide","meat","rotten_meat","plague","flesh","rotten_meat","oxygen","meat","rotten_meat","plague","flesh"], chance:0.1 };
elements.plague.reactions.simple_lung = { elem2: ["infection","rotten_meat","carbon_dioxide","meat","rotten_meat","plague","flesh","rotten_meat","carbon_dioxide","meat","rotten_meat","plague","flesh","rotten_meat","oxygen","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.brain = { elem2: ["infection","rotten_meat","steam","salt","meat","rotten_meat","plague","flesh","cerebrospinal_fluid"], chance:0.04 };
elements.plague.reactions.amygdala = { elem2: ["infection","rotten_meat","steam","salt","rotten_meat","steam","salt","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.nerve = { elem2: ["infection","rotten_meat","steam","salt","rotten_meat","steam","salt","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.olfactory_bulb = { elem2: ["infection","rotten_meat","steam","salt","rotten_meat","steam","salt","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.eye = { elem2: ["infection","rotten_meat","steam","salt","rotten_meat","steam","salt","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.sphincter = { elem2: ["infection","rotten_meat","steam","excrement","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.intestines = { elem2: ["infection","rotten_meat","steam","meat","rotten_meat","plague","flesh","rotten_meat","steam","meat","rotten_meat","plague","flesh","excrement"], chance:0.04 };
elements.plague.reactions.stomach_valve = { elem2: ["infection","rotten_meat","steam","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.stomach_lining = { elem2: ["infection","rotten_meat","steam","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.herbi_stomach = { elem2: ["infection","rotten_meat","steam","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.carni_stomach = { elem2: ["infection","rotten_meat","steam","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.explosive_stomach = { elem2: ["infection","plague","steam","meat","rotten_meat","plague","flesh","pop"], chance:0.03 };
elements.plague.reactions.throat_lining = { elem2: ["infection","rotten_meat","slime","meat","rotten_meat","plague","flesh"], chance:0.04 };
elements.plague.reactions.biotorch = { elem2: ["infection","ash","steam","cooked_meat","rotten_meat","plague","plague","fire"], chance:0.04 };
elements.plague.reactions.biosensor = { elem2: ["infection","blood","fat","meat","rotten_meat","plague"], chance:0.04 };
elements.plague.reactions.valve = { elem2: ["infection","infection","fat","meat","rotten_meat","plague"], chance:0.04 };
elements.plague.reactions.valve_extension = { elem2: ["infection","infection","plague","meat","rotten_meat","plague"], chance:0.04 };

if (!elements.infection.reactions) { elements.infection.reactions = {} }
elements.infection.reactions.blood_vessel = { elem2: ["infection","infected_vessel","infected_vessel","infected_vessel","infected_vessel","infected_vessel","infected_vessel","infected_vessel"], chance:0.1 };
elements.infection.reactions.heart = { elem2: ["infection","infected_vessel","infection","infection","infection","infection","infected_vessel","infected_vessel"], chance:0.02 };

if (!elements.fly.reactions) { elements.infection.reactions = {} }
elements.fly.reactions.excrement = { elem2:[null,null,"stench"], chance:0.15, func:behaviors.FEEDPIXEL };

if (!elements.stench.reactions) { elements.infection.reactions = {} }
elements.stench.reactions.intestines = { elem1:[null,null,null,null,null,null,"foam"], chance:0.005, };
elements.stench.reactions.stomach_valve = { elem1:[null,null,null,null,null,null,"foam"], chance:0.015, };

elements.bless.reactions.excrement = { elem2:null }
elements.bless.reactions.infected_vessel = { elem2:["blood_vessel","blood_vessel","blood_vessel","blood_vessel","blood_vessel","blood_vessel","white_blood_cell"] }
elements.bless.reactions.urine = { elem2:"water" }
elements.bless.tool = function(pixel) {
    if (elements.bless.ignore.indexOf(pixel.element) !== -1) { return; }
    if (pixel.burning && !elements[pixel.element].burning) { // stop burning
        delete pixel.burning;
        delete pixel.burnStart;
    }
    if (!elements[pixel.element].insulate) {
        if (pixel.temp > 100) {
            pixel.temp = (pixel.temp+100)/2;
            pixelTempCheck(pixel);
            if (pixel.del) {return}
        }
        if (pixel.temp < -200) {
            pixel.temp = (pixel.temp-200)/2;
            pixelTempCheck(pixel);
            if (pixel.del) {return}
        }
    }
    if (pixel.origColor) {
        pixel.color = "rgb("+pixel.origColor.join(",")+")";
        delete pixel.origColor;
    }
    if (pixel.charge) {
        delete pixel.charge;
        pixel.chargeCD = 16;
    }
    if (elements.bless.reactions[pixel.element] && Math.random()<0.25) {
        var r = elements.bless.reactions[pixel.element];
        var elem2 = r.elem2;
        if (elem2 !== undefined) {
            if (Array.isArray(elem2)) { elem2 = elem2[Math.floor(Math.random()*elem2.length)]; }
            if (elem2 === null) { deletePixel(pixel.x,pixel.y) }
            else { changePixel(pixel, elem2); }
        }
        if (r.func) { r.func(pixel,pixel) }
        if (r.color2) { pixel.color = pixelColorPick(pixel,r.color2) }
    }
    if (elements[pixel.element].isBio == true) {
        if (pixel.nutrition < 2000 || pixel.oxygen < 2000) {
            if (pixel.nutrition < 2000) {
                pixel.nutrition += 100
            }
            if (pixel.oxygen < 2000) {
                pixel.oxygen += 100
            }
            if (pixel.speed < 0) {
                pixel.oxygen += 10
            }
        }
        if (pixel.burning) {
            pixel.burning = false
        }
    }
}

elements.dna.reactions.juice = { elem1: null, elem2: "elixir", chance:0.01 }

elements.dirty_water.isWaste = true;
elements.salt_water.isWaste = true;
elements.dirty_water.isWaste = true;

elements.acid.isAcid = true;


if (!elements.glass_shard.reactions) { elements.glass_shard.reactions = {} }
elements.glass_shard.reactions.intestines = { elem2: ["blood","blood","meat"], chance:0.001 }
elements.glass_shard.reactions.lungs = { elem2: ["blood","blood","meat"], chance:0.001 };
elements.glass_shard.reactions.simple_lung = { elem2:["blood","blood","meat"], chance:0.001 }
elements.glass_shard.reactions.flesh = { elem2: ["blood","meat","meat"], chance:0.0005 }
elements.glass_shard.reactions.blood_vessel = { elem2: ["meat","infected_vessel","blood","blood","blood","blood","blood"], chance:0.001 }
elements.glass_shard.reactions.epidermis = { elem2: ["dust","blood","blood","blood","blood","blood"], chance:0.0001 }
elements.glass_shard.reactions.dermis = { elem2: ["dust","blood","blood","blood","blood","blood"], chance:0.0001 }

if (!elements.rad_shard.reactions) { elements.rad_shard.reactions = {} }
elements.rad_shard.reactions.intestines = { elem2: ["blood","blood","meat"], chance:0.001 }
elements.rad_shard.reactions.lungs = { elem2: ["blood","blood","meat"], chance:0.001 }
elements.rad_shard.reactions.simple_lung = { elem2:["blood","blood","meat"], chance:0.001 }
elements.rad_shard.reactions.flesh = { elem2: ["blood","meat","meat"], chance:0.0005 }
elements.rad_shard.reactions.blood_vessel = { elem2: ["meat","infected_vessel","blood","blood","blood","blood","blood"], chance:0.001 }
elements.rad_shard.reactions.epidermis = { elem2: ["dust","blood","blood","blood","blood","blood"], chance:0.0001 }
elements.rad_shard.reactions.dermis = { elem2: ["dust","blood","blood","blood","blood","blood"], chance:0.0001 }

if (!elements.porcelain_shard.reactions) { elements.porcelain_shard.reactions = {} }
elements.porcelain_shard.reactions.intestines = { elem2: ["blood","blood","meat"], chance:0.0005 }
elements.porcelain_shard.reactions.lungs = { elem2: ["blood","blood","meat"], chance:0.0005 }
elements.porcelain_shard.reactions.simple_lung = { elem2:["blood","blood","meat"], chance:0.0005 }
elements.porcelain_shard.reactions.flesh = { elem2: ["blood","meat","meat"], chance:0.0001 }
elements.porcelain_shard.reactions.blood_vessel = { elem2: ["meat","infected_vessel","blood","blood","blood","blood","blood"], chance:0.0005 }
elements.porcelain_shard.reactions.epidermis = { elem2: ["dust","blood","blood","blood","blood","blood"], chance:0.00005 }
elements.porcelain_shard.reactions.dermis = { elem2: ["dust","blood","blood","blood","blood","blood"], chance:0.00005 }

if (!elements.metal_scrap.reactions) { elements.metal_scrap.reactions = {} }
elements.metal_scrap.reactions.intestines = { elem2: ["blood","meat"], chance:0.0005 }
elements.metal_scrap.reactions.lungs = { elem2: ["blood","meat"], chance:0.0005 }
elements.metal_scrap.reactions.simple_lung = { elem2:["blood","meat"], chance:0.0005 }
elements.metal_scrap.reactions.flesh = { elem2: ["blood","meat","meat"], chance:0.0001 }
elements.metal_scrap.reactions.blood_vessel = { elem2: ["meat","infected_vessel","blood","blood","blood","blood"], chance:0.0005 }

elements.vaccine.reactions.infected_vessel = { elem1: null, elem2: "blood_vessel", attr2:{"immune": true}, chance:0.02 }
elements.antidote.reactions.infected_vessel = { elem1: null, elem2: "blood_vessel", attr2:{"immune": true}, chance:0.02 }

elements.salt_water.stateHigh = ["steam","steam","salt"]

elements.vaccine.category = "medicine"
elements.antidote.category = "medicine"
elements.on_try_move_into_test = {
	color: "#ffffff",
	properties: {
		ticks: 0,
		attemptedMovesIntoPixel: 0,
	},	
	behavior: behaviors.POWDER,
	reactions: {
		"dirt": { elem1: "diamond" },
	},
	state: "solid",
	hidden: true,
	excludeRandom: true,
	category: "special",
	density: 1000,
	tick: function(pixel) {
		pixel.ticks++;
	},
	onTryMoveInto: function(pixel,otherPixel) {
		pixel.attemptedMovesIntoPixel++;
		var otherElement = otherPixel.element;
		if(otherElement === "ash") {
		console.log(`This is a test of potentially undesired multiplicate running. (tick: ${pixelTicks}, move attempts: ${pixel.attemptedMovesIntoPixel})`);
			//if(deletePixel(pixel.x,pixel.y)) {
			//	console.log("This pixel has been deleted.");
			//};
		};
	},
	desc: "Try burying this pixel and see what happens. (Use Debug)\n\nonTryMoveInto is run as part of tryMove, <em>before reactions</em>, while tick functions are run as part of pixelDraw.\n<span style='color:red;'>In some circumstances, such as a pixel being buried under a pile of anything that isn't a sturdy powder, this function may run multiple times per tick.</span> For example, bury this pixel in ash and look in the console.\n\nTo use this function, include in your element definition the \"onTryMoveInto\" key with a function value, similarly to tick functions. This function takes two arguments; \"otherPixel\" is the pixel that is trying to move and \"pixel\" is the pixel whose position otherPixel is trying to move into.",
	related: ["debug", "ash"],
}

function tryMove(pixel,nx,ny,leaveBehind,force) {
	if (pixel.drag && !force) { return true; }
	var info = elements[pixel.element];
	var oob = outOfBounds(nx,ny);
	if (isEmpty(nx,ny,false,oob)) { // If coords is empty, move to coords
		//console.log(`Moving ${pixel.element} (${pixel.x},${pixel.y}) to (${nx},${ny})`);
		movePixel(pixel,nx,ny,leaveBehind);
		return true;
	}
	else if (!oob) {
		//console.log(`Moving ${pixel.element} (${pixel.x},${pixel.y}) to (${nx},${ny})`);
		// Reactions
		newPixel = pixelMap[nx][ny];
		var newInfo = elements[newPixel.element];
		var returnVal = false;
		if(newInfo.onTryMoveInto !== undefined) {
			newInfo.onTryMoveInto(newPixel,pixel);
			if(!pixel || pixel.del) {
				return "deleted";
			};
			returnVal = true;
		}
		var rr1 = false;
		if (info.reactions !== undefined && info.reactions[newPixel.element] !== undefined) {
			rr1 = reactPixels(pixel,newPixel)
			if (rr1) {
				return true;
			}
		}
		if (!rr1 && elements[newPixel.element].reactions !== undefined && elements[newPixel.element].reactions[pixel.element] !== undefined && !elements[newPixel.element].reactions[pixel.element].oneway) {
			if (reactPixels(newPixel,pixel)) {
				return true;
			}
		}
		// Density
		if (elements[pixel.element].id !== elements[newPixel.element].id) {
			if (info.density !== undefined && elements[newPixel.element].density !== undefined) {
				// if the pixel's state + ">" + newPixel's state is in validDensitySwaps, and the pixel's density is larger than the newPixel's density, swap the pixels
				if (validDensitySwaps[info.state][elements[newPixel.element].state] && info.density >= elements[newPixel.element].density) {
					// chance depending on the difference in density
					if (Math.random() < (info.density - elements[newPixel.element].density)/(info.density + elements[newPixel.element].density)) {
						swapPixels(pixel,newPixel);
						return true;
					}
				}
			}
		}
		if(returnVal) {
			return true;
		}
	}
	return false;
}
var modName = "mods/human_edit.js";
var onTryMoveIntoMod = "mods/onTryMoveInto.js";
if(typeof(breakPixel) == "undefined") {
	function breakPixel(pixel,changetemp=false,defaultBreakIntoDust=false) {
		var info = elements[pixel.element];
		if(typeof(info.breakInto) === "undefined") {
			if(defaultBreakIntoDust) {
				if(Math.random() < defaultBreakIntoDust) { changePixel(pixel,"dust",changetemp) };
			};
			return defaultBreakIntoDust;
		};
		var breakIntoElement = info.breakInto;
		if(Array.isArray(breakIntoElement)) {
			breakIntoElement = breakIntoElement[Math.floor(Math.random() * breakIntoElement.length)]
		};
		changePixel(pixel,breakIntoElement,changetemp)
		return true
	}
};

function hasPixel(x,y,elementInput) {
	if(isEmpty(x,y,true)) { //if empty, it can't have a pixel
		return false;
	} else {
		if(elementInput.includes(",")) { //CSTA
			elementInput = elementInput.split(",");
		};
		if(Array.isArray(elementInput)) { //if element list
			return elementInput.includes(pixelMap[x][y].element);
		} else { //if single element
			return pixelMap[x][y].element === elementInput;
		};
	};		
};

if(enabledMods.includes(onTryMoveIntoMod)) {
	elements.brain = {
		color: ["#fce3e3","#deb6c5","#f5ced5","#e87b8f"],
		behavior: [
			"XX|XX|XX",
			"XX|CH:rotten_meat%1|XX",
			"M2|M1|M2",
		],
		reactions: {
			"dirty_water": { "elem1":"rotten_meat", "chance":0.1 },
			"fly": { "elem1":"rotten_meat", "chance":0.2 },
			"dioxin": { "elem1":"rotten_meat", "elem2":null, "chance":0.1 },
			"uranium": { "elem1":"rotten_meat", "chance":0.1 },
			"cancer": { "elem1":"rotten_meat", "chance":0.1 },
			"plague": { "elem1":"rotten_meat", "elem2":null, "chance":0.3 },
			"ant": { "elem1":"rotten_meat", "chance":0.1 },
			"worm": { "elem1":"rotten_meat", "chance":0.1 },
			"rat": { "elem1":"rotten_meat", "chance":0.3 },
			"mushroom_spore": { "elem1":"rotten_meat", "chance":0.1 },
			"mushroom_stalk": { "elem1":"rotten_meat", "chance":0.1 },
			"mercury": { "elem1":"rotten_meat", "elem2":null, "chance":0.2 },
			"mercury_gas": { "elem1":"rotten_meat", "elem2":null, "chance":0.1 },
			"virus": { "elem1":"rotten_meat", "chance":0.1 },
			"poison": { "elem1":"rotten_meat", "elem2":null, "chance":0.5 },
			"infection": { "elem1":"rotten_meat", "elem2":null, "chance":0.1 },
			"ink": { "elem1":"rotten_meat", "elem2":null, "chance":0.1 },
			"acid": { "elem1":"rotten_meat", "elem2":null, "chance":0.5 },
			"acid_gas": { "elem1":"rotten_meat", "chance":0.4 },
			"cyanide": { "elem1":"rotten_meat", "elem2":null, "chance":0.5 },
		},
		tempHigh: 100,
		stateHigh: "cooked_meat",
		tempLow: -18,
		stateLow: "frozen_meat",
		category:"life",
		hidden: true,
		breakInto: ["meat", "blood"],
		burn:10,
		burnTime:200,
		burnInto:["cooked_meat","steam","steam","salt"],
		state: "solid",
		density: 1081,
		conduct: 1,
	};

	elements.cerebrospinal_fluid = {
		color: "#ced7db",
		behavior: behaviors.LIQUID,
		state: "liquid",
		tempHigh: 100,
		stateHigh: "steam",
		breakInto: "steam",
		reactions: JSON.parse(JSON.stringify(elements.water.reactions)),
	};

	function validatePanic(pixel) {
		//console.log(`validatePanic: validatePanic called on pixel ${pixel.element} at (${pixel.x},${pixel.y}) with panic level ${pixel.panic || 0}`);
		if(pixel.element.endsWith("body")) {
			//console.log("validatePanic called on body pixel (panic is stored in the head)");
		};
		if(Number.isNaN(pixel.panic)) {
			//console.log("NaN case: panic set to 0");
			pixel.panic = 0;
		};
		//console.log(`Bounding code running from value of ${pixel.panic}`);
		pixel.panic = Math.max(0,Math.min(1,pixel.panic));
		//console.log(`Validation result: Panic set to ${pixel.panic}`);

		if(Number.isNaN(pixel.mood)) {
			//console.log("NaN case: panic set to 0");
			pixel.mood = 0;
		};
		//console.log(`Bounding code running from value of ${pixel.panic}`);
		pixel.mood = Math.max(-3,Math.min(3,pixel.mood));
		//console.log(`Validation result: Panic set to ${pixel.panic}`);
	};

	goodPixels = {
		silver: { panicChange: 0.01, panicChangeChance: 0.1, moodChange: 0.004 },
		gold: { panicChange: 0.02, panicChangeChance: 0.15, moodChange: 0.01 },
		diamond: { panicChange: 0.03, panicChangeChance: 0.2, moodChange: 0.02 },
	}; //effectively, the difference is that good pixels don't make the human flip direction (run away);
	badPixels = {
		rotten_meat: { panicChange: 0.02, panicChangeChance: 0.15, moodChange: -0.015 },
		blood: { panicChange: 0.06, panicChangeChance: 0.2, moodChange: -0.006 },
		brain: { panicChange: 0.1, panicChangeChance: 0.3, moodChange: -0.005 },
		fire: { panicChange: 0.1, panicChangeChance: 0.1, moodChange: 0 },
		poison: { panicChange: 0.2, panicChangeChance: 0.05, moodChange: -0.01 },
		grenade: { panicChange: 0.2, panicChangeChance: 0.4, moodChange: -0.3 },
		bomb: { panicChange: 0.2, panicChangeChance: 0.4, moodChange: -0.3 },
		tnt: { panicChange: 0.2, panicChangeChance: 0.4, moodChange: 0 },
		dynamite: { panicChange: 0.2, panicChangeChance: 0.4, moodChange: -0.3 },
		anti_bomb: { panicChange: 0.2, panicChangeChance: 0.4, moodChange: -0.3 },
		cluster_bomb: { panicChange: 0.2, panicChangeChance: 0.4, moodChange: -0.4 },
		landmine: { panicChange: 0.25, panicChangeChance: 0.1, moodChange: -0.3 },
		fireball: { panicChange: 0.25, panicChangeChance: 0.45, moodChange: -0.35 },
		magma: { panicChange: 0.3, panicChangeChance: 0.2, moodChange: 0 },
		plasma: { panicChange: 0.3, panicChangeChance: 0.2, moodChange: 0 },
		nuke: { panicChange: 1, panicChangeChance: 1, moodChange: -1 }, //insta-panic
		cluster_nuke: { panicChange: 1, panicChangeChance: 1, moodChange: -1 }, //insta-panic
	}; //testing
	otherPixels = ["head","body"]; //do custom code here

	var initialTransparencyArray = ["glass","water","salt_water","sugar_water","steam","oxygen","nitrogen","neon","methane","propane","anesthesia","ammonia","carbon_dioxide","helium","hydrogen","ozone","radiation","pool_water"];
	for(transparentElementIndex = 0; transparentElementIndex < initialTransparencyArray.length; transparentElementIndex++) {
		var transparentElement = initialTransparencyArray[i];
		if(typeof(elements[transparentElement]) !== "undefined") {
			elements[transparentElement].transparent = true;
		};
	};

	elements.body.properties = {
		dead: false,
		dir: 1,
		extremePanicStart: null,
	};
	elements.body.tick = function(pixel) {
		if(typeof(pixel.extremePanicStart) == "undefined") {
			//console.log("oops");
			pixel.extremePanicStart = null
		};
		if (tryMove(pixel, pixel.x, pixel.y+1)) { // Fall
			if (!isEmpty(pixel.x, pixel.y-2, true)) { // Drag head down
				var headpixel = pixelMap[pixel.x][pixel.y-2];
				if (headpixel.element == "head") {
					if (isEmpty(pixel.x, pixel.y-1)) {
						movePixel(pixelMap[pixel.x][pixel.y-2], pixel.x, pixel.y-1);
					}
					else {
						swapPixels(pixelMap[pixel.x][pixel.y-2], pixelMap[pixel.x][pixel.y-1]);
					}
				}
			}
		}
		doHeat(pixel);
		doBurning(pixel);
		doElectricity(pixel);
		if (pixel.dead) {
			// Turn into rotten_meat if pixelTicks-dead > 500
			if (pixelTicks-pixel.dead > 200) {
				changePixel(pixel,"rotten_meat");
			}
			return
		}

		// Find the head
		if (!isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "head") {
			var head = pixelMap[pixel.x][pixel.y-1];
			if (head.dead) { // If head is dead, kill body
				pixel.dead = head.dead;
			}
		}
		else { var head = null }

		if (isEmpty(pixel.x, pixel.y-1)) {
			// create blood if decapitated 10% chance
			if (Math.random() < 0.1) {
				createPixel("blood", pixel.x, pixel.y-1);
				// set dead to true 15% chance
				if (Math.random() < 0.15) {
					pixel.dead = pixelTicks;
				}
			}
		}
		if (head == null) { return };
		
		if (Math.random() < (0.1 + head.panic)) { // Move 10% chance, varying depending on panic value
			var movesToTry = [
				[1*pixel.dir,0],
				[1*pixel.dir,-1],
			];
			// While movesToTry is not empty, tryMove(pixel, x, y) with a random move, then remove it. if tryMove returns true, break.
			while (movesToTry.length > 0) {
				var move = movesToTry.splice(Math.floor(Math.random() * movesToTry.length), 1)[0];
				/*
				console.log(move);
				console.log("Body X:", pixel.x, "to", pixel.x+move[0]);
				console.log("Body Y:", pixel.y, "to", pixel.y+move[1]);
				console.log("Head X:",head.x, "to", head.x+move[0]);
				console.log("Head Y:", head.y, "to", head.y+move[1]);
				*/
				//If head coords are empty
				if (isEmpty(pixel.x+move[0], pixel.y+move[1]) && isEmpty(head.x+move[0], head.y+move[1])) {
					//console.log("Head target coords are empty");
					if (tryMove(pixel, pixel.x+move[0], pixel.y+move[1])) {
						movePixel(head, head.x+move[0], head.y+move[1]);
						//console.log(`Moved body to (${pixel.x},${pixel.y}) and head to (${head.x},${head.y})`);
						//console.log(`Head-body offset (should always be [0,-1]): [${head.x-pixel.x},${head.y-pixel.y}]`)
						break;
					}
				}
			}
			// 15% chance to change direction
			if(!head.dirLocked) {
				if (Math.random() < 0.15) {
					pixel.dir *= -1;
					//console.log("*turns around cutely to face ${pixel.dir < 0 ? 'left' : 'right'}*");
				};
			};
		};	

		//if not flagged for extreme panic
		//extreme panic will not be flagged in good moods, just to be nice
		if(pixel.extremePanicStart == null && head.panic > 0.8 && head.mood <= 0) {
			//flag extreme panic
			pixel.extremePanicStart = pixelTicks;
		}
		//if flagged for extreme panic and panic is still extreme
		else if(pixel.extremePanicStart != null && (head.panic > 0.8 && head.mood <= 0)) {
			//if extreme panic lasts too long
			if(pixelTicks - pixel.extremePanicStart > 350) {
				//random chance to die from exhaustion/a heart attack/whatever
				if(Math.random() < 0.01) {
					pixel.dead = true;
				};
			};
		}
		//if flagged for extreme panic and extreme panic is no longer extreme
		else if(pixel.extremePanicStart != null && (head.panic <= 0.8 || head.mood > 0)) {
			//unflag
			pixel.extremePanicStart = null;
		};
		
	};

	elements.body.onTryMoveInto = function(pixel,otherPixel) {
		var pX = pixel.x;
		var pY = pixel.y;
		if(!pixel.dead && hasPixel(pX,pY-1,"head")) { //if this body pixel is alive and has a head
			var head = pixelMap[pX][pY-1];
			var otherElement = otherPixel.element;
			var oX = otherPixel.x;
			var oY = otherPixel.y;
			if(oY !== (pY - 1)) { //exclude the head above this body
				if(otherElement === "head") { //if the pixel hitting this body is a head
					if(hasPixel(oX,oY+1,"body")) { //if the pixel hitting this pixel has a body under it
						var otherBody = pixelMap[oX][oY+1];
						if(otherPixel.dead || otherBody.dead) { //if either part of that human is dead
							head.panic += 0.08; //being hit by a dead ******* body is terrifying
						} else {
							if(otherPixel.panic > 0.04 && otherPixel.mood <= 0) { head.panic += 0.04 }; //living, normal, bodied heads scare only if that incoming human is already scared
						};
					} else { //if it's a severed head
						if(otherPixel.dead) { //if the head is dead
							head.panic += 0.08; //being hit by a /severed ******* head/ is terrifying
						} else {
							head.panic += 0.1; //being hit by a //******* severed head that's still alive// is even worse
						};					
					};
				} else if(otherElement === "body") { //if the pixel hitting this body is a body
					if(hasPixel(oX,oY-1,"head")) { //if the pixel hitting this pixel has a head on it
						var otherHead = pixelMap[oX][oY-1];
						if(otherPixel.dead || otherHead.dead) { //if either part of that human is dead
							head.panic += 0.06; //dead whole body case
						} else {
							if(otherHead.panic > 0.04) { head.panic += 0.04 }; //living, normal, bodied heads scare only if that incoming human is already scared
						};
					} else { //severed body case
						if(otherPixel.dead) { //if the body is dead
							head.panic += 0.08; //imagine being hit by a severed human without the head
						} else {
							head.panic += 0.1; //imagine the above but the heart is still beating
						};
					};
				};
			};
		};
	};

	elements.head.properties = {
		dead: false,
		dirLocked: false,
		panic: 0,
	};

	elements.head.tick = function(pixel) {
		doHeat(pixel);
		doBurning(pixel);
		doElectricity(pixel);
		if (pixel.dead) {
			// Turn into rotten_meat if pixelTicks-dead > 500
			if (pixelTicks-pixel.dead > 200) {
				changePixel(pixel,"rotten_meat");
				return
			}
		}

		// Find the body
		if (!isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "body") {
			var body = pixelMap[pixel.x][pixel.y+1];
			if (body.dead) { // If body is dead, kill head
				pixel.dead = body.dead;
			}
		}
		else { var body = null }

		if (isEmpty(pixel.x, pixel.y+1)) {
			tryMove(pixel, pixel.x, pixel.y+1);
			// create blood if severed 10% chance
			if (isEmpty(pixel.x, pixel.y+1) && !pixel.dead && Math.random() < 0.1) {
				createPixel("blood", pixel.x, pixel.y+1);
				// set dead to true 15% chance
				if (Math.random() < 0.15) {
					pixel.dead = pixelTicks;
				}
			}
		}
		
		pixel.mood ??= 0;

		if((pixelTicks-pixel.start) % 5 === 0) {
			//Vision loop
			var pX = pixel.x;
			var pY = pixel.y;
			if(pixel.dir === -1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = (-1); j > (-16 - 1); j--) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(Object.keys(goodPixels).includes(newElement)) {
								//no dir flip
								if(Math.random() > goodPixels[newElement].panicChangeChance) {
									pixel.panic += goodPixels[newElement].panicChange;
									pixel.mood += goodPixels[newElement].moodChange; //like if there was a pretty painting item, it would make you feel better but you wouldn't necessarily feel the need to run towards it
								};
								pixel.dirLocked = true;
							} else if(Object.keys(badPixels).includes(newElement)) {
								body.dir = 1; //flip dir
								if(Math.random() > badPixels[newElement].panicChangeChance) {
									pixel.panic += badPixels[newElement].panicChange;
									pixel.mood += badPixels[newElement].moodChange;
								};
								pixel.dirLocked = true;
							}; //good and bad should be mutually exclusive; good will be evaulated first because one inevitably has to be considered first
							if(otherPixels.includes(newElement)) {
								//specific custom code
								if(newElement === "head") {
									if(hasPixel(nX,nY+1,"body")) {
										var newBody = pixelMap[nX][nY+1];
										if(newPixel.dead || newBody.dead) {
											pixel.panic += 0.02;	//if it's seeing a whole human, it's likely to see the dead head and the dead body, thus double-executing
																	//it would be nice if there was a way to avoid double/multiple detection of the same human
											if(hasPixel(pX,pY+1,"body")) { //mix error-proofing
												var body = pixelMap[pX][pY+1];
												body.dir = 1; //run away
											};
										} else {
											if(newPixel.panic > 0.04) {
												if(newPixel.panic > 0.8) {
													pixel.panic += 0.015; //it will add up
												} else if(newPixel.panic > 0.6) {
													pixel.panic += 0.012;
												} else if(newPixel.panic > 0.4) {
													pixel.panic += 0.009;
												} else if(newPixel.panic > 0.2) {
													pixel.panic += 0.006;
												} else {
													pixel.panic += 0.003;
												};
												
												//the vision loop is in the head, and this is in the "seeing head" case, then this will happen when the head sees another head, and heads store panic; this is in the "other head" is panicking case so this will ultimately be the code that runs when its human sees another human panicking
												if(Math.random() < 0.5) {
													//run in same direction as panicking person
													pixel.dir = newPixel.dir
												};
											};
										};
									} else { //severed head
										newPixel.dead ? pixel.panic += 0.03 : pixel.panic += 0.04;
										if(hasPixel(pX,pY+1,"body")) {
											var body = pixelMap[pX][pY+1];
											body.dir = 1; //run away
										};
									};
								} else if(newElement === "body") {
									if(hasPixel(nX,nY-1,"head")) {
										var newHead = pixelMap[nX][nY-1];
										if(newPixel.dead || newHead.dead) {
											pixel.panic += 0.02;
											if(hasPixel(pX,pY+1,"body")) {
												var body = pixelMap[pX][pY+1];
												body.dir = 1; //run away
											};
										} else {
											if(newHead.panic > 0.04) {
												if(newHead.panic > 0.8) {
													pixel.panic += 0.014; //it will add up
												} else if(newHead.panic > 0.6) {
													pixel.panic += 0.011;
												} else if(newHead.panic > 0.4) {
													pixel.panic += 0.008;
												} else if(newHead.panic > 0.2) {
													pixel.panic += 0.005;
												} else {
													pixel.panic += 0.002;
												};
											};
										};
									} else { //severed body
										newPixel.dead ? pixel.panic += 0.025 : pixel.panic += 0.035;
										if(hasPixel(pX,pY+1,"body")) { //mix error-proofing
											var body = pixelMap[pX][pY+1];
											body.dir = 1; //run away
										};
									};
								};
							};
							//code outside of those three if blocks will be applied to pixels of all elements
							if(!elements[newElement].transparent) {
								break; //can't see through humans
							};
						};
					};
				};
			} else if(pixel.dir === 1) {
				for(i = -4; i < 4+1; i++) {
					var oY = i;
					//console.log(`Starting row look at row ${pY+oY}`)
					for(j = 1; j < 16 + 1; j++) {
						var oX = j;
						var nX = pX+oX;
						var nY = pY+oY;
						if(outOfBounds(nX,nY)) {
							//console.log(`Stopping row look at pixel (${nX},${nY}) due to OoB`)
							break;
						};
						if(isEmpty(nX,nY)) {
							//console.log(`Skipping pixel (${nX},${nY}) (empty)`)
							continue;
						};
						if(!isEmpty(nX,nY,true)) {
							var newPixel = pixelMap[nX][nY];
							var newElement = newPixel.element;
							if(Object.keys(goodPixels).includes(newElement)) {
								//no dir flip
								if(Math.random() > goodPixels[newElement].panicChangeChance) {
									pixel.panic += goodPixels[newElement].panicChange;
									pixel.mood += goodPixels[newElement].moodChange;
								};
								pixel.dirLocked = true;
							} else if(Object.keys(badPixels).includes(newElement)) {
								if(hasPixel(pX,pY+1,"body")) {
									var body = pixelMap[pX][pY+1];
									body.dir = -1; //run away
								};
								if(Math.random() > badPixels[newElement].panicChangeChance) {
									pixel.panic += badPixels[newElement].panicChange;
									pixel.mood += badPixels[newElement].moodChange;
								};
								pixel.dirLocked = true;
							}; //good and bad should be mutually exclusive; good will be evaulated first because one inevitably has to be considered first
							if(otherPixels.includes(newElement)) {
								if(newElement === "head") {
									if(hasPixel(nX,nY+1,"body")) {
										var newBody = pixelMap[nX][nY+1];
										if(newPixel.dead || newBody.dead) {
											pixel.panic += 0.02;	//if it's seeing a whole human, it's likely to see the dead head and the dead body, thus double-executing
																	//it would be nice if there was a way to avoid double/multiple detection of the same human
											if(hasPixel(pX,pY+1,"body")) {
												var body = pixelMap[pX][pY+1];
												body.dir = -1; //run away
											};
										} else {
											if(newPixel.panic > 0.04) {
												if(newPixel.panic > 0.8) {
													pixel.panic += 0.015; //it will add up
												} else if(newPixel.panic > 0.6) {
													pixel.panic += 0.012;
												} else if(newPixel.panic > 0.4) {
													pixel.panic += 0.009;
												} else if(newPixel.panic > 0.2) {
													pixel.panic += 0.006;
												} else {
													pixel.panic += 0.003;
												};
											};
										};
									} else { //severed head
										newPixel.dead ? pixel.panic += 0.03 : pixel.panic += 0.04;
										if(hasPixel(pX,pY+1,"body")) {
											var body = pixelMap[pX][pY+1];
											body.dir = -1; //run away
										};
									};
								} else if(newElement === "body") {
									if(hasPixel(nX,nY-1,"head")) {
										var newHead = pixelMap[nX][nY-1];
										if(newPixel.dead || newHead.dead) {
											pixel.panic += 0.02;
											if(hasPixel(pX,pY+1,"body")) {
												var body = pixelMap[pX][pY+1];
												body.dir = -1; //run away
											};
										} else {
											if(newHead.panic > 0.04) {
												if(newHead.panic > 0.8) {
													pixel.panic += 0.014; //it will add up
												} else if(newHead.panic > 0.6) {
													pixel.panic += 0.011;
												} else if(newHead.panic > 0.4) {
													pixel.panic += 0.008;
												} else if(newHead.panic > 0.2) {
													pixel.panic += 0.005;
												} else {
													pixel.panic += 0.002;
												};
											};
										};
									} else { //severed body
										newPixel.dead ? pixel.panic += 0.025 : pixel.panic += 0.035;
										if(hasPixel(pX,pY+1,"body")) {
											var body = pixelMap[pX][pY+1];
											body.dir = -1; //run away
										};
									};
								};
							};
							//code outside of those three if blocks will be applied to pixels of all elements
							if(!elements[newElement].transparent) {
								break; //can't see through humans
							};
						};
					};
				};
			};
		};

		validatePanic(pixel);

		if(Math.random() < 0.01) { //1% chance each tick to lose interest
			pixel.dirLocked = false;
			//console.log("Meh.");
		};

		if(Math.random() < ((pixel.panic) > 0.8 ? 0.04 : 0.02)) { //2% chance each tick to decrease panic (4% if the panic is extreme)
			//console.log("Decreasing panic");
			pixel.panic < 0.05 ? pixel.panic = 0 : pixel.panic -= 0.05;
		};

	};
	elements.head.breakInto = ["bone","brain","brain","cerebrospinal_fluid","blood","blood","meat"];

	elements.head.onTryMoveInto = function(pixel,otherPixel) {
		var pX = pixel.x;
		var pY = pixel.y;
		if(!pixel.dead) {
			var otherElement = otherPixel.element;
			var oX = otherPixel.x;
			var oY = otherPixel.y;
			if(oY !== (pY + 1)) { //exclude the body under this head
				if(otherElement === "head") { //if the pixel hitting this head is also a head
					//console.log("head.onTryMoveInto: Head has tried to move into head");
					if(hasPixel(oX,oY+1,"body")) { //if the pixel hitting this pixel has a body under it
						var otherBody = pixelMap[oX][oY+1];
						if(otherPixel.dead || otherBody.dead) { //if either part of that human is dead
							pixel.panic += 0.08; //being hit by a dead ******* body is terrifying
							//console.log("head.onTryMoveInto: panic increase, case: head hit by dead whole body (head's code branch)");
						} else {
							//if(otherPixel.panic > 0.04) { pixel.panic += 0.04; console.log("head.onTryMoveInto: panic increase, case: head hit by panicked whole body (head's code branch)"); }; //living, normal, headed bodies scare only if that incoming human is already scared
						};
					} else { //if it's a severed head
						if(otherPixel.dead) { //if the head is dead
							pixel.panic += 0.08; //being hit by a /severed ******* head/ is terrifying
							//console.log("head.onTryMoveInto: panic increase, case: head hit by dead severed head");
						} else {
							pixel.panic += 0.1; //being hit by a //******* severed head that's still alive// is even worse
							//console.log("head.onTryMoveInto: panic increase, case: head hit by living severed head");
						};					
					};
				} else if(otherElement === "body") { //if the pixel hitting this head is a body
					if(hasPixel(oX,oY-1,"head")) { //if the body hitting this pixel has a head on it
						var otherHead = pixelMap[oX][oY-1];
						if(otherPixel.dead || otherHead.dead) { //if either part of that human is dead
							pixel.panic += 0.03; //dead whole body case
							//console.log("head.onTryMoveInto: panic increase, case: head hit by dead whole body (body's code branch)");
						} else {
							if(otherHead.panic > 0.04) {
								pixel.panic += 0.03;
								//console.log("head.onTryMoveInto: panic increase, case: head crushed by panicked whole body (body's code branch)");
							} else {
								pixel.panic += 0.02;
								//console.log("head.onTryMoveInto: panic increase, case: head crushed by whole body (body's code branch)");
							};
						};
					} else { //severed body case
						if(otherPixel.dead) { //if the body is dead
							pixel.panic += 0.04; //imagine being hit by a severed human without the head
							//console.log("head.onTryMoveInto: panic increase, case: head hit by dead severed body");
						} else {
							pixel.panic += 0.05; //imagine the above but the heart is still beating
							//console.log("head.onTryMoveInto: panic increase, case: head hit by living severed body");
						};
					};
				} else {
					if(oX === pX && oY === pY-1) {
						var otherInfo = elements[otherElement];
						var otherState; typeof(otherInfo.state) === "undefined" ? otherState = null : otherState = otherInfo.state;
						var otherDensity = typeof(otherInfo.density) === "undefined" ? otherDensity = null : otherDensity = otherInfo.density;
						if(otherState === "solid") {
							if(otherDensity > 5000) {
								var chance = (0.1 + (otherDensity/50000)) / 5;
								if(Math.random() < chance) {
									breakPixel(pixel);
								};
							} else if(otherDensity >= 500) {
								pixel.panic += (0.01 * (otherDensity / 500));
							} else if(otherDensity >= 100) {
								pixel.panic += (0.001 * (otherDensity / 100));
							};
						};
					};
				};
			};
		};
	};

	//Worldgen preset for testing

	worldgentypes.basalt_dirt = {
		layers: [
			[0, "basalt", 0.05],
			[0, "dirt"]
		]
	};

	kep1er = [
		["first_impact",	["#664482","#cf4ba3","#c15ca9","#f0a669"]],
		["doublast",		["#2b98fd","#d0e26d","#e6f049","#dce4b3"]],
		["fly-up",			["#f2f2f2","#15a667","#de0180"]],
		["troubleshooter",	["#291923","#ed3fb6","#fee6f8","#64c5e0","#d6cdca","#330d25"]],
		["fly-by",			["#e7e6dd","#fcf0ef","#efa1ba","#8d7cb6","#5e74ba","#2b5db5","#e292b7"]],
		["lovestruck",		["#bfd9f0","#bfd9f0","#fef792","#c36475","#edd1d6"]],
	];
	
	for(index in kep1er) {
		index = parseInt(index);
		var newName = kep1er[index][0];
		var newColor = kep1er[index][1];
		var newDisplayName = newName.replaceAll("_"," ").replaceAll("-"," - ").split(" ").map(x => x.substring(0,1).toUpperCase() + x.substring(1)).join(" ").replace(" - ","-");
		elements[newName] = {
			name: newDisplayName,
			color: newColor,
			tempHigh: 200,
			stateHigh: ["ash","molten_plastic"],
			density: 332, //based off of First Impact: https://www.amazon.com/Kep1er-IMPACT-Contents-Tracking-Connect/dp/B09MQMNZ62
			tick: function(pixel) {
				if(!(tryMove(pixel,pixel.x,pixel.y+1))) {
					var directions = [];
					if(isEmpty(pixel.x-1,pixel.y+1) && isEmpty(pixel.x-1,pixel.y+2)) {
						directions.push(-1)
					};
					if(isEmpty(pixel.x+1,pixel.y+1) && isEmpty(pixel.x+1,pixel.y+2)) {
						directions.push(1)
					};
					if(directions.length > 0) {
						tryMove(pixel,pixel.x+directions[Math.floor(Math.random() * directions.length)],pixel.y)
					};
				}
			},
			reactions: {
				water: { elem1: ["plastic","cellulose","cellulose"], elem2: ["water","water","cellulose",null,null], chance: 0.8 }
			},
			burn: 40,
			burnTime: 150,
			burnInto: ["ash","molten_plastic","carbon_dioxide","smoke"],
			category: "other"
		};
		
		goodPixels[newName] = { panicChange: 0.01, panicChangeChance: 0.2, moodChange: 0.035 };
	};
	
} else {
	enabledMods.splice(enabledMods.indexOf(modName),0,onTryMoveIntoMod)
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
	alert(`The ${onTryMoveIntoMod} mod is required and has been automatically inserted (reload for this to take effect).`)
};
/* by nekonico, do not steal!!!!!! >:3*/

elements.organism = {
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2%10|M1|M2%10",
    ],
    color: ["#997457","#a89a76"],
    properties: {
      geneticCode: 0,
      oldvore: 0,
      vore: 0,
      food: 0,
      age: 0,
      dead: false
    },
    tick: function(pixel) {
      if (pixel.vore != pixel.oldvore) {
      if (pixel.vore === 0) {
          if (Math.random() > 0.5) {
            pixel.color = "#997457"
          }
          else {
            pixel.color = "#a89a76"
          }
      }
      else if (pixel.vore === 1) {
        if (Math.random() > 0.5) {
            pixel.color = "#9E6954"
        }
        else {
            pixel.color = "#AB8C6B"
        }
      }
      else if (pixel.vore === 2) {
        if (Math.random() > 0.5) {
            pixel.color = "#A25F50"
        }
        else {
            pixel.color = "#AF7E61"
        }
      }
      else if (pixel.vore === 3) {
        if (Math.random() > 0.5) {
            pixel.color = "#A7544D"
        }
        else {
            pixel.color = "#B27056"
        }
      }
      else if (pixel.vore === 4) {
        if (Math.random() > 0.5) {
            pixel.color = "#A7544D"
        }
        else {
            pixel.color = "#B5624B"
        }
      }
      else if (pixel.vore === 5) {
        if (Math.random() > 0.5) {
            pixel.color = "#AC4A4A"
        }
        else {
            pixel.color = "#B85440"
        }
      }
      else if (pixel.vore === 6) {
        if (Math.random() > 0.5) {
            pixel.color = "#B03F47"
        }
        else {
            pixel.color = "#BC4636"
        }
      }
      else if (pixel.vore === 7) {
        if (Math.random() > 0.5) {
            pixel.color = "#B53543"
        }
        else {
            pixel.color = "#BF382B"
        }
      }
      else if (pixel.vore === 8) {
        if (Math.random() > 0.5) {
            pixel.color = "#B92A40"
        }
        else {
            pixel.color = "#C22A20"
        }
      }
      else if (pixel.vore > 8) {
        if (Math.random() > 0.5) {
            pixel.color = "#BE203D"
        }
        else {
            pixel.color = "#C51C15"
        }
      }
      else if (pixel.vore === -1) {
        if (Math.random() > 0.5) {
            pixel.color = "#8B7C4F"
        }
        else {
            pixel.color = "#9D9A6B"
        }
      }
      else if (pixel.vore === -2) {
        if (Math.random() > 0.5) {
            pixel.color = "#7D8447"
        }
        else {
            pixel.color = "#939A61"
        }
      }
      else if (pixel.vore === -3) {
        if (Math.random() > 0.5) {
            pixel.color = "#6F8C3F"
        }
        else {
            pixel.color = "#889A56"
        }
      }
      else if (pixel.vore === -4) {
        if (Math.random() > 0.5) {
            pixel.color = "#619437"
        }
        else {
            pixel.color = "#7D9A4B"
        }
      }
      else if (pixel.vore === -5) {
        if (Math.random() > 0.5) {
            pixel.color = "#539C2F"
        }
        else {
            pixel.color = "#739A40"
        }
      }
      else if (pixel.vore === -6) {
        if (Math.random() > 0.5) {
            pixel.color = "#46A428"
        }
        else {
            pixel.color = "#689936"
        }
      }
      else if (pixel.vore === -7) {
        if (Math.random() > 0.5) {
            pixel.color = "#38AC20"
        }
        else {
            pixel.color = "#5E992B"
        }
      }
      else if (pixel.vore === -8) {
        if (Math.random() > 0.5) {
            pixel.color = "#2AB418"
        }
        else {
            pixel.color = "#539920"
        }
      }
      else if (pixel.vore < -8) {
        if (Math.random() > 0.5) {
            pixel.color = "#1CBC10"
        }
        else {
            pixel.color = "#489915"
        }
      }
      }
      if (pixel.food > 0 && Math.random() > 0.99) {
        pixel.food -= 1;
      }
      else if (pixel.food < 1 && pixel.age > 1000 && Math.random() > 0.99) {
        pixel.dead = true;
      }
      if (pixel.geneticCode < 11) {
        if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
            deletePixel(pixel.x, pixel.y-1);
            pixel.food += 1
        }
        else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
            deletePixel(pixel.x+1, pixel.y);
            pixel.food += 1
        }
        else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
            deletePixel(pixel.x-1, pixel.y);
            pixel.food += 1
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                changePixel(pixel,"sugar"); 
            }
            else if (Math.random() > 0.5) {
                changePixel(pixel,"dna"); 
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 10 && pixel.geneticCode < 21) {
        if (isEmpty(pixel.x, pixel.y+1)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x, pixel.y+1);
        }
        else if (Math.random() > 0.99 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.99 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
            deletePixel(pixel.x, pixel.y-1);
            pixel.food += 1
        }
        if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sugar") {
            deletePixel(pixel.x, pixel.y+1);
            pixel.food += 1
        }
        else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
            deletePixel(pixel.x+1, pixel.y);
            pixel.food += 1
        }
        else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
            deletePixel(pixel.x-1, pixel.y);
            pixel.food += 1
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                changePixel(pixel,"sugar"); 
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 20 && pixel.geneticCode < 31) {
        if (Math.random() > 0.95 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.95 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sugar") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2 ) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                changePixel(pixel,"sugar"); 
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 30 && pixel.geneticCode < 41) {
        if (Math.random() > 0.9 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.9 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sugar") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
           /* by nekonico, do not steal!!!!!! >:3*/ if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            } 
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 40 && pixel.geneticCode < 51) {
        if (Math.random() > 0.9 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.9 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sugar") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 50 && pixel.geneticCode < 61) {
        if (Math.random() > 0.8 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.8 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sugar") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fly") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fly") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fly") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fly") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "ant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "ant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "ant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "ant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
    }
    else if (pixel.geneticCode > 60 && pixel.geneticCode < 71) {
        if (Math.random() > 0.8 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.8 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sugar") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sugar") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sugar") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sugar") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fly") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fly") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fly") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fly") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "ant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "ant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "ant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "ant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "egg") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "egg") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "egg") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "egg") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "wood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "wood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "wood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "wood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
    }
    else if (pixel.geneticCode > 70 && pixel.geneticCode < 81) {
        if (Math.random() > 0.75 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.75 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && elements[pixelMap[pixel.x][pixel.y-1].element].isFood) {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && elements[pixelMap[pixel.x][pixel.y+1].element].isFood) {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && elements[pixelMap[pixel.x+1][pixel.y].element].isFood) {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && elements[pixelMap[pixel.x-1][pixel.y].element].isFood) {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fly") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fly") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fly") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fly") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "ant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "ant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "ant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "ant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "egg") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "egg") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "egg") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "egg") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bird") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bird") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bird") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bird") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fish") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fish") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fish") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fish") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "wood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "wood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "wood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "wood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "vine") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "vine") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "vine") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "vine") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "cactus") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "cactus") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "cactus") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "cactus") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.95) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.05) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.95) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.05) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.95) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.05) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 80 && pixel.geneticCode < 91) {
        if (Math.random() > 0.75 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.75 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && elements[pixelMap[pixel.x][pixel.y-1].element].isFood) {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && elements[pixelMap[pixel.x][pixel.y+1].element].isFood) {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && elements[pixelMap[pixel.x+1][pixel.y].element].isFood) {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && elements[pixelMap[pixel.x-1][pixel.y].element].isFood) {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fly") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fly") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fly") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fly") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "ant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "ant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "ant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "ant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "egg") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "egg") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "egg") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "egg") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bird") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bird") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bird") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bird") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fish") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fish") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fish") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fish") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "head") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "head") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "head") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "head") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "body") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "body") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "body") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "body") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "wood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "wood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "wood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "wood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "vine") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "vine") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "vine") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "vine") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "cactus") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "cactus") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "cactus") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "cactus") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "petal") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "petal") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "petal") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "petal") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "pistil") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "pistil") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "pistil") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "pistil") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.95) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.05) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.95) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.05) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.95) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.05) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 90 && pixel.geneticCode < 101) {
        if (Math.random() > 0.75 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.75 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && elements[pixelMap[pixel.x][pixel.y-1].element].isFood) {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && elements[pixelMap[pixel.x][pixel.y+1].element].isFood) {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && elements[pixelMap[pixel.x+1][pixel.y].element].isFood) {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && elements[pixelMap[pixel.x-1][pixel.y].element].isFood) {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fly") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fly") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fly") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fly") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "ant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "ant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "ant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "ant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "egg") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "egg") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "egg") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "egg") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bird") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bird") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bird") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bird") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fish") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fish") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fish") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fish") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "head") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "head") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "head") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "head") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "body") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "body") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "body") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "body") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bone") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bone") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bone") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bone") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "blood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "blood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "blood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "blood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "wood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "wood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "wood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "wood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "vine") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "vine") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "vine") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "vine") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "cactus") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "cactus") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "cactus") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "cactus") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "petal") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "petal") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "petal") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "petal") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "pistil") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "pistil") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "pistil") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "pistil") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sapling") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sapling") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sapling") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sapling") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "pinecone") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "pinecone") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "pinecone") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "pinecone") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.995) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.005) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.995) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.005) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.995) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.005) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
      }
      else if (pixel.geneticCode > 100) {
        if (Math.random() > 0.75 && isEmpty(pixel.x-1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x-1, pixel.y);
        }
        else if (Math.random() > 0.75 && isEmpty(pixel.x+1, pixel.y)) {
            movePixel(pixelMap[pixel.x][pixel.y], pixel.x+1, pixel.y);
        }
        if (pixel.vore > -3 && pixel.vore < 3) {
            changePixel(pixel,"human");
        }
        else if (pixel.vore > 2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rotten_meat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rotten_meat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fly") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fly") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fly") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fly") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "ant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "ant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "ant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "ant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "egg") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "egg") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "egg") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "egg") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "rat") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "rat") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "rat") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "rat") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bird") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bird") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bird") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bird") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "fish") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "fish") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "fish") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "fish") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "head") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "head") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "head") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "head") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "body") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "body") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "body") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "body") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bone") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bone") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bone") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bone") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "blood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "blood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "blood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "blood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        else if (pixel.vore < -2) {
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "grass") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "grass") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "grass") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "grass") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "dead_plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "dead_plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "plant") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "plant") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "plant") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "plant") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "tree_branch") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "tree_branch") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "wood") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "wood") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "wood") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "wood") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "bamboo") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "bamboo") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "vine") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "vine") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "vine") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "vine") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "cactus") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "cactus") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "cactus") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "cactus") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "petal") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "petal") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "petal") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "petal") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "pistil") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "pistil") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "pistil") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "pistil") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "sapling") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "sapling") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "sapling") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "sapling") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
            if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y-1, true) && pixelMap[pixel.x][pixel.y-1].element == "pinecone") {
                deletePixel(pixel.x, pixel.y-1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x, pixel.y+1, true) && pixelMap[pixel.x][pixel.y+1].element == "pinecone") {
                deletePixel(pixel.x, pixel.y+1);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x+1, pixel.y, true) && pixelMap[pixel.x+1][pixel.y].element == "pinecone") {
                deletePixel(pixel.x+1, pixel.y);
                pixel.food += 1
            }
            else if (Math.random() < 0.1 && !isEmpty(pixel.x-1, pixel.y, true) && pixelMap[pixel.x-1][pixel.y].element == "pinecone") {
                deletePixel(pixel.x-1, pixel.y);
                pixel.food += 1
            }
        }
        if (isEmpty(pixel.x, pixel.y-1) && pixel.food > 10) {
            createPixel("organism", pixel.x, pixel.y-1);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.995) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.005) {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x][pixel.y-1].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x+1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x+1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.995) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.005) {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x+1][pixel.y].vore = pixel.vore;
            }
        }
        else if (isEmpty(pixel.x-1, pixel.y) && pixel.food > 10) {
            createPixel("organism", pixel.x-1, pixel.y);
            pixel.food -= 5;
            if (Math.random() > 0.8) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode += 1;
            }
            if (Math.random() < 0.2) {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].geneticCode = pixel.geneticCode;
            }
            if (Math.random() > 0.995) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore += 1;
            }
            if (Math.random() < 0.005) {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore -= 1;
            }
            else {
                pixelMap[pixel.x-1][pixel.y].vore = pixel.vore;
            }
        }
        if (pixel.age > 10000 || pixel.dead === true) {
            if (Math.random() > 0.3) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"rotten_meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"dead_plant"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
            else if (Math.random() > 0.5) {
                if (pixel.vore > 0) {
                    changePixel(pixel,"meat"); 
                }
                else if (pixel.vore < 0) {
                    changePixel(pixel,"grass"); 
                }
                else if (pixel.vore === 0) {
                    changePixel(pixel,"sugar"); 
                }
            }
        }
        pixel.age += 1
      }
      pixel.oldvore = pixel.vore
    }, 
    reactions: {
        "cancer": { elem1:"cancer", chance:0.005 },
        "radiation": { elem1:["ash","grass","meat","cooked_meat","dead_plant","dna","sugar"], chance:0.4, func:function(pixel) {
            if (pixel1.vore > 2) {
                changePixel(pixel,"cooked_meat");
            }
            else if (pixel1.vore < -2) {
                changePixel(pixel,"dead_plant");
            }
            else if (pixel1.vore > -3 && pixel1.vore < 3) {
                changePixel(pixel,"ash");
            }
        }},
    },
    burn: 10,
    burnTime: 250,
    burnInto: ["cooked_meat","dead_plant","dna","sugar"],
    tempHigh: 150,
    stateHigh: ["cooked_meat","dead_plant","dna","sugar"],
    tempLow: -50,
    stateLow: ["frozen_meat","frozen_plant","dna","sugar"],
    breakInto: ["rotten_meat","dead_plant","dna","sugar"],
    category: "organism",
    state: "solid",
    density: 1050
}

elements.food_pill = {
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.vore > 2) {
                pixel2.food += 2
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore < -2) {
                pixel2.food += 2
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore > -3 && pixel2.vore < 3) {
                pixel2.food += 5
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
        }},
    }, 
    category: "organism",
    state: "solid",
    color: ["#2b1107","#5c3322","#2b1107","#5c3322","#2b1107","#5c3322"],
    tempHigh: 250,
    stateHigh: ["sugar","cooked_meat","smoke","smoke","smoke","dead_plant","smoke","smoke","smoke","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["sugar","cooked_meat","smoke","smoke","smoke","dead_plant","smoke","smoke","smoke","stench"],
    breakInto: ["sugar","cooked_meat","dead_plant","dust","dust","dust","dust","dust","dust","dust","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#2b1107","#5c3322","#5c3322","#5c3322","#5c3322","#5c3322","#5c3322","#5c3322","#41770B","#774C35"],
    isFood: true
}

elements.pacifism_pill = {
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.vore > 0) {
                pixel2.vore -= 1
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore < 0) {
                pixel2.vore -= 1
                pixel2.food += 1
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore === 0) {
                pixel2.vore -= 1
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
        }},
    },
    category: "organism",
    state: "solid",
    color: ["#58AA38","#58AA38","#3D6D4B","#316232","#6CA65A","#58AA38","#3D6D4B","#316232","#58AA38","#58AA38","#3D6D4B","#316232"],
    tempHigh: 250,
    stateHigh: ["molten_plastic","dead_plant","smoke","smoke","smoke","dead_plant","smoke","smoke","smoke","stench","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["molten_plastic","dead_plant","smoke","smoke","smoke","dead_plant","smoke","smoke","smoke","stench","stench"],
    breakInto: ["dead_plant","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#6CA65A","#58AA38","#6CA65A","#6CA65A"],
    isFood: true
}

elements.neutrality_pill = {
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.vore > 0) {
                pixel2.vore -= 1
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore < 0) {
                pixel2.vore += 1
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore === 0) {
                pixel2.food += 1
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
        }},
    },
    category: "organism",
    state: "solid",
    color: ["#c5dede","#c5dede","#464196","#2E2B64","#a4b3b3","#c5dede","#464196","#2E2B64","#c5dede","#c5dede","#464196","#2E2B64"],
    tempHigh: 250,
    stateHigh: ["molten_plastic","sugar","smoke","smoke","smoke","sugar","smoke","smoke","smoke","stench","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["molten_plastic","sugar","smoke","smoke","smoke","sugar","smoke","smoke","smoke","stench","stench"],
    breakInto: ["sugar","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#a4b3b3","#c5dede","#a4b3b3","#a4b3b3"],
    isFood: true
}

elements.aggression_pill = {
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.vore > 0) {
                pixel2.vore += 1
                pixel2.food += 1
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore < 0) {
                pixel2.vore += 1
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.vore === 0) {
                pixel2.vore += 1
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.9) {
                    pixel2.geneticCode += 1
                };
            }
        }},
    },
    category: "organism",
    state: "solid",
    color: ["#B13E3E","#B13E3E","#8E122A","#870C1C","#A83232","#B13E3E","#8E122A","#870C1C","#B13E3E","#B13E3E","#8E122A","#870C1C"],
    tempHigh: 250,
    stateHigh: ["molten_plastic","cooked_meat","smoke","smoke","smoke","cooked_meat","smoke","smoke","smoke","stench","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["molten_plastic","cooked_meat","smoke","smoke","smoke","cooked_meat","smoke","smoke","smoke","stench","stench"],
    breakInto: ["cooked_meat","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#A83232","#B13E3E","#A83232","#A83232"],
    isFood: true
}

elements.growth_pill = {
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.vore > 0) {
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.99) {
                    pixel2.vore += 1
                };
                pixel2.geneticCode += 1
            }
            else if (pixel2.vore < 0) {
                if (Math.random() > 0.8) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.99) {
                    pixel2.vore -= 1
                };
                pixel2.geneticCode += 1
            }
            else if (pixel2.vore === 0) {
                if (Math.random() > 0.75) {
                    pixel2.food += 1
                };
                pixel2.geneticCode += 1
            }
        }},
    },
    category: "organism",
    state: "solid",
    color: ["#ECF4B0","#ECF4B0","#D1D099","#CBCA8C","#D2D9A6","#ECF4B0","#D1D099","#CBCA8C","#ECF4B0","#ECF4B0","#D1D099","#CBCA8C"],
    tempHigh: 250,
    stateHigh: ["molten_plastic","sugar","smoke","smoke","smoke","herb","smoke","smoke","smoke","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["molten_plastic","sugar","smoke","smoke","smoke","herb","smoke","smoke","smoke","stench"],
    breakInto: ["sugar","dust","dust","dust","dust","dust","dust","herb","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#D2D9A6","#ECF4B0","#D2D9A6","#D2D9A6"],
    isFood: true
}

elements.antiaging_pill = {
    name: "anti-aging_pill",
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.age > 99) {
                pixel2.age -= 100;
                if (Math.random() > 0.999) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.995) {
                    pixel2.geneticCode += 1
                };
            }
            else if (pixel2.age < 100) {
                pixel2.age = 100;
                if (Math.random() > 0.999) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.995) {
                    pixel2.geneticCode += 1
                };
            }
        }},
    },
    category: "organism",
    state: "solid",
    color: ["#B8C5C5","#B8C5C5","#9291A6","#8C8B99","#A8AFAF","#B8C5C5","#9291A6","#8C8B99","#B8C5C5","#B8C5C5","#9291A6","#8C8B99"],
    tempHigh: 250,
    stateHigh: ["molten_plastic","magnesium","smoke","smoke","smoke","sugar","smoke","smoke","smoke","stench","stench","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["molten_plastic","magnesium","smoke","smoke","smoke","sugar","smoke","smoke","smoke","stench","stench","stench"],
    breakInto: ["magnesium","dust","dust","dust","dust","dust","dust","sugar","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#A8AFAF","#B8C5C5","#A8AFAF","#A8AFAF"],
    isFood: true
}

elements.regression_pill = {
    behavior: behaviors.POWDER,
    reactions: {
        "organism": { elem1: null, chance:0.1, func:function(pixel1,pixel2) {
            if (pixel2.vore > 0) {
                if (Math.random() > 0.9) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.99) {
                    pixel2.vore -= 1
                };
                pixel2.geneticCode -= 1
            }
            else if (pixel2.vore < 0) {
                if (Math.random() > 0.8) {
                    pixel2.food += 1
                };
                if (Math.random() > 0.99) {
                    pixel2.vore += 1
                };
                pixel2.geneticCode -= 1
            }
            else if (pixel2.vore === 0) {
                if (Math.random() > 0.75) {
                    pixel2.food += 1
                };
                pixel2.geneticCode -= 1
            }
        }},
    },
    category: "organism",
    state: "solid",
    color: ["#c5dede","#c5dede","#D1D099","#CBCA8C","#a4b3b3","#c5dede","#D1D099","#CBCA8C","#c5dede","#c5dede","#D1D099","#CBCA8C"],
    tempHigh: 250,
    stateHigh: ["molten_plastic","sugar","smoke","smoke","smoke","herb","smoke","smoke","smoke","stench"],
    burn: 10,
    burnTime: 200,
    burnInto: ["molten_plastic","sugar","smoke","smoke","smoke","herb","smoke","smoke","smoke","stench"],
    breakInto: ["sugar","dust","dust","dust","dust","dust","dust","herb","dust","dust","dust","dust","dust","dust"],
    breakIntoColor: ["#a4b3b3","#ECF4B0","#a4b3b3","#a4b3b3"],
    isFood: true
}

/* by nekonico, do not steal!!!!!! >:3*/
// created by sqec
// coming soon: apartments, small houses

function building_1_segment(pixel) {
    if (pixel.foundation = true && pixel.height < pixel.limit) {
        if (isEmpty(pixel.x+1,pixel.y-pixel.height) &&
        isEmpty(pixel.x-1,pixel.y-pixel.height) &&
        isEmpty(pixel.x+2,pixel.y-pixel.height) &&
        isEmpty(pixel.x-2,pixel.y-pixel.height) &&
        isEmpty(pixel.x+2,pixel.y-1-pixel.height) &&
        isEmpty(pixel.x-2,pixel.y-1-pixel.height) &&
        isEmpty(pixel.x+1,pixel.y-1-pixel.height) &&
        isEmpty(pixel.x-1,pixel.y-1-pixel.height) &&
        isEmpty(pixel.x,pixel.y-1-pixel.height) &&
        isEmpty(pixel.x,pixel.y-pixel.height)) {
            createPixel("glass",pixel.x+1,pixel.y-pixel.height);
            createPixel("glass",pixel.x-1,pixel.y-pixel.height);
            createPixel("concrete",pixel.x+2,pixel.y-pixel.height);
            createPixel("concrete",pixel.x-2,pixel.y-pixel.height);
            createPixel("concrete",pixel.x+1,pixel.y-1-pixel.height);
            createPixel("concrete",pixel.x-1,pixel.y-1-pixel.height);
            createPixel("concrete",pixel.x+2,pixel.y-1-pixel.height);
            createPixel("concrete",pixel.x-2,pixel.y-1-pixel.height);
            createPixel("concrete",pixel.x,pixel.y-1-pixel.height);
            createPixel("concrete",pixel.x,pixel.y-pixel.height);
            pixel.height = pixel.height+2
        }
    }
}
function clearbase3x5(pixel) {
    if (pixel.clearbase = false && pixel.height < pixel.limit) {
        pixel.clearbase = true
        deletePixel(pixel.x-1,pixel.y)
        deletePixel(pixel.x+1,pixel.y)
        deletePixel(pixel.x-2,pixel.y)
        deletePixel(pixel.x+2,pixel.y)
        deletePixel(pixel.x,pixel.y-1)
        deletePixel(pixel.x-1,pixel.y-1)
        deletePixel(pixel.x+1,pixel.y-1)
        deletePixel(pixel.x-2,pixel.y-1)
        deletePixel(pixel.x+2,pixel.y-1)
        deletePixel(pixel.x,pixel.y-2)
        deletePixel(pixel.x-1,pixel.y-2)
        deletePixel(pixel.x+1,pixel.y-2)
        deletePixel(pixel.x-2,pixel.y-2)
        deletePixel(pixel.x+2,pixel.y-2)
    }
}
function filldirt2x5(pixel) {
    var dirtPixelElem = pixelMap[pixel.x][pixel.y+1];
    if (!isEmpty(pixel.x,pixel.y+1) && !outOfBounds(pixel.x,pixel.y+1)) {
            dirtPixelElem = pixelMap[pixel.x][pixel.y+1].element
        }
    if (isEmpty(pixel.x+1,pixel.y+1)) {
        createPixel(dirtPixelElem,pixel.x+1,pixel.y+1);
    }
    if (isEmpty(pixel.x-1,pixel.y+1)) {
        createPixel(dirtPixelElem,pixel.x-1,pixel.y+1);
    }
    if (isEmpty(pixel.x+2,pixel.y+1)) {
        createPixel(dirtPixelElem,pixel.x+2,pixel.y+1);
    }
    if (isEmpty(pixel.x-2,pixel.y+1)) {
        createPixel(dirtPixelElem,pixel.x-2,pixel.y+1);
    }
    if (isEmpty(pixel.x+2,pixel.y+2)) {
        createPixel(dirtPixelElem,pixel.x+2,pixel.y+2);
    }
    if (isEmpty(pixel.x-2,pixel.y+2)) {
        createPixel(dirtPixelElem,pixel.x-2,pixel.y+2);
    }
    if (isEmpty(pixel.x+1,pixel.y+2)) {
        createPixel(dirtPixelElem,pixel.x+2,pixel.y+2);
    }
    if (isEmpty(pixel.x-1,pixel.y+2)) {
        createPixel(dirtPixelElem,pixel.x-2,pixel.y+2);
    }
    if (isEmpty(pixel.x,pixel.y+2)) {
        createPixel(dirtPixelElem,pixel.x-2,pixel.y+2);
    }
}
elements.building_1 = {
    color: "#ffc800",
    tick: function(pixel) {
        if (!isEmpty(pixel.x,pixel.y+1)) {
            clearbase3x5(pixel);
            if (isEmpty(pixel.x+1,pixel.y) &&
            isEmpty(pixel.x-1,pixel.y) &&
            isEmpty(pixel.x+2,pixel.y) &&
            isEmpty(pixel.x-2,pixel.y) &&
            isEmpty(pixel.x+2,pixel.y-1) &&
            isEmpty(pixel.x-2,pixel.y-1) &&
            isEmpty(pixel.x+1,pixel.y-1) &&
            isEmpty(pixel.x-1,pixel.y-1) &&
            isEmpty(pixel.x,pixel.y-1) &&
            isEmpty(pixel.x+2,pixel.y-2) &&
            isEmpty(pixel.x-2,pixel.y-2) &&
            isEmpty(pixel.x+1,pixel.y-2) &&
            isEmpty(pixel.x-1,pixel.y-2) &&
            isEmpty(pixel.x,pixel.y-2)) {
                filldirt2x5(pixel);
                movePixel(pixel,pixel.x,pixel.y-1);
                createPixel("concrete",pixel.x+1,pixel.y+1);
                createPixel("concrete",pixel.x-1,pixel.y+1);
                createPixel("concrete",pixel.x+2,pixel.y+1);
                createPixel("concrete",pixel.x-2,pixel.y+1);
                createPixel("wood",pixel.x,pixel.y+1);
                pixel.limit = 5 + Math.floor(Math.random() * 25)*2;
                createPixel("concrete",pixel.x+1,pixel.y);
                createPixel("concrete",pixel.x-1,pixel.y);
                createPixel("concrete",pixel.x+2,pixel.y);
                createPixel("concrete",pixel.x-2,pixel.y);
                createPixel("concrete",pixel.x+1,pixel.y-1);
                createPixel("concrete",pixel.x-1,pixel.y-1);
                createPixel("concrete",pixel.x+2,pixel.y-1);
                createPixel("concrete",pixel.x-2,pixel.y-1);
                createPixel("concrete",pixel.x,pixel.y-1);
                pixel.foundation = true;
                pixel.height = pixel.height+2
            }
        }
        if (pixel.foundation == true && pixel.height < pixel.limit) {
            building_1_segment(pixel);
        }
        else if (pixel.foundation == true && pixel.height >= pixel.limit) {
            pixel.built = true;
        }
        if (pixel.built == true || pixel.age > 100) {
            changePixel(pixel,"wood");
        }
        pixel.age++
        doDefaults(pixel);
    },
    properties: {
        height:0,
        limit:0,
        foundation:false,
        built:false,
        clearbase:false,
        age:0
    },
    category: "citybuilding",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    maxSize: 1,
    excludeRandom: true,
    behavior: behaviors.STURDYPOWDER,
};
elements.small_tree_1 = {
    color: "#4bd943",
    tick: function(pixel) {
        if (!isEmpty(pixel.x,pixel.y+1)) {
            if (isEmpty(pixel.x+1,pixel.y-1) &&
            isEmpty(pixel.x-1,pixel.y-1) &&
            isEmpty(pixel.x,pixel.y-1) &&
            isEmpty(pixel.x+1,pixel.y-2) &&
            isEmpty(pixel.x-1,pixel.y-2) &&
            isEmpty(pixel.x,pixel.y-2) &&
            isEmpty(pixel.x+1,pixel.y-3) &&
            isEmpty(pixel.x-1,pixel.y-3) &&
            isEmpty(pixel.x,pixel.y-3)) {
                createPixel("wood",pixel.x,pixel.y-1);
                createPixel("wood",pixel.x,pixel.y-2);
                createPixel("plant",pixel.x,pixel.y-3);
                createPixel("plant",pixel.x-1,pixel.y-1);
                createPixel("plant",pixel.x-1,pixel.y-2);
                createPixel("plant",pixel.x-1,pixel.y-3);
                createPixel("plant",pixel.x+1,pixel.y-1);
                createPixel("plant",pixel.x+1,pixel.y-2);
                createPixel("plant",pixel.x+1,pixel.y-3);
                changePixel(pixel,"wood");
            }
        }
        if (pixel.age > 50) {
            changePixel(pixel,"wood");
        }
        pixel.age++
        doDefaults(pixel);
    },
    properties: {
        age:0
    },
    category: "citybuilding",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    maxSize: 1,
    excludeRandom: true,
    behavior: behaviors.STURDYPOWDER,
};
elements.roomtemper = {
	color: "#29632f",
	behavior: behaviors.WALL,
	tick: function(pixel) {
        // from nouserthings.js <3
		for (var i = 0; i < squareCoords.length; i++) {
                var coord = squareCoords[i];
                var x = pixel.x+coord[0];
                var y = pixel.y+coord[1];
                if (!isEmpty(x,y, true)) {
					if(pixelMap[x][y].temp < -230) {
                    pixelMap[x][y].temp = (pixelMap[x][y].temp + 7)
					} else if(pixelMap[x][y].temp > 270) {
						pixelMap[x][y].temp = (pixelMap[x][y].temp - 7)
					} else if (pixelMap[x][y].temp < 20) {
						pixelMap[x][y].temp = (pixelMap[x][y].temp + 2)
					} else if (pixelMap[x][y].temp > 20) {
						pixelMap[x][y].temp = (pixelMap[x][y].temp - 2)
					}
                }
            }
	},
	category:"machines",
	state:"solid",
	insulate: true,
	noMix: true,
	movable: false,
};

elements.cold_fire.behavior = [
    "M1|M1|M1",
    "M2|DL%8|M2",
    "XX|M2|XX",
];

// powder
elements.powder_heater = {
    category: "machines",
    behavior: [
        "XX|HT:2|XX",
        "HT:2|XX|HT:2",
        "M2|HT:2 AND M1|M2",
    ],
    color: "#881111",
    insulate: true,
};

elements.powder_cooler = {
    category: "machines",
    behavior: [
        "XX|CO:2|XX",
        "CO:2|XX|CO:2",
        "M2|CO:2 AND M1|M2",
    ],
    color: "#111188",
    insulate: true,
};

elements.powder_superheater = {
    category: "machines",
    behavior: [
        "XX|HT:10|XX",
        "HT:10|XX|HT:10",
        "M2|HT:10 AND M1|M2",
    ],
    color: "#dd1111",
    insulate: true,
};

elements.powder_freezer = {
    category: "machines",
    behavior: [
        "XX|CO:10|XX",
        "CO:10|XX|CO:10",
        "M2|CO:10 AND M1|M2",
    ],
    color: "#1111dd",
    insulate: true,
};

// gas
elements.gas_heater = {
    color: "#881111",
    behavior: [
        "M2|M1 AND HT:2|M2",
        "M1 AND HT:2|XX|M1 AND HT:2",
        "M2|M1 AND HT:2 | M2",
    ],
    category: "machines",
    insulate: true,
};

elements.gas_cooler = {
    color: "#111188",
    behavior: [
        "M2|M1 AND CO:2|M2",
        "M1 AND CO:2|XX|M1 AND CO:2",
        "M2|M1 AND CO:2|M2",
    ],
    category: "machines",
    insulate: true,
};

elements.gas_superheater = {
    color: "#dd1111",
    behavior: [
        "M2|M1 AND HT:10|M2",
        "M1 AND HT:10|XX|M1 AND HT:10",
        "M2|M1 AND HT:10|M2",
    ],
    category: "machines",
    insulate: true,
};

elements.gas_freezer = {
    color: "#1111dd",
    behavior: [
        "M2|M1 AND CO:10|M2",
        "M1 AND CO:10|XX|M1 AND CO:10",
        "M2|M1 AND CO:10|M2",
    ],
    category: "machines",
    insulate: true,
};

// antipowder
elements.anti_heater = {
    color: "#881111",
    behavior: [
        "M2|M1 AND HT:2|M2",
        "HT:2|XX|HT:2",
        "XX|HT:2|XX",
    ],
    category: "special",
    insulate: true,
};

elements.anti_cooler = {
    color: "#111188",
    behavior: [
        "M2|M1 AND CO:2|M2",
        "CO:2|XX|CO:2",
        "XX:CO:2|XX",
    ],
    category: "special",
    insulate: true,
};

elements.anti_superheater = {
    color: "#881111",
    behavior: [
        "M2|M1 AND HT:10|M2",
        "HT:10|XX|HT:10",
        "XX|HT:10|XX",
    ],
    category: "special",
    insulate: true,
};

elements.anti_freezer = {
    color: "#1111dd",
    behavior: [
        "M2|M1 AND CO:10|M2",
        "CO:10|XX|CO:10",
        "XX:CO:10|XX",
    ],
    category: "special",
    insulate: true,
};

elements.heater_gas = {
    color: "#881111",
    behavior: [
        "M2|M1 AND HT:2|M2",
        "M1 AND HT:2|XX|M1 AND HT:2",
        "M2|M1 aND HT:2|M2",
    ],
    category: "special",
    insulate: true,
}

elements.cooler_gas = {
    color: "#111188",
    behavior: [
        "M2|M1 AND CO:2|M2",
        "M1 AND CO:2|XX|M1 AND CO:2",
        "M2|M1 A ND CO:2|M2",
    ],
    category: "special",
    insulate: true,
}

elements.superheater_gas = {
    color: "#881111",
    behavior: [
        "M2|M1 AND H1:10|M2",
        "M1 AND HT:10|XX|M1 AND HT:10",
        "M2|M1 AND HT:10|M2",
    ],
    category: "special",
    insulate: true,
}

elements.freezer_gas = {
    color: "#1111dd",
    behavior: [
        "M2|M1 AND CO:10|M2",
        "M1 AND CO:10|XX|M1 AND CO:10",
        "M2|M1 AND CO:10|M2",
    ],
    category: "special",
    insulate: true,
}
elements.troll1 = {
	color: "#eeeeee",
	tick: function(pixel) {
		for (var i = 1; i < width; i++) {
			for (var j = 1; j < height; j++) {
				if (!isEmpty(i,j)) {
					if(Math.random() < 0.003 && pixelMap[i][j].element != pixel.element) { deletePixel(i,j) }
				}
			}
		if(i == width) {
			i = 1
		}
		}
	},
	category: "machines",
	insulate: true,
	state: "solid",
	excludeRandom: true,
},

elements.troll2 = {
	color: "#eeeeee",
	tick: function(pixel) {
		for (var i = 1; i < width; i++) {
			for (var j = 1; j < height; j++) {
				if (!isEmpty(i,j)) {
					if(Math.random() < 0.005) { pixelMap[i][j].color = "rgb(0,0,0)" }
				}
			}
		if(i == width) {
			i = 1
		}
		}
	},
	category: "machines",
	insulate: true,
	state: "solid",
	excludeRandom: true,
},

elements.troll3 = {
	color: "#eeeeee",
	tick: function(pixel) {
		for (var i = 1; i < width; i++) {
			for (var j = 1; j < height; j++) {
				if (!isEmpty(i,j)) {
					if(Math.random() < 0.05) { swapPixels(pixel,pixelMap[i][j]) }
				}
			}
		if(i == width) {
			i = 1
		}
		}
	},
	category: "machines",
	insulate: true,
	state: "solid",
	excludeRandom: true,
},

elements.troll4 = {
	color: "#eeeeee",
	tick: function(pixel) {
		for (var i = 1; i < width; i++) {
			for (var j = 1; j < height; j++) {
				var eeaa = (Math.floor(Math.random()*5))-2
				if(Math.random() < 0.00007) { explodeAt(i,j,9+eeaa) }
				if(j == height) { j == 1 }
			}
			if(i == height) { i == 1 }
		}
	},
	category: "machines",
	insulate: true,
	hardness: 1.0,
	state: "solid",
	excludeRandom: true,
},

elements.offset_fourth_y = {
    color: ["#000000", "#ff00ff", "#000000", "#ff00ff", "#000000", "#ff00ff", "#000000", "#ff00ff"],
    tool: function(pixel) {
        tryMove(pixel,pixel.x,pixel.y+0.25);
		pixelTempCheck(pixel)
    },
    category: "tools",
},

elements.offset_half_y = {
    color: ["#000000", "#ff00ff", "#000000", "#ff00ff", "#000000", "#ff00ff", "#000000", "#ff00ff"],
    tool: function(pixel) {
        tryMove(pixel,pixel.x,pixel.y+0.5);
		pixelTempCheck(pixel)
    },
    category: "tools",
},

elements.offset_three_fourth_y = {
    color: ["#000000", "#ff00ff", "#000000", "#ff00ff", "#000000", "#ff00ff", "#000000", "#ff00ff"],
    tool: function(pixel) {
        tryMove(pixel,pixel.x,pixel.y+0.75);
		pixelTempCheck(pixel)
    },
    category: "tools",
},

elements.troll5 = {
	color: "#eeeeee",
	tick: function() {
		for (var i = 1; i < width; i++) {
			for (var j = 1; j < height; j++) {
				if (!isEmpty(i,j)) {
					if(!pixelMap[i][j].r) {
						pixelMap[i][j].r = 0
					}
					pixelMap[i][j].r = (pixelMap[i][j].r + 1) % 4
				}
			}
		}
	},
	category: "machines",
	insulate: true,
	state: "solid",
	excludeRandom: true,
}

elements.troll6 = {
	color: "#eeeeee",
	tick: function() {
            if(pixel.temp < -273) {
                pixel.temp = -273;
            };
            if(isNaN(pixel.temp)) {
                pixel.temp = -1;
            };
            pixel.bemp = Math.floor(pixel.temp);
            if(pixel.bemp > 273) {
                pixel.bemp = 273;
            };
            if(pixel.temp >= 4000) {
                pixelTicks = -1;
                pixel.temp = 4000;
            } else {
                pixelTicks += pixel.bemp;
            };
	},
	category: "machines",
	insulate: true,
	state: "solid",
	excludeRandom: true,
        temp: -1,
},

elements.troll7 = {
	color: "#eeeeee",
	tick: function(pixel) {
		for (var i = 1; i < width; i++) {
			for (var j = 1; j < height; j++) {
				if (!isEmpty(i,j)) {
                                        piskel = pixelMap[i][j]
					if(Math.random() < 0.003 && piskel.element != pixel.element) { piskel.temp += (Math.floor(Math.random() * 500 + 1) - 250) }
				}
			}
		}
	},
	category: "machines",
	insulate: true,
	state: "solid",
	excludeRandom: true,
}
function createSus(right, top) {
    return {
      color: "#ff0000",
      behavior: [
        `XX|CR:${top} AND CH:${top}|XX`,
        `XX|XX|CR:${right} AND CH:${right}`,
        "XX|XX|XX",
      ],
      category: "special",
      state: "solid",
      density: 6942.0,
      hidden: true,
    }
  }
  function createSusTop(top) {
    return {
      color: "#ff0000",
      behavior: [
        `XX|CR:${top} AND CH:${top}|XX`,
        `XX|XX|DL`,
        "XX|XX|XX",
      ],
      category: "special",
      state: "solid",
      density: 6942.0,
      hidden: true,
    }
  }
  function createSusTopRow(right) {
    return {
      color: "#ff0000",
      behavior: [
        `XX|CR:top AND CH:top|XX`,
        `XX|XX|CR:${right} AND CH:${right}`,
        "XX|XX|XX",
      ],
      category: "special",
      state: "solid",
      density: 6942.0,
      hidden: true,
    }
  }
  
  elements.sus = createSus("sus2", "sus4")
  elements.sus.behavior[2] = "XX|M1|XX"
  elements.sus.hidden = false
  elements.sus2 = createSus("sus3", "sus5")
  elements.sus3 = createSusTop("sus6")
  elements.sus4 = createSus("sus5", "sus7")
  elements.sus5 = createSus("sus6", "sus8")
  elements.sus6 = createSusTop("sus9")
  elements.sus7 = createSus("sus8", "susA")
  elements.sus8 = createSus("sus9", "susB")
  elements.sus9 = createSusTop("susC")
  elements.susA = createSusTopRow("susB")
  elements.susB = createSusTopRow("susC")
  elements.susC = {
    color: "#ff0000",
    behavior: [
      `XX|CR:top AND CH:top|XX`,
      `XX|XX|DL`,
      "XX|XX|XX",
    ],
    category: "special",
    state: "solid",
    density: 6942.0,
    hidden: true,
  }
  elements.top = {
    color: "#000000",
    behavior: [
      `XX|DL|XX`,
      `XX|DL%5|XX`,
      "XX|XX|XX",
    ],
    category: "special",
    state: "solid",
    density: 6942.0,
    hidden: true,
  }
  
  // Colors
  elements.sus2.color = "#000000"
  elements.sus8.color = "#00ffff"
  elements.sus9.color = "#00ffff"
  
  /* 
  susA susB susC
  sus7 sus8 sus9
  sus4 sus5 sus6
  sus_ sus2 sus3
  */
  enabledMods.includes("mods/libpacman-v1.js") || (enabledMods.push("mods/libpacman-v1.js"), localStorage.setItem("enabledMods", JSON.stringify(enabledMods)), location.reload());

  let realTps = 0;
  let lastTps = 0;
  window.addEventListener("load", ()=>{
    requireMods(["mods/libhooktick.js"], () => {
      beforeEveryTick(()=>{
        lastTps++;
      });
      setInterval(()=>{
        realTps = lastTps;
        lastTps = 0;
      }, 1000);
    });
  });
  function updateStatsNew() {
      var statsDiv = document.getElementById("stats");
      var stats = "<span id='stat-pos' class='stat'>x"+mousePos.x+",y"+mousePos.y+"</span>";
      stats += "<span id='stat-pixels' class='stat"+ (currentPixels.length >= maxPixelCount ? " redText" : "") +"'>Pxls:" + currentPixels.length+"</span>";
      stats += "<span id='stat-tps' class='stat'>" + tps+"tps</span>";
      stats += "<span id='stat-realtps' class='stat'>" + realTps + "tps</span>";
      stats += "<span id='stat-ticks' class='stat'>" + pixelTicks+"</span>";
      if ((typeof pixelMap).length === 9) { return; }
      if (pixelMap[mousePos.x] !== undefined) {
          var currentPixel = pixelMap[mousePos.x][mousePos.y];
          if (currentPixel !== undefined) {
              stats += "<span id='stat-element' class='stat'>Elem:"+(elements[currentPixel.element].name || currentPixel.element).toUpperCase()+"</span>";
              stats += "<span id='stat-temperature' class='stat'>Temp:"+formatTemp(currentPixel.temp)+"</span>";
              if (currentPixel.charge) {
                  stats += "<span id='stat-charge' class='stat'>C"+parseFloat(currentPixel.charge)+"</span>";
              }
              if (currentPixel.burning) {
                  stats += "<span id='stat-burning' class='stat'>Burning</span>";
              }
              if (elements[currentPixel.element].hoverStat) {
                  stats += "<span id='stat-hover' class='stat'>"+elements[currentPixel.element].hoverStat(currentPixel).toString().replaceAll("<","&lt;")+"</span>";
              }
              else if (currentPixel.clone) {
                  stats += "<span id='stat-clone' class='stat'>"+currentPixel.clone.toString().toUpperCase().replaceAll("<","&lt;")+"</span>";
              }
              else if (currentPixel.con && currentPixel.con.element) {
                  stats += "<span id='stat-clone' class='stat'>"+currentPixel.con.element.toString().toUpperCase().replaceAll("<","&lt;")+"</span>";
              }
          }
      }
      if (shiftDown) {
          stats += "<span id='stat-shift' class='stat'>"+shiftDownTypes[shiftDown]+"</span>";
      }
      // If the view is not null, show the view in all caps
      if (view !== null) {
          stats += "<span id='stat-view' class='stat'>"+(viewInfo[view] ? viewInfo[view].name : view)+"</span>";
      }
      statsDiv.innerHTML = stats;
  }
  updateStats = updateStatsNew;
  var style = document.createElement('style');
style.type = 'text/css';
style.id = 'findStatusStylesheet';
style.innerHTML = '.findStatus { color: #E11; text-decoration: none; }';
document.getElementsByTagName('head')[0].appendChild(style);

find = false;
findElement = "sand";
findColorPulseTimer = 0;
findColorPulseTimerSubTimer = 0;

function marasi(number) {
	return Math.min(255,Math.round(Math.abs(Math.sin(number) * 255)));
};
		
function updateFindDescription() {
	var elems = findElement;
	if(elems instanceof Array) {
		elems = elems.join(", ");
	};
	elements.find_toggle.desc = `
<em>I'm running out of keybinds</em>


<span class="findStatus">If this text is green or underlined, find mode is on.</span> Currently finding: ${elems} <small style="font-size:80%;">(this display does not update automatically)</small>.
<span onclick=toggleFind() style="color: #ff00ff;";>Click here</span> to toggle find mode. This highlights the currently selected element.<br/>
<span style='color:#FF00FF' onClick=findFilterPrompt()>Click here to configure the find filter.</span>`;
};

function toggleFind() {
	if(find != true) {
		find = true;
		document.getElementById("findStatusStylesheet").innerHTML = '.findStatus { color: #1E1; text-decoration: underline; }'; //Displayed info doen't update until it's pulled up again, so I'm using CSS to dynamically change the color of an element.
	} else {
		find = false;
		document.getElementById("findStatusStylesheet").innerHTML = '.findStatus { color: #E11; text-decoration: none; }';
	};
	updateFindDescription();
};

findHighlighting = function() {
	//console.log(3);
	if(!find) {
		return false;
	}
	var newCurrentPixels = currentPixels;
	var pixelsFirst = [];
	var pixelsLast = [];
	var canvas = document.getElementById("game");
	var ctx = canvas.getContext("2d");

	for (var i = 0; i < newCurrentPixels.length; i++) {
		pixel = newCurrentPixels[i];
		//if (pixelMap[pixel.x][pixel.y] == undefined || currentPixels.indexOf(pixel) == -1) {continue}
		if (pixel.del) {continue};
		if (elements[pixel.element].isGas) {
			pixelsLast.push(pixel);
		} else {
			pixelsFirst.push(pixel);
		};
	};

	var pixelDrawList = pixelsFirst.concat(pixelsLast);
	for (var i = 0; i < pixelDrawList.length; i++) {
		pixel = pixelDrawList[i];
		if (pixelMap[pixel.x][pixel.y] == undefined) {continue};
		if(findElement instanceof Array ? findElement.includes(pixel.element) : pixel.element === findElement) {
			ctx.fillStyle = "rgb(255," + marasi(findColorPulseTimer / 10) + ",0)";
			ctx.fillRect(pixel.x*pixelSize, pixel.y*pixelSize, pixelSize, pixelSize);
		};
	};
	
	findColorPulseTimerSubTimer++;
	if(findColorPulseTimerSubTimer >= 2) {
		findColorPulseTimer++;
		findColorPulseTimerSubTimer = 0;
	};
	
	return true;
};

elements.find_toggle = {
    color: ["#000000", "#000000", "#000000", "#000000", "#ff0000", "#ff0000", "#ff0000", "#ff0000"],
	name: "find toggle (look at info)",
    behavior: behaviors.SELFDELETE,
    category: "tools",
	excludeRandom: true,
	desc: `
<em>I'm running out of keybinds</em>


<span class="findStatus">If this text is green or underlined, find mode is on.</span> Currently finding: sand <small style="font-size:80%;">(this display does not update automatically)</small>.
<span onclick=toggleFind() style="color: #ff00ff;";>Click here</span> to toggle find mode. This highlights the currently selected element.<br/>
<span style='color:#FF00FF' onClick=findFilterPrompt()>Click here to configure the find filter.</span>`,
};

function findFilterPrompt() {
	var preElement = prompt("Enter the elements you want to highlight\nSeparate multiple elements with commas");
	if(preElement === null || preElement === "") {
		return false;
	};
	if(preElement.includes(",")) {
		preElement = preElement.split(",");
		findElement = preElement;
		updateFindDescription();
		return findElement;
	};
	findElement = preElement;
	updateFindDescription();
	return findElement;
};

renderPostPixel(findHighlighting);

elements.loose_straw = {
	color: ["#F9E3A1","#93734E","#C7AA83"],
	behavior: behaviors.POWDER,
	tempHigh: 380,
	stateHigh: "fire",
	burn: 80,
	burnTime: 30,
	category: "powders",
	state: "solid",
	density: 47.5,
	hidden: true,
},

elements.straw.breakInto = ["ash","loose_straw"]

elements.plastic_scrap = {
	color: "#c3cccc",
	behavior: behaviors.POWDER,
	category: "powders",
	tempHigh: 200,
	stateHigh: "molten_plastic",
	burn: 15,
	burnTime: 350,
	burnInto: "dioxin",
	state: "solid",
	density: 952,
	hidden: true,
},

elements.plastic.breakInto = ["plastic_scrap","dioxin"]

elements.insulation.breakInto = ["plastic_scrap","dioxin","glass_shard"]

elements.copper_scrap = {
	color: ["#B96242","#CE5332","#D77045","#994222","#AE3312","#B75025","#A95232","#BE4322","#C76035"],
	behavior: [
		"XX|XX|XX",
		"XX|CH:oxidized_copper%0.005|XX",
		"M2|M1|M2",
	],
	reactions: {
		"water": { "elem1":"oxidized_copper", chance:0.0035 },
		"salt_water": { "elem1":"oxidized_copper", chance:0.006 },
		"dirty_water": { "elem1":"oxidized_copper", chance:0.045 },
		"sugar_water": { "elem1":"oxidized_copper", chance:0.0045 },
	},
	category: "powders",
	tempHigh: 1085,
	stateHigh: "molten_copper",
	density: 5960,
	conduct: 0.90,
	hidden: true,
},

elements.oxidized_copper_scrap = {
	color: ["#507565","#52665A","#618374","#305545","#32463A","#416354","#406555","#42564A","#517364"],
	behavior: behaviors.POWDER,
	category: "powders",
	hidden: true,
	tempHigh: 1085,
	stateHigh: "molten_copper",
	density: 5960,
	conduct: 0.80,
	hidden: true,
}

elements.copper.breakInto = ["copper_scrap","copper_scrap","copper_scrap","copper_scrap","copper_scrap","oxidized_copper_scrap"]

elements.dry_ice.breakInto = "carbon_dioxide"

regularShinyThingArray = ["iron", "zinc", "tin", "nickel", "silver", "aluminum", "lead", "tungsten", "brass", "bronze", "sterling", "steel", "rose_gold", "solder", "gold", "pyrite"]
//pyrite is a mineral

runAfterLoad(function() {
	if(enabledMods.includes("mods/Neutronium Mod.js")) {
		regularShinyThingArray.push("mythril")
		regularShinyThingArray.push("mithril_mythril_alloy")
		regularShinyThingArray.push("titanium")
		regularShinyThingArray.push("ilitium")
	}
	if(enabledMods.includes("mods/fey_and_more.js")) {
		regularShinyThingArray.push("mithril")
	}
	if(enabledMods.includes("mods/metals.js")) {
		regularShinyThingArray.push("beryllium")
		regularShinyThingArray.push("boron")
		regularShinyThingArray.push("ruthenium")
		regularShinyThingArray.push("rhodium")
		regularShinyThingArray.push("palladium")
		regularShinyThingArray.push("rhenium")
		regularShinyThingArray.push("osmium")
		regularShinyThingArray.push("iridium")
		regularShinyThingArray.push("platinum")
		regularShinyThingArray.push("frozen_mercury")
		regularShinyThingArray.push("lithium")
		regularShinyThingArray.push("niobium")
		if(elements.mercury) {
			elements.mercury.breakInto = "mercury_gas"
		}
	}

	if(enabledMods.includes("mods/ketchup_mod.js")) {
		regularShinyThingArray.push("ketchup_metal")
		regularShinyThingArray.push("ketchup_gold")
		elements.frozen_ketchup.breakInto = "ketchup_snow"
		elements.frozen_poisoned_ketchup.breakInto = "poisoned_ketchup_snow"
	}

	if(enabledMods.includes("mods/randomness.js")) {
		regularShinyThingArray.push("tungstensteel")
		regularShinyThingArray.push("densinium")
	}

	if(enabledMods.includes("mods/fey_and_more.js")) {
		regularShinyThingArray.push("mithril")
	}

	if(enabledMods.includes("mods/some_tf_liquids.js")) {
		regularShinyThingArray.push("signalum")
	}

	if(enabledMods.includes("mods/laetium.js")) {
		regularShinyThingArray.push("laetium")
	}

	elements.nitrogen_snow = {
		color: "#efefef",
		behavior: behaviors.POWDER,
		category: "solids",
		temp: -259.86,
		tempHigh: -209.86,
		stateHigh: "liquid_nitrogen",
		state: "solid",
		density: 850,
		hidden: true,
	}

	elements.nitrogen_ice.breakInto = "nitrogen_snow"

	runAfterLoad(function() {
		for(i = 0; i < regularShinyThingArray.length; i++) {
			var thing = regularShinyThingArray[i];
			if(elements[thing]) {
				elements[`${thing}_scrap`] = {
					color: elements[thing].color,
					behavior: behaviors.POWDER,
					tempHigh: elements[thing].tempHigh,
					stateHigh: thing,
					category: "powders",
					hidden: true,
					density: elements[thing].density * 0.09,
					conduct: elements[thing].conduct * 0.4,
					movable: true,
				};
				if(elements[thing].reactions) {
					elements[`${thing}_scrap`].reactions = elements[thing].reactions;
				};
				elements[thing].breakInto = `${thing}_scrap`;
			};
		};
	if(enabledMods.includes("mods/randomness.js")) {
		elements.acid.ignore.push("densinium_scrap")
		elements.densinium_scrap.hardness = 0.99
	}
	if(enabledMods.includes("mods/metals.js")) {
		elements.lithium_scrap.tick = function(pixel) {
			tryTarnish(pixel,"lithium_oxide",0.021) 
			if(pixel.temp >= 178) {
				pixel.burning = true; 
				pixel.burnStart = pixelTicks; 
			};
		};
	};
	if(enabledMods.includes("mods/laetium.js")) {
		elements.laetium_scrap.tick = function(pixel) {
			neighbors = [[-1,0],[0,-1],[1,0],[0,1]]
			for(i = 0; i < neighbors.length; i++) {
				if(!isEmpty(pixel.x+neighbors[i][0],pixel.y+neighbors[i][1],true)) {
					if(elements[pixelMap[pixel.x+neighbors[i][0]][pixel.y+neighbors[i][1]].element].category) {
						if(elements[pixelMap[pixel.x+neighbors[i][0]][pixel.y+neighbors[i][1]].element].category == "cum") {
							pixel.temp += 7
						};
					};
				};
			};
		};
	};
	});
});
//jaydsfunctions
erase1Var = 0;
elements.selective_eraser = {
    color: ["#ffff00","#ffff00","#ffff00","#555555","#555555","#555555"],
    category: "tools",
    tool: function(pixel) {
        if (pixel.element === erase1Var) {
            deletePixel(pixel.x, pixel.y);
        }
    },
        onSelect: function() {
        var answer1 = prompt("Please input what element should be erased.",(erase1Var||undefined));
        if (!answer1) { return }
		erase1Var = answer1;
    }
},
explode1Var = 0;
elements.selective_exploder = {
    color: ["#ff0000","#ff0000","#ff0000","#555555","#555555","#555555"],
    category: "tools",
    tool: function(pixel) {
        if (pixel.element === explode1Var) {
			changePixel(pixel, "explosion")
        }
    },
        onSelect: function() {
        var answer1 = prompt("Please input what element to explode.",(explode1Var||undefined));
        if (!answer1) { return }
		explode1Var = answer1;
    }
},
convert11Var = 0;
convert22Var = 0;
elements.converter_tool = {
    color: ["#ffffff","#ffffff","#ffffff","#555555","#555555","#555555"],
    darkText: true,
    category: "tools",
    tool: function(pixel) {
        if (pixel.element === convert11Var) {
			changePixel(pixel, convert22Var)
        }
    },
        onSelect: function() {
        var answer1 = prompt("Please input what should element be converted.",(convert11Var||undefined));
        if (!answer1) { return }
		convert11Var = answer1;
        var answer2 = prompt("Please input what element to convert into.",(convert22Var||undefined));
        if (!answer2) { return }
		convert22Var = answer2;
    }
},
elements.fast_bomb = {
    color: "#524c41",
    category: "weapons",
    state: "solid",
    behavior: [
        "XX|EX:10>explosion|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10>explosion|M2",
        ],
    tick: function(pixel) {
        for (var i=0; i<3; i++) {
            if (!tryMove(pixel, pixel.x, pixel.y+1)) {
                if (!isEmpty(pixel.x, pixel.y+1,true)) {
                    var newPixel = pixelMap[pixel.x][pixel.y+1];
                    if (newPixel.element === "fast_bomb") { break; }
                    }
                }
            }
        },
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
},
exclude1Var = 0;
elements.exclusive_eraser = {
    color: ["#ff5a00","#ff5a00","#ff5a00","#555555","#555555","#555555"],
    category: "tools",
    tool: function(pixel) {
        if (pixel.element !== exclude1Var) {
            deletePixel(pixel.x, pixel.y);
        }
    },
        onSelect: function() {
        var answer1 = prompt("Please input what element shouldn't be erased.",(exclude1Var||undefined));
        if (!answer1) { return }
		exclude1Var = answer1;
    }
},
elements.tenth_heater = {
    category: "special",
    color: "#ff0000",
    behavior: [
        "XX|HT:0.1|XX",
        "HT:0.1|XX|HT:0.1",
        "XX|HT:0.1|XX",
        ],
    ignore: "tenth_heater"
},
elements.e_tenth_heater = {
    category: "special",
    color: "#ff3000",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|HT:0.1|XX",
        "HT:0.1|XX|HT:0.1",
        "XX|HT:0.1|XX",
        ],
    ignore: "tenth_heater",
    conduct: 1
},
paint1Var = 0;
elements.selective_paint_tool = {
    color: ["#ff0000","#ff0000","#ff0000","#00ff00","#00ff00","#00ff00","#0000ff","#0000ff","#0000ff"],
    tool: function(pixel) {
        if (pixel.element === paint1Var) {
            if (!shiftDown) {
            pixel.color = pixelColorPick(pixel,currentColor)
        }
        else {
            // convert the hex of currentColor to rgb and set it as a string
            var rgb = currentColor.replace("#","").match(/.{1,2}/g);
            for (var i = 0; i < rgb.length; i++) {
                rgb[i] = parseInt(rgb[i],16);
            }
            pixel.color = "rgb(" + rgb.join(",") + ")"
        }
        delete pixel.origColor;
        }
    },
    onSelect: function() {
        var answer1 = prompt("Please input what element should be painted.",(paint1Var||undefined));
        if (!answer1) { return }
		paint1Var = answer1;
    },
    customColor: true,
    category: "tools",
    canPlace: false,
    desc: "Select certain pixels to change color."
},
paint2Var = 0;
elements.exclusive_paint_tool = {
    color: ["#ff0000","#00ff00","#0000ff","#0000ff","#00ff00","#ff0000"],
    tool: function(pixel) {
        if (pixel.element !== paint2Var) {
            if (!shiftDown) {
            pixel.color = pixelColorPick(pixel,currentColor)
        }
        else {
            // convert the hex of currentColor to rgb and set it as a string
            var rgb = currentColor.replace("#","").match(/.{1,2}/g);
            for (var i = 0; i < rgb.length; i++) {
                rgb[i] = parseInt(rgb[i],16);
            }
            pixel.color = "rgb(" + rgb.join(",") + ")"
        }
        delete pixel.origColor;
        }
    },
    onSelect: function() {
        var answer1 = prompt("Please input what element should be painted.",(paint2Var||undefined));
        if (!answer1) { return }
		paint2Var = answer1;
    },
    customColor: true,
    category: "tools",
    canPlace: false,
    desc: "Excludes pixels you don't want to color."
    //hello
}
elements.superheat = {
    color: "#ff2f2f",
    tool: function(pixel) {
        pixel.temp += 10;
		pixelTempCheck(pixel)
    },
    category: "tools",
};
elements.supercool = {
    color: "#2f2fff",
    tool: function(pixel) {
        pixel.temp += -10;
		pixelTempCheck(pixel)
    },
    category: "tools",
};
elements.hyperheat = {
    color: "#ff5f5f",
    tool: function(pixel) {
        pixel.temp += 50;
		pixelTempCheck(pixel)
    },
    category: "tools",
};
elements.hypercool = {
    color: "#5f5fff",
    tool: function(pixel) {
        pixel.temp += -50;
		pixelTempCheck(pixel)
    },
    category: "tools",
};
elements.absolutezero = {
    color: "#d1f7ff",
    tool: function(pixel) {
        pixel.temp = -273.15;
		pixelTempCheck(pixel)
    },
    category: "tools",
};
elements.antigrav = {
    color: ["#696969", "#969696"],
    tool: function(pixel) {
        pixel.r = 2
    },
    category: "tools",
};
elements.normalgrav = {
    color: ["#969696", "#696969"],
    tool: function(pixel) {
        pixel.r = 0
    },
    category: "tools",
};
elements.leftgrav = {
    color: ["#696969", "#969696"],
    tool: function(pixel) {
        pixel.r = 3
    },
    category: "tools",
};
elements.rightgrav = {
    color: ["#969696", "#696969"],
    tool: function(pixel) {
        pixel.r = 1
    },
    category: "tools",
};
/* Helps make managing many dependencies easier */
// Version 1.0.1
// Update Description: Refresh quickfix
let __needRefresh = false;

window.addEventListener("load", e=>{
  if(__needRefresh) location.reload();
});
/*
 * Requires that certain mods are installed for the callback to proceed.
 * @param {array} mods - The mods your mod depends on.
 * @param {function} callback - The callback to run when the dependencies are met.
 */
function requireMods(mods, cal) {
  if (__checkMods(mods)) {
    // The whole callback system remains from a feature that was nerfed soon before release. It will either be removed or taken advantage of in future versions.
    cal();
  }
  else {
    __installMods(mods);
    __needRefresh = true;
  }
}

/*
 * Fetches the name of any mods that are missing
 * @param {array} mods - The mods your mod depends on.
 * @returns {array} An array of missing mods.
 */
function __getMissingMods(mods) {
  let missing = [];
  for (let i = 0; i < mods.length; i++) {
    if (enabledMods.includes(mods[i])) {
      continue;
    }
    missing.push(mods[i]);
  }
  return missing;
}

/*
 * Checks if any mods are missing.
 * @param {array} mods - The mods your mod depends on.
 * @returns {boolean} True if any mods are missing.
 */
function __checkMods(mods) {
  return __getMissingMods(mods).length === 0;
}

function __installMods(mods) {
  __getMissingMods(mods).forEach(mod => __installMod(mod));
}

function __installMod(mod) {
  let mods = JSON.parse(localStorage.getItem("enabledMods") || "[]");
  mods.push(mod);
  localStorage.setItem("enabledMods", JSON.stringify(mods));
}

// Ensure it's available in the global scope
window.requireMods = requireMods;
let __registeredAfterTickCallbacks = [];
let __registeredBeforeTickCallbacks = [];
window.addEventListener("load", ()=>{
  const oldTick = tick;
  clearInterval(tickInterval);
  tick = function(){
    __registeredBeforeTickCallbacks.forEach(func=>{
      func();
    });
    oldTick();
    __registeredAfterTickCallbacks.forEach(func=>{
      func();
    });
  }
  tickInterval = setInterval(tick, 1000/tps);
});
function everyTick(callback) {
  afterEveryTick(callback);
}
window.everyTick = everyTick;
function beforeEveryTick(callback) {
  __registeredBeforeTickCallbacks.push(callback);
}
window.beforeEveryTick = beforeEveryTick;
function afterEveryTick(callback) {
  __registeredAfterTickCallbacks.push(callback);
}
window.afterEveryTick = afterEveryTick;
function removeTickListener(callback, mode) {
  let removed = false;
  if(mode!=="before") {
    let index = __registeredAfterTickCallbacks.indexOf(callback);
    if (index === -1 && mode === "after") throw new Error(`Could not find callback.`);
    if(index !== -1) {
      __registeredAfterTickCallbacks.splice(index, 1);
      removed = true;
    }
  }
  if(mode!=="after") {
    let index = __registeredBeforeTickCallbacks.indexOf(callback);
    if (index === -1 && mode === "before") throw new Error(`Could not find callback.`);
    if(index !== -1) {
      __registeredBeforeTickCallbacks.splice(index, 1);
      removed = true;
    }
  }
  return removed;
}
window.removeTickListener = removeTickListener;
elements.cooked_rice = {
	viscosity: 1000,
	tempHigh: 500,
	stateHigh: "charcoal",
	density: 699,
	color: "#c2b6b6",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
	reactions: {
		"water": { elem1: null, elem2: "dirty_water" }
	}
};

elements.rice = {
	breakInto: "flour",
	isFood: true,
	density: 696,
	tempHigh: 232,
	stateHigh: "cooked_rice",
	color: "#c8c8c8",
	behavior: behaviors.POWDER,
	category: "food",
	state: "liquid",
};

elements.moth = {
	tempHigh: 500,
	stateHigh: "dead_bug",
	breakInto: "dead_bug",
	color: "#57381a",
	behavior: behaviors.FLY,
	category: "life",
	state: "liquid",
};

elements.cotton_candy = {
	isFood: true,
	tempHigh: 200,
	stateHigh: "sugar",
	density: 1000,
	color: ["#b6c7e3", "#c54b4b", "#e7769c"],
	singleColor: true,
	behavior: behaviors.POWDER,
	category: "food",
	state: "liquid",
	reactions: {
		"water": { elem1: "sugar", elem2: "water" },
		"sugar_water": { elem1: "sugar", elem2:"sugar_water", chance: 10 }
	}
};

elements.mc_donalds = {
	tempHigh: 6969,
	stateHigh: "void",
	density: 69,
	color: "#ff0000",
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
};

elements.maple_syrup = {
	viscosity: 10000,
	isFood: true,
	tempHigh: 500,
	stateHigh: "steam",
	color: "#9c6000",
	behavior: behaviors.CRAWLER,
	category: "liquids",
	state: "liquid",
};

elements.boiled_egg = {
	isFood: true,
	density: 700,
	breakInto: "yolk",
	tempHigh: 500,
	stateHigh: "ash",
	color: "#fff9d1",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.dark_oak = {
	breakInto: "dark_oak_wood",
	tempHigh: 500,
	stateHigh: "ash",
	color: "#302216",
	behavior: behaviors.WALL,
	category: "solids",
	state: "solid",
	burn: 5,
	burnTime: 300,
};

elements.dark_oak_wood = {
	tempHigh: 500,
	stateHigh: "ash",
	color: "#573e28",
	behavior: behaviors.SUPPORT,
	category: "land",
	state: "solid",
	burn: 5,
	burnTime: 300,
};

elements.avocado = {
	isFood: true,
	tempHigh: 500,
	breakInto: "guacamole",
	stateHigh: "ash",
	color: "#254a22",
	behavior: behaviors.SUPPORTPOWDER,
	category: "food",
	state: "liquid",
};

elements.guacamole = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#a2e09d",
	behavior: behaviors.POWDER,
	category: "food",
	state: "liquid",
};

elements.watermelon = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	breakInto: "watermelon_flesh",
	color: "#40993f",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.melon = { //this one is kind of boring ngl it looks like a sponge but its food
	isFood: true,
	tempHigh: 500,
	stateHigh: "steam",
	color: "#c4bf1f",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.watermelon_flesh = {
	hidden: true,
	isFood: true,
	tempHigh: 500,
	stateHigh: "steam",
	color: "#ff5d47",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.nachos = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#bd7b26",
	behavior: behaviors.SUPPORTPOWDER,
	category: "food",
	state: "solid",
};

elements.cherry = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#ff0f0f",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.green_berries = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#5ce344",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.meth = {
	hardness: 1,
	tempHigh: 500,
	tempLow: -50,
	stateLowColorMultiplier: 0.9,
	stateHigh: "melted_meth",
	color: "#0affef",
	behavior: behaviors.POWDER,
	category: "joke",
	state: "liquid"
};

elements.melted_meth = {
	viscosity: 1000,
	tempHigh: 100000,
	tempLow: -20,
	stateHigh: "beans",
	stateLow: "meth",
	color: "#00a2ff",
	behavior: behaviors.LIQUID,
	category: "joke",
	state: "solid",
};

elements.garlic = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#ffebbd",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	reactions: {
		"bread": { elem1: null, elem2: "garlic_bread" },
	}
};

elements.garlic_bread = {
	isFood: true,
	breakInto: "crumb",
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#e9be90", "#288a0c", "#e0c6aa", "#b49e85", "#b6926b", "#ccac8b"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.kiwi = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#0f4700", "#0f4700", "#0f4700", "#0f4700", "#0f4700", "#0f4700", "#0f4700", "#0f4700", "#0f4700", "#210a00"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.lemon = {
	breakInto: "lemonade",
	tempHigh: 500,
	stateHigh: "steam",
	color: "#c9c22a",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
	reactions: {
        "juice": {elem1: "lemonade", elem2: null},
    }
};

elements.lemonade = {
	isFood: true,
	tempHigh: 500,
	tempLow: -15,
	tempLowColor: "#f8eb35",
	stateHigh: "steam",
	color: "#fff41c",
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "liquid",
};

elements.poop = {
	hardness: 1,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#331600",
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
	reactions: {
		"piss": { elem1: null, elem2: "bless" },
	}
};

elements.diarrhea = {
	hardness: 1,
	viscosity: 10000,
	tempHigh: 500,
    stateHigh: ["ash", "ash", "ash", "ash", "ash", "ash", "ash", "steam",],
    color: "#523718",
    behavior: behaviors.LIQUID,
    category: "joke",
	state: "solid",
	desc: "riddle me this, libshart, if theres liquid poop then wheres the solid piss?"
};

elements.marshmallow = {
	isFood: true,
	tempHigh: 50,
	stateHigh: "cooked_marshmallow",
	color: "#ffe4e3",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.cooked_marshmallow = {
	hidden: true,
	isFood: true,
	tempHigh: 150,
	stateHigh: "burnt_marshmallow",
	color: "#d49e9d",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.burnt_marshmallow = {
	hidden: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#1c1212",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.spaghetti = {
	isFood: true,
	tempHigh: 90,
	stateHigh: "cooked_ramen",
	color: "#fae34d",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.cooked_spaghetti = {
	hidden: true,
	density: 800,
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#ada24e",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.cereal = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#ba3425", "#baa31e", "#26ba1e", "#1e9dba", "#6f1eba"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
	stain: 0.005
};

elements.sushi = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#020802", "#fff0eb", "#ff6524", "#35ab26"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.diamond_ore = {
	tempHigh: 1000,
	stateHigh: "ash",
	breakInto: "diamond",
	color: ["#525252", "#525252", "#525252", "#525252", "#525252", "#2ba3ff"],
	behavior: behaviors.WALL,
	category: "joke",
	state: "solid",
};

elements.coca_cola = {
	isFood: true,
	tempHigh: 500,
	tempLow: -10,
	stateHigh: "steam",
	color: "#381e13",
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "liquid",
};

elements.pepsi = {
	tempHigh: 500,
	stateHigh: "steam",
	tempLow: -10,
	color: "#2b1717",
	behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
};

elements.piss = {
	tempHigh: 500,
	stateHigh: "steam",
	tempLow: -10,
	color: "#ffff00",
	behavior: behaviors.LIQUID,
	category: "joke",
	state: "liquid",
};

elements.soup = {
	isFood: true,
	temp: 100,
	tempHigh: 500,
	stateHigh: "steam",
	color: "#945e00",
	behavior: [
		"XX|CR:steam%0.1|XX",
		"M2|XX|M2",
		"M2|M1|M2"
	],
	category: "liquids",
	state: "liquid",
};

elements.pastry = {
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#ba6727",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};


elements.spoiled_milk = {
	tempHigh: 500,
	tempLow: -20,
	stateHigh: "ash",
	color: "#b8c2b4",
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "solid",
	reactions: {
		"dirty_water": { elem1: "milk", elem2: "expired_milk" },
		"milk": { elem1: "expired_milk", elem2: "milk" },
		"water": { elem1: "milk", elem2: "dirty_water" },
	}
};

elements.kfc = {
	tempHigh: 69420,
	stateHigh: "void",
	color: "#d16e11",
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
};

elements.wendys = {
	tempHigh: 69420,
	stateHigh: "void",
	color: "#db1e0d",
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
};

elements.burger_king = {
	tempHigh: 69420,
	stateHigh: "void",
	color: "#db660d",
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
};

elements.pizza_hut = {
	tempHigh: 69420,
	stateHigh: "void",
	color: "#ed3b24",
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
};

elements.dominos = {
	tempHigh: 69420,
	stateHigh: "void",
	color: ["#ed4934", "#3494ed"],
	behavior: behaviors.STURDYPOWDER,
	category: "joke",
	state: "solid",
};


elements.vape = {
	tempHigh: 500999,
	stateHigh: "beans",
	color: "#999999",
	behavior:  [
        "XX|CR:smoke|XX",
        "CR:smoke|XX|CR:smoke",
        "XX|CR:smoke|XX",
    ],
	category: "joke",
	state: "solid",
};

elements.tendon = {
	temp: 20000,
	color: ["#1eff00", "#1eff00", "#1eff00", "#acffa1", "#1eff00", "#1eff00", "#1eff00"],
	behavior: behaviors.DGAS,
	category: "energy",
	state: "gas",
};

elements.plasma.tempHigh = 18000
elements.plasma.stateHigh = "tendon"

elements.pea = {
	isFood: true,
	breakInto: "mashed_pea",
	tempHigh: 500,
	stateHigh: "ash",
	color: "#3cbf2a",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.mashed_pea = {
	hidden: true,
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#97f578",
	behavior: behaviors.POWDER,
	category: "food",
	state: "liquid",
};

elements.burnt_beans = {
	tempHigh: 500,
	stateHigh: "ash",
	tempLow: -0,
	stateLow: "beans",
	isFood: true,
	viscosity: 10000,
	density: 721,
	hardness: 1,
	color: "#1a0d04",
	category: "food",
	behavior: behaviors.LIQUID,
	state: "liquid",
};

elements.chicken = {
	tempHigh: 60,
	stateHigh: "chicken_nugget",
	color: "#cfbab0",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
};

elements.chicken_nugget = {
	hidden: true,
	isFood: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#e0723f",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.cocaine = {
	tempHigh: 500,
	stateHigh: "ash",
	color: "#fafafa",
	behavior: behaviors.POWDER,
	category: "joke",
	state: "liquid",
};

elements.zombie = {
	excludeRandom: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#114700",
	behavior: [
	    "M1%2|M1%2 AND SW%1|M1%2",
	    "M1%2 AND CH:zombie|XX|M1%2 AND CH:zombie",
		"M1|M1 AND SW%1|M1"
	],
	category: "special",
	state: "liquid",
	ignore: ["fire","smoke","antimatter","strange_matter","filler","lattice","wall","ewall","plasma","void","border"]
};

elements.toothpaste = {
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#e8e8e8", "#ff0000", "#00b7ff"],
	behavior: behaviors.STURDYPOWDER,
	category: "liquids",
	state: "liquid",
};

elements.radioactive_grape = {
	hidden: true,
	tempHigh: 1000,
	stateHigh: "ash",
	color: ["#7d00d1", "#8047d6"],
	behavior: behaviors.RADPOWDER,
	category: "food",
	state: "liquid",
};

elements.radioactive_meat = {
	hidden: true,
	tempHigh: 1000,
	stateHigh: "ash",
    color: ["#4b5742", "#91564a"],
    behavior: behaviors.RADPOWDER,
    category: "food",
    state: "liquid",
};

elements.radioactive_chocolate = {
	hidden: true,
    tempHigh: 1000,
    stateHigh: "ash",
    color: ["#404d29", "#4d3429"],
    behavior: behaviors.RADPOWDER,
    category: "food",
    state: "liquid",
};

elements.radioactive_egg = {
	hidden: true,
	tempHigh: 1000,
    stateHigh: "ash",
    color: "#93cc87",
    behavior: behaviors.RADPOWDER,
    category: "food",
    state: "liquid",
};

elements.radioactive_milk = {
	hidden: true,
	tempHigh: 1000,
    stateHigh: "ash",
    color: "#9bb895",
    behavior: behaviors.RADLIQUID,
    category: "liquids",
    state: "liquid",
};

elements.radioactive_potato = {
	hidden: true,
	tempHigh: 1000,
    stateHigh: "ash",
    color: "#6e8544",
    behavior: behaviors.RADPOWDER,
    category: "food",
    state: "liquid",
};

elements.radioactive_water = {
	hidden: true,
	tempHigh: 1000,
    stateHigh: "steam",
    color: "#baf0aa",
    behavior: behaviors.RADLIQUID,
    category: "liquids",
    state: "liquid",
};

elements.radioactive_bread = {
	hidden: true,
	tempHigh: 1000,
    stateHigh: "ash",
    color: "#aec74c",
    behavior: behaviors.RADPOWDER,
    category: "food",
    state: "liquid",
};

elements.radioactive_toast = {
	hidden: true,
    tempHigh: 1000,
    stateHigh: "ash",
    color: "#565e38",
    behavior: behaviors.RADPOWDER,
    category: "food",
    state: "liquid",
};

elements.radioactive_beans = {
	hidden: true,
	tempHigh: 1000,
	stateHigh: "ash",
	color: ["#34541f", "#994926"],
	behavior: behaviors.RADPOWDER,
	category: "food",
	state: "liquid",
};

elements.shampoo = {
	viscosity: 1000,
	density: 500,
	hardness: 1,
	tempHigh: 500,
	stateHigh: "steam",
	color: "#ccd3e0",
	behavior: behaviors.FOAM,
	category: "liquids",
	state: "liquid",
};

elements.salami = {
	density: 1000,
	hardness: 1,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#de3c1d",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.moon = {
	density: 3344,
	hardness: 1,
	tempHigh: 10000,
	stateHigh: "beans",
	color: "#bababa",
	behavior: behaviors.WALL,
	category: "special",
	state: "solid",
};

elements.dragon_fruit = {
	breakInto: "mashed_dragon_fruit",
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#ff006f", "#ff006f", "#ff006f", "#036300", "#ff006f", "#ff006f", "#ff006f", "#ff006f"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.mashed_dragon_fruit = {
	hidden: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: ["#e3e3e3", "#e3e3e3", "#0f0f0f", "#e3e3e3", "#e3e3e3", "#e3e3e3"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.chantilly = {
	hardness: 1,
	tempHigh: 500,
	stateHigh: "steam",
	color: "#cccccc",
	behavior: behaviors.FOAM,
	category: "liquids",
	state: "liquid",
};

elements.fart = {
	temp: Infinity,
	color: "#2e4722",
	behavior: behaviors.DGAS,
	category: "joke",
	state: "gas",
	excludeRandom: true
};

elements.chips = {
	density: 600,
	hidden: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#ff9a1f",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.fries = {
	density: 600,
	hidden: true,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#d6ab0f",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.mayo = {
	color: "#fcffbd",
    behavior: behaviors.LIQUID,
    reactions: {
        "glue": { elem2:null, chance:0.01 },
        "oil": { elem2:null, chance:0.01 },
        "sap": { elem2:null, chance:0.01 },
    },
    viscosity: 3491,
    tempHigh: 100.6,
    stateHigh: ["steam","carbon_dioxide","methane"],
    category:"liquids",
    state: "liquid",
    density: 910,
    stain: 0.01,
    isFood: true
};

elements.barbecue_sauce = {
	viscosity: 3000,
	density: 1800,
	tempHigh: 500,
	tempLow: 0,
	stateHigh: "steam",
	color: "#420400",
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "liquid",
};

elements.fried_water = {
	hidden: true,
	temp: 50,
	tempHigh: 500,
	stateHigh: "ash",
	color: "#a3591c",
	behavior: behaviors.POWDER,
	category: "joke",
	state: "liquid",
};

elements.solid_water = {
	hidden: true,
	viscosity: 10000,
	tempHigh: 100,
	stateHigh: "fried_water",
	color: "#dfe9f5",
	behavior: behaviors.LIQUID,
	category: "joke",
	state: "liquid",
};

elements.vanilla = {
	hardness: 1,
	tempHigh: 300,
	stateHigh: "steam",
	color: "#e3e3e3",
	behavior: behaviors.FOAM,
	category: "food",
	state: "liquid",
	reactions: {
		"cream": { elem1: null, elem2: "vanilla_cream" },
		"ice_cream": { elem1: null, elem2: "vanilla_ice_cream" },
		"yolk": { elem1: null, elem2: "vanilla_pudding" },
	}
};

elements.vanilla_cream = {
	hardness: 1,
	hidden: true,
	tempHigh: 300,
	stateHigh: "steam",
	color: "#d6d6d6",
	behavior: behaviors.FOAM,
	category: "food",
	state: "liquid",
};

elements.vanilla_ice_cream = {
	hardness: 1,
	hidden: true,
	tempHigh: 200,
	stateHigh: "steam",
	color: "#f7f7f7",
	behavior: behaviors.FOAM,
	category: "food",
	state: "liquid",
	reactions: {
		"chocolate": { elem1: null, elem2: "chocolate_vanilla_ice_cream", tempMin: 0 },
		"melted_chocolate": { elem1: null, elem2: "chocolate_vanilla_ice_cream", tempMin: 0 },
	}
};

elements.chocolate_vanilla_ice_cream = {
	hardness: 1,
	hidden: true,
	tempHigh: 200,
	stateHigh: "steam",
	color: ["#dbdbdb", "#915936"],
	behavior: behaviors.FOAM,
	category: "food",
	state: "liquid",
};

elements.vanilla_pudding = {
	hardness: 1,
	hidden: true,
	tempHigh: 300,
	stateHigh: "steam",
	color: "#d4c4ba",
	behavior: behaviors.FOAM,
	category: "food",
	state: "liquid",
};

elements.cinnamon = {
	tempHigh: 500,
	stateHigh: "ash",
	color: "#3d1409",
	behavior: behaviors.POWDER,
	category: "powders",
	state: "liquid",
};

elements.porridge = {
	temp: 30,
	viscosity: 3000,
	density: 500,
	tempHigh: 500,
	tempLow: -10,
	stateHigh: "steam",
	color: "#b8a254",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.beet = {
	tempHigh: 400,
	stateHigh: "ash",
	color: "#5d0678",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.chocolate_egg = {
	hidden: true,
	tempHigh: 300,
	stateHigh: "steam",
	color: "#805e2e",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.chocolate_grape = {
	hidden: true,
	viscosity: 10000,
	tempHigh: 300,
	stateHigh: "steam",
	color: ["#7e600d", "#6e4d36"],
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.sprinkles = {
	tempHigh: 200,
	stateHigh: "ash",
	cooldown: 0.2,
	color: ["#ff5e5e", "#ffea5e", "#73ff5e", "#5efcff", "#995eff", "#ff5ed1"],
	behavior: behaviors.POWDER,
	category: "powders",
	state: "liquid",
	maxSize: 1,
};

elements.incinerator = {
	color: "#bf4b7d",
	behavior: [
	"XX|HT:10000|XX",
	"HT:10000|XX|HT:10000",
	"XX|HT:10000|XX",
	],
	category: "machines",
	state: "solid",
	insulate: true,
	excludeRandom: true,
	reactions: {
		"fart": { elem1: null, elem2: "kaboom" },
	}
};

elements.cocoa = {
	breakInto: "cocoa_seeds",
	tempHigh: 300,
	stateHigh: "ash",
	color: "#912f1d",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.cocoa_seeds = {
	breakInto: "chocolate",
	hidden: true,
	tempHigh: 80,
	stateHigh: "melted_chocolate",
	color: "#cfc7ab",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.pineapple = {
	tempHigh: 200,
	stateHigh: "steam",
	color: "#ccbe3b",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.broccoli = {
	viscosity: 100000,
	tempHigh: 300,
	stateHigh: "ash",
	color: "#073804",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.pepperoni = {
	tempHigh: 300,
	stateHigh: "ash",
	color: "#8f2e11",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.apple = {
	viscosity: 10000,
	breakInto: "juice",
	tempHigh: 200,
	stateHigh: "steam",
	color: "#bd2d1a",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.blueberry = {
	density: 626,
	viscosity: 10000,
	breakInto: "juice",
	breakIntoColor: "#0e2773",
	tempHigh: 200,
	stateHigh: "steam",
	color: "#192f73",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.cucumber = {
	tempHigh: 200,
	stateHigh: "steam",
	color: "#235214",
	behavior: behaviors.SUPPORT,
	category: "food",
	state: "solid",
};

elements.olive = {
	viscosity: 10000,
	tempHigh: 200,
	stateHigh: "steam",
	color: "#0d0806",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.mushroom = {
	tempHigh: 200,
	stateHigh: "steam",
	color: "#96847d",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.onion = {
	tempHigh: 300,
	stateHigh: "steam",
	color: "#460063",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.bacon = {
	tempHigh: 90,
	stateHigh: "cooked_bacon",
	color: ["#a1392d", "#edb4ad"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.cooked_bacon = {
	hidden: true,
	tempHigh: 300,
	stateHigh: "ash",
	color: ["#70211d", "#783b38"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.strawberry = {
	viscosity: 10000,
	density: 754,
	tempHigh: 200,
	stateHigh: "steam",
	color: "#db564d",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
};

elements.beer = {
    tempHigh: 300,
    stateHigh: "steam",
	tempLow: -10,
    color: "#b39329",
    behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
};

elements.cardboard = {
	tempHigh: 500,
    stateHigh: "ash",
    color: "#7d4725",
    behavior: behaviors.SUPPORT,
    category: "land",
    state: "solid",
	burn: 5,
	burnTime: 200,
};

elements.carrot = {
	tempHigh: 500,
    stateHigh: "ash",
    color: "#f06c0e",
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "liquid",
};

elements.wine = {
	hidden: true,
	tempHigh: 400,
    stateHigh: "steam",
	tempLow: -10,
    color: "#2e0206",
    behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
};

elements.plasma_bomb = {
	tempHigh: 1000,
    stateHigh: "ash",
    color: "#452f4a",
    behavior: [
	"XX|EX:20>plasma|XX",
	"XX|XX|XX",
	"M2|M1 AND EX:20>plasma|M2"
	],
    category: "weapons",
    state: "liquid",
},

elements.dark_energy = {
	hardness: 1,
	tempHigh: 1000000,
    stateHigh: "void",
    color: "#1b161c",
	behavior: [
	    "M1%10|M1%10 AND SW%5|M1%10",
	    "M1%10 AND CH:dark_energy|XX|M1%10 AND CH:dark_energy",
		"M1|M1 AND SW%5|M1"
	 ],
    category: "special",
    state: "gas",
	excludeRandom: true
};

elements.kaboom = {
	hidden: true,
	hardness: 1,
	hidden: true,
    color: "#40174d",
    behavior: [
        "XX|XX|XX",
        "XX|EX:800>plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,molten_iron,molten_uranium,molten_lead,oxygen,molten_sodium,sulfur_gas,neon,chlorine,molten_calcium,molten_nickel,molten_copper,molten_zinc,gallium_gas AND CH:void|XX",
        "XX|XX|XX",
    ],
    temp: 99999999700,
	category: "joke",
    state: "gas",
	desc: "use at own risk",
	excludeRandom: true
};

elements.papaya = {
	tempHigh: 300,
	stateHigh: "steam",
	color: "#e38934",
	behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "liquid",
};

elements.caviar = {
	viscosity: 10000,
	tempHigh: 500,
    stateHigh: "steam",
    color: "#1f1b18",
    behavior: behaviors.LIQUID,
    category: "food",
    state: "liquid",
};

elements.peeper = {
	hidden: true,
	density: 1000,
	burn: 0.00001,
	burnTime: 9999,
	ignoreAir: true,
	burning: true,
	hardness: 1,
	tempHigh: 5000000000000000000,
	stateHigh: "ash",
	color: "#9c1208",
	behavior: behaviors.STURDYPOWDER,
    category: "joke",
    state: "solid",
};

elements.robux = {
	hidden: true,
	viscosity: 10000,
    tempHigh: 500,
    stateHigh: "fire",
    color: ["#4a8741", "#4bb53c"],
    behavior: behaviors.LIQUID,
    category: "joke",
    state: "liquid",
};

elements.ruby = {
	tempHigh: 2000,
	stateHigh: "magma",
	color: ["#d6091a", "#e83544"],
	behavior: behaviors.WALL,
	category: "solids",
	state: "solid",
};

elements.mosquito = {
	tempHigh: 2000,
	stateHigh: "ash",
	color: "#2b2421",
	behavior: behaviors.FLY,
	category: "life",
	state: "liquid",
};

elements.bug_spray = {
    tempHigh: 2000,
    stateHigh: "steam",
    color: "#c9d1cb",
    behavior: behaviors.DGAS,
    category: "gases",
    state: "gas",
	reactions: {
		"mosquito": { elem1: null, elem2: null },
		"ant": { elem1: null, elem2: null },
		"fly": { elem1: null, elem2: null },
		"stink_bug": { elem1: null, elem2: null },
	}
};

elements.heavy_water = {
	tempLow: 0,
	stateLow: "ice",
	tempHigh: 150,
	stateHigh: "steam",
	color: "#447ecf",
	behavior: behaviors.LIQUID_OLD,
	category: "liquids",
    state: "liquid",
	reactions: {
		"sand": { elem1: null, elem2: "quicksand" },
	}
};

elements.blood_orange = {
	hidden: true,
	tempHigh: 300,
	stateHigh: ["ash", "steam"],
    color: ["#f06c0e", "#bd1000"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "liquid",
};

elements.orange = {
    tempHigh: 300,
    stateHigh: "steam",
    color: "#f06c0e",
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "liquid",
	reactions: {
		"blood": { elem1: null, elem2: "blood_orange", chance: 0.01 },
	}
};

elements.cranberry = {
	viscosity: 10000,
	hidden: true,
    tempHigh: 300,
    stateHigh: "steam",
	tempLow: -15,
    color: "#ad2a1d",
    behavior: behaviors.LIQUID,
    category: "food",
    state: "liquid",
};

elements.yoyleberries = {
	desc: "who the fuck requested yoylecake?",
	viscosity: 10000,
    hidden: true,
    tempHigh: 300,
    stateHigh: "steam",
    color: "#630094",
    behavior: behaviors.LIQUID,
    category: "food",
    state: "liquid",
	reactions: {
		"batter": { elem1: null, elem2: "yoylecake" },
	}
};

elements.yoylecake = {
	hidden: true,
	tempHigh: 500,
	stateHigh: "steam",
	color: ["#9404db", "#28b82b"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid",
};

elements.cool_ray = {
color: ["#0cdaed","#baf9ff"],
    tick: function(pixel) {
        var x = pixel.x;
        for (var y = pixel.y; y < height; y++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.05) { continue }
                createPixel("flash", x, y);
                pixelMap[x][y].color = "#0cdaed";
                pixelMap[x][y].temp = 0;
            }
            else {
                if (elements[pixelMap[x][y].element].isGas) { continue }
                if (elements[pixelMap[x][y].element].id === elements.heat_ray.id) { break }
                pixelMap[x][y].temp += -10;
                pixelTempCheck(pixelMap[x][y]);
                break;
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    temp: 0,
    category: "energy",
    state: "gas",
    excludeRandom: true,
    noMix: true
};

elements.flood_disaster = {
	color: "#5397c2",
    behavior: [
        "XX|XX|XX",
        "XX|EX:10>flood_disaster,water,water,water,water,water,water,water,water,water,water,water,water%25 AND DL%10|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    hidden: true,
    excludeRandom: true,
    maxSize: 1,
    cooldown: defaultCooldown
};

elements.uranium_ice_cream = {
	viscosity: 10000,
	tempHigh: 150,
	stateHigh: "steam",
	color: ["#cee6cc", "#1bab11", "#305e2d", "#5a7059"],
	behavior: [
		"XX|CR:radiation%2|XX",
        "M2|XX|M2",
        "M2|M1|M2",
	],
    category: "food",
    state: "liquid",
};

elements.silver_coin = {
	tempHigh: 1000,
	stateHigh: "molten_silver",
	color: ["#ababab", "#dedede"],
	behavior: behaviors.POWDER,
	category: "powders",
	state: "solid",
};

elements.lololol_this_crashes_ur_game_lololol_why_would_you_want_to_use_this_lololol_it_crashes = {
	color: "#238fe8",
    behavior: [
        "XX|XX|XX",
        "XX|EX:800000000000>plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,plasma,molten_iron,molten_uranium,molten_lead,oxygen,molten_sodium,sulfur_gas,neon,chlorine,molten_calcium,molten_nickel,molten_copper,molten_zinc,gallium_gas AND CH:void|XX",
        "XX|XX|XX",
    ],
    temp: 99999999700,
    category: "joke",
    state: "gas",
    density: 1000,
    hardness: 1,
    hidden: true,
    excludeRandom: true,
    maxSize: 1,
    noMix: true,
	desc: "ok now ACTUALLY use it at your own risk IM NOT KIDDING! THIS CAN FUCKING CRASH YOUR GAME",
	excludeRandom: true,
};

elements.coffee_milk = {
	tempHigh: 300,
    stateHigh: "steam",
	tempLow: -30,
    color: "#5c4c42",
    behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
};

elements.mentos = {
	tempHigh: 500,
	stateHigh: "ash",
	color: "#d0cbd6",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "liquid"
};

elements.oreo = {
	tempHigh: 300,
	stateHigh: "steam",
	color: ["#211e1e","#fff6f5"],
	singleColor: true,
	behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "liquid"
};

elements.sned = {
	desc: "slowly expanding...",
	color: "#dfe0d9",
	behavior: [
		"XX|XX AND CR:sned%1|XX",
		"M2 AND CR:sned%1|XX|M2 AND CR:sned%1",
		"M1|M1 AND CH:sned%1|M1",
	],
	category: "joke",
	state: "liquid",
	excludeRandom: true
};

elements.uranium_tea = {
	temp: 60,
	tempHigh: 400,
	stateHigh: "molten_uranium",
	color: ["#526306", "#40530c", "#80320e", "#502e0f"],
	behavior: behaviors.RADLIQUID,
	category: "liquids",
	state: "liquid"
};

elements.powerlaser = {
	color: ["#ed0ca9","#ff2b95"],
    tick: function(pixel) {
        var x = pixel.x;
        for (var y = pixel.y; y < height; y++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.05) { continue }
                createPixel("flash", x, y);
                pixelMap[x][y].color = "#b80ced";
                pixelMap[x][y].temp = 11000;
            }
            else {
                if (elements[pixelMap[x][y].element].isGas) { continue }
                if (elements[pixelMap[x][y].element].id === elements.heat_ray.id) { break }
                pixelMap[x][y].temp += 9000;
                pixelTempCheck(pixelMap[x][y]);
                break;
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    temp: 10000,
    category: "energy",
    state: "gas",
    excludeRandom: true,
    noMix: true
};

elements.magma_bomb = {
	temp: 100,
	color: "#b83109",
	behavior: [
		"XX|EX:6>magma|XX",
		"XX|XX|XX",
		"M2|M1 AND EX:6>magma|M2"
	],
	category: "weapons",
	state: "liquid"
};

elements.quicksand = {
	viscosity: 10000,
	tempHigh: 1000,
	stateHigh: ["molten_glass", "molten_glass", "molten_glass", "molten_glass", "steam"],
	color: ["#b1873a", "#cea250"],
	behavior: behaviors.LIQUID,
    category: "land",
    state: "liquid",
	density: 1400,
	stain: 0.02
};

elements.liquid_filler = {
	color: "#ae00ff",
	behavior: [
		"XX|XX AND CR:liquid_filler%50|XX",
		"M2 AND CR:liquid_filler%50|XX|M2 AND CR:liquid_filler%50",
		"M1|M1 AND CH:liquid_filler%50|M1",
	],
	category: "special",
    state: "liquid",
	excludeRandom: true
};

elements.antimony = {
	color: ["#4b90b8", "#a3bfd8", "#89a0b6", "#8798a7", "#738092"],
	behavior: behaviors.WALL,
	category: "solids",
	state: "solid",
	density: 6697,
	tempHigh: 630,
	stateHigh: "melted_antimony",
	alias: "...sb?!"
};

elements.melted_antimony = {
	color: ["#8fb2c7", "#7494b1", "#72a1cc", "#a3aaaf", "#a4aab3"],
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "liquid",
	density: 6697,
	stain: 0.1,
	tempLow: -270,
	stateLowName: "antimony_ice"
};

elements.unstain = {
	color: "#729fff",
	behavior: [
		"XX|XX|XX",
		"XX|XX|XX",
		"XX|XX|XX"
	],
	stain: -1,
    tool: (pixel) => {
        doStaining({
            element: "unstain",
            x: pixel.x,
            y: pixel.y
        })
    },
	category: "tools",
	state: "solid",
};

elements.antmatter = {
	color: "#5f4a4a",
	behavior: [
        "M2|DB%50 AND M2 AND EX:8>ant%10|M2",
        "M1|XX|M1",
        "M1|DB%50 AND M1 AND EX:8>ant%10|M1",
    ],
	category: "others",
    state: "gas",
    density: 6.9,
	desc: "first ever others category element i guess"
};

elements.thermal_paste = {
	viscosity: 10000,
	tempHigh: 200,
	stateHigh: [null, "thermal_paste"],
	color: "#c5cfd3",
	behavior: [
		"XX|CO:1|XX",
		"CO:1 AND M2|XX|CO:1 AND M2",
		"M1|CO:1 AND M1|M1",
		],
	category: "liquids",
	state: "liquid",
};

// die

elements.glitch = {
	color: ["#ff0000", "#c300ff", "#bbff00", "#1100ff", "#00ffaa"],
	behavior: [
		"XX|XX|XX",
        "XX|CC:ff0000,c300ff,bbff00,1100ff,00ffaa|XX",
		"XX|XX|XX"
	],
	category: "special",
	conduct: 0.5,
	movable: false
};

elements.sound = {
    color: ["#1464b4","#aeeb82"],
    currentSound: null,
    onSelect: function() {
        var file = document.createElement("input");
        file.type = "file";
        file.accept = "audio/*";
        file.onchange = function() {
            setTimeout(function(){
                var reader = new FileReader();
                reader.onload = function(e) {
                    if (elements.sound.currentSound) {
                        elements.sound.currentSound.pause();
                    }
                    elements.sound.currentSound = new Audio();
                    elements.sound.currentSound.src = e.target.result;
                    elements.sound.currentSound.play();
                    file.value = "";
                }
                reader.readAsDataURL(file.files[0]);
            },500);
        }
        file.click();
    },
    tool: function() {},
    category: "special",
};

elements.vomit = {
	viscosity: 170,
	tempHigh: 100,
	stateHigh: ["dirty_water", "stench"],
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "liquid",
	stain: 0.1
};

elements.incinerate.category = "tools",
elements.cook.category = "tools",
elements.room_temp.category = "tools",

elements.beans.tempHigh = 349,
elements.beans.stateHigh = "burnt_beans"
elements.grass.onSelect = function() {
        logMessage("go touch this");
}

if (!elements.radiation.reactions) elements.egg.reactions = {};
elements.radiation.reactions.meat = { elem1: null, elem2: "radioactive_meat" },
elements.radiation.reactions.grape = { elem1: null, elem2: "radioactive_grape" },
elements.radiation.reactions.egg = { elem1: null, elem2: "radioactive_egg" },
elements.radiation.reactions.potato = { elem1: null, elem2: "radioactive_potato" },
elements.radiation.reactions.water = { elem1: null, elem2: "radioactive_water" },
elements.radiation.reactions.chocolate = { elem1: null, elem2: "radioactive_chocolate" },
elements.radiation.reactions.milk = { elem1: null, elem2: "radioactive_milk" },
elements.radiation.reactions.bread = { elem1: null, elem2: "radioactive_bread" },
elements.radiation.reactions.toast = { elem1: null, elem2: "radioactive_toast" },
elements.radiation.reactions.beans = { elem1: null, elem2: "radioactive_beans" }

if (!elements.egg.reactions) elements.egg.reactions = {};
elements.egg.reactions.water = {elem1: "boiled_egg", tempMin: 100},
elements.egg.reactions.steam = {elem1: "boiled_egg", tempMin: 100},
elements.egg.reactions.melted_chocolate = {elem1: "chocolate_egg"},
elements.egg.reactions.chocolate = {elem1: "chocolate_egg", chance: 0.1}

if (!elements.potato.reactions) elements.potato.reactions = {};
elements.potato.reactions.water = {elem1: "fries", tempMin: 100, chance:50},
elements.potato.reactions.steam = {elem1: "fries", tempMin: 100, chance:50},
elements.potato.reactions.water = {elem1: "chips", tempMin: 100, chance:50},
elements.potato.reactions.steam = {elem1: "fries", tempMin: 100, chance:50}

if (!elements.water.reactions) elements.water.reactions = {};
elements.water.reactions.cocaine = { elem1: "solid_water", elem2: null }

if (!elements.alcohol.reactions) elements.alcohol.reactions = {};
elements.alcohol.reactions.juice = {elem1:"wine", elem2:null, chance:5}

if (!elements.paper.reactions) elements.paper.reactions = {};
elements.paper.reactions.bless = { elem1: "robux", elem2: null, chance: 0.0000001 }

if (!elements.uranium.reactions) elements.uranium.reactions = {};
elements.uranium.reactions.ice_cream = {elem1: "uranium_ice_cream", elem2: null},
elements.uranium.reactions.cream = {elem1: "uranium_ice_cream", elem2: null},
elements.uranium.reactions.tea = {elem1: "uranium_tea", elem2: null}

if (!elements.dough.reactions) elements.dough.reactions = {};
elements.dough.reactions.yolk = {elem1: null, elem2: "spaghetti", tempMin: 25}

if (!elements.coffee.reactions) elements.coffee.reactions = {};
elements.coffee.reactions.milk = {elem1: null, elem2: "coffee_milk",}

elements.silver.breakInto = "silver_coin"

// sb is an idiot and he has alzheimer so here is a property list
/*
== METADATA ==
name
alias
category
desc
extraInfo
related
hidden
darkText
canPlace
nocheer
forceAutoGen

== COLOR ==
color
innerColor (dead property)
colorOn
customColor
forceSaveColor
colorPattern
colorKey

== BEHAVIOR ==
behavior
behaviorOn
tool (func)
onMouseUp (func)
onSelect (func)
onUnselect (func)
onMix (func)
tick (func)
perTick (func)
reactions

== TEMP ==
temp
tempLow
stateLow
stateLowName
stateLowColor
stateLowColorMultiplier
tempHigh
stateHigh
stateHighName
stateHighColor
stateHighColorMultiplier
extraTempLow
extraTempHigh
heatCapacity (dead property)

== PROPERTIES ==
state
density
insulate
viscosity
conduct
stain
stainSelf
charge
movable
hardness
foodNeed
properties
maxSize
baby
egg
eggColor
seed
noMix
ignoreAir
excludeRandom
cooldown
isFood
ignore
canContain

== BURN ==
burn
burning
burnTime
burnInto
extinguish
fireColor
fireElement

== FLIP ==
rotatable
flipX
flippableX
flipY
flippableY

== BREAK ==
breakInto
breakIntoColor
*/
// behaviors
behaviors.POISONED_LIQUID = [
    "XX|DL:"+eLists.ANIMAL+"|XX",
    "DL:"+eLists.ANIMAL+" AND M2|XX|DL:"+eLists.ANIMAL+" AND M2",
    "M1|DL:"+eLists.ANIMAL+" AND M1|M1",
];
behaviors.POISONED_WALL = [
    "XX|DL:"+eLists.ANIMAL+"|XX",
    "DL:"+eLists.ANIMAL+"|XX|DL:"+eLists.ANIMAL+"",
    "XX|DL:"+eLists.ANIMAL+"|XX",
];
behaviors.POISONED_POWDER = [
    "XX|DL:"+eLists.ANIMAL+"|XX",
    "DL:"+eLists.ANIMAL+"|XX|DL:"+eLists.ANIMAL+"",
    "M2|DL:"+eLists.ANIMAL+" AND M1|M2",
];
behaviors.POISONED_GAS = [
    "M2|DL:"+eLists.ANIMAL+" AND M1|M2",
    "DL:"+eLists.ANIMAL+" AND M1|XX|DL:"+eLists.ANIMAL+" AND M1",
    "M2|DL:"+eLists.ANIMAL+" AND M1|M2",
];

// changing ketchup
elements.ketchup.tempLow = -3;
elements.ketchup.stateLow = "frozen_ketchup";
elements.ketchup.tempHigh = 100;
elements.ketchup.stateHigh = "ketchup_gas";
elements.ketchup.density = 1092;
elements.ketchup.reactions ??= {};
elements.ketchup.reactions.mayonnaise = { "elem1": null, "elem2": "fry_sauce" };
elements.ketchup.reactions.plague = { "elem1": "poisoned_ketchup", "elem2": null};
elements.ketchup.reactions.infection = { "elem1": "poisoned_ketchup", "elem2": null};
elements.ketchup.reactions.fallout = { "elem1": "poisoned_ketchup", "chance":25};
elements.ketchup.reactions.gloomwind = { "elem1": "poisoned_ketchup", "elem2": null};

// making ketchup dirty
elements.dirt.reactions ??= {};
elements.dirt.reactions.ketchup = { "elem1": null, "elem2": "dirty_ketchup", "oneway":true};
elements.ash.reactions ??= {};
elements.ash.reactions.ketchup = { "elem1": null, "elem2": "dirty_ketchup", "oneway":true};
elements.dust.reactions ??= {};
elements.dust.reactions.ketchup = { "elem1": null, "elem2": "dirty_ketchup", "oneway":true};

// pyrocumulus reactions
elements.smoke.reactions.ketchup_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.smoke.reactions.poisoned_ketchup_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.smoke.reactions.ketchup_snow_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.smoke.reactions.poisoned_ketchup_snow_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.smoke.reactions.ketchup_rain_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.smoke.reactions.poisoned_ketchup_rain_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.ash.reactions.ketchup_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.ash.reactions.poisoned_ketchup_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.ash.reactions.ketchup_snow_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.ash.reactions.poisoned_ketchup_snow_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.ash.reactions.ketchup_rain_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },
elements.ash.reactions.poisoned_ketchup_rain_cloud = { "elem1": "pyrocumulus", "chance":0.08, "y":[0,15], "setting":"clouds" },

// fixing radiation reactions
elements.radiation.reactions.ketchup = { "elem1": null, "elem2": "poisoned_ketchup", "chance":25}

// elements
elements.frozen_ketchup = {
    color: "#d44737",
    behavior: behaviors.WALL,
    temp: -5,
    category:"solids",
    tempHigh: 5,
    stateHigh: "ketchup",
    state: "solid",
    density: 917,
    reactions: {
        "plague": { "elem1": "frozen_poisoned_ketchup", "elem2": null},
        "infection": { "elem1": "frozen_poisoned_ketchup", "elem2": null},
        "radiation": { "elem1": "frozen_poisoned_ketchup", "chance":25},
        "fallout": { "elem1": "frozen_poisoned_ketchup", "chance":25},
        "gloomwind": { "elem1": "frozen_poisoned_ketchup", "elem2": null},
    },
};
elements.poisoned_ketchup = {
    color: "#de0030",
    behavior: behaviors.POISONED_LIQUID,
    tempLow: -3,
    stateLow: "frozen_poisoned_ketchup",
    tempHigh: 100,
    stateHigh: "poisoned_ketchup_gas",
    viscosity: 50000,
    category:"liquids",
    state: "liquid",
    density: 1140,
    stain: 0.05,
};
elements.frozen_poisoned_ketchup = {
    color: "#d43754",
    behavior: behaviors.POISONED_WALL,
    temp: -5,
    category:"solids",
    tempHigh: 5,
    stateHigh: "poisoned_ketchup",
    state: "solid",
    density: 917,
};
elements.ketchup_spout = {
    color: "#944137",
    behavior: [
        "XX|CR:poisoned_ketchup%0.001 AND CR:ketchup|XX",
        "CR:poisoned_ketchup%0.001 AND CR:ketchup|XX|CR:poisoned_ketchup%0.001 AND CR:ketchup",
        "XX|CR:poisoned_ketchup%0.001 AND CR:ketchup|XX",
    ],
    category:"special",
};
elements.ketchup_cloud = {
    color: "#ad655c",
    behavior: [
        "XX|XX|XX",
        "XX|CO:1%5|M1%2.5 AND BO",
        "XX|XX|XX",
    ],
    category:"gases",
    temp: 110,
    tempLow: 100,
    stateLow: "ketchup_rain_cloud",
    state: "gas",
    density: 0.5,
    reactions: {
        "plague": { "elem1": "poisoned_ketchup_cloud", "elem2": null},
        "infection": { "elem1": "poisoned_ketchup_cloud"},
        "radiation": { "elem1": "poisoned_ketchup_cloud", "chance":25},
        "fallout": { "elem1": "poisoned_ketchup_cloud", "chance":25},
        "gloomwind": { "elem1": "poisoned_ketchup_cloud", "elem2": null},
        "ketchup_rain_cloud": { "elem1":"ketchup_rain_cloud", "temp1":-20 },
    },
    conduct: 0.03,
    ignoreAir: true,
};
elements.ketchup_rain_cloud = {
    color: "#6e413b",
    behavior: [
        "XX|XX|XX",
        "XX|CH:ketchup%0.05|M1%2.5 AND BO",
        "XX|XX|XX|",
    ],
    category: "gases",
    temp: 70,
    tempHigh: 100,
    stateHigh: "ketchup_cloud",
    tempLow: 0,
    stateLow: "ketchup_snow_cloud",
    state: "gas",
    density: "0.5",
    ignoreAir: true,
    conduct: 0.03,
};
elements.poisoned_ketchup_cloud = {
    color: "#a8596b",
    behavior: [
        "XX|XX|XX",
        "XX|CO:1%5|M1%2.5 AND BO",
        "XX|XX|XX",
    ],
    reactions: {
        "poisoned_ketchup_rain_cloud": { "elem1":"poisoned_ketchup_rain_cloud", "temp1": -20 },
    },
    category: "gases",
    temp: 110,
    tempLow: 100,
    stateLow: "poisoned_ketchup_rain_cloud",
    state: "gas",
    density: 0.5,
    conduct: 0.03,
    ignoreAir: true,
};
elements.poisoned_ketchup_rain_cloud = {
    color: "#633640",
    behavior: [
        "XX|XX|XX",
        "XX|CH:poisoned_ketchup%0.05|M1%2.5 AND BO",
        "XX|XX|XX",
    ],
    category: "gases",
    temp: 70,
    tempHigh: 100,
    stateHigh: "poisoned_ketchup_cloud",
    tempLow: 0,
    stateLow: "poisoned_ketchup_snow_cloud",
    state: "gas",
    density: 0.5,
    ignoreAir: true,
    conduct: 0.03,
};
elements.ketchup_snow = {
    color: "#ed7a6d",
    behavior: behaviors.POWDER,
    temp: -5,
    tempHigh: 18,
    stateHigh: "ketchup",
    category: "land",
    state: "solid",
    density: 100,
    reactions: {
        "plague": { "elem1": "poisoned_ketchup_snow", "elem2": null},
        "infection": { "elem1": "poisoned_ketchup_snow", "elem2": null},
        "radiation": { "elem1": "poisoned_ketchup_snow", chance:25},
        "fallout": { "elem1": "poisoned_ketchup_snow", chance:25},
        "gloomwind": { "elem1": "poisoned_ketchup_snow", "elem2": null},
    },
};
elements.ketchup_snow_cloud = {
    color: "#755652",
    behavior: [
        "XX|XX|XX",
        "XX|CH:ketchup_snow%0.05|M1%2.5 AND BO",
        "XX|XX|XX",
    ],
    category:"gases",
    temp: -10,
    tempHigh: 30,
    stateHigh: "ketchup_cloud",
    state: "gas",
    density: 0.55,
    reactions: {
        "plague": { "elem1": "poisoned_ketchup_snow_cloud", "elem2": null},
        "infection": { "elem1": "poisoned_ketchup_snow_cloud"},
        "radiation": { "elem1": "poisoned_ketchup_snow_cloud", chance:25},
        "fallout": { "elem1": "poisoned_ketchup_snow_cloud", chance:25},
        "gloomwind": { "elem1": "poisoned_ketchup_snow_cloud", "elem2": null},
    },
    ignoreAir: true,
};
elements.poisoned_ketchup_snow = {
    color: "#d1697f",
    behavior: behaviors.POISONED_POWDER,
    temp: -5,
    tempHigh: 18,
    stateHigh: "poisoned_ketchup",
    category: "land",
    state: "solid",
    density: 100,
};
elements.poisoned_ketchup_snow_cloud = {
    color: "#6e4e55",
    behavior: [
        "XX|XX|XX",
        "XX|CH:poisoned_ketchup_snow%0.05|M1%2.5 AND BO",
        "XX|XX|XX",
    ],
    category:"gases",
    temp: -10,
    tempHigh: 30,
    stateHigh: "poisoned_ketchup_cloud",
    state: "gas",
    density: 0.55,
    ignoreAir: true,
};
elements.mayonnaise = {
    color: "#F2EEE9",
    behavior: behaviors.LIQUID,
    viscosity: 50000,
    category:"liquids",
    state: "liquid",
    density: 1000,
    stain: 0.05,
    isFood: true,
};
elements.mustard = {
    color: "#D8AD01",
    behavior: behaviors.LIQUID,
    viscosity: 50000,
    category:"liquids",
    state: "liquid",
    density: 1052,
    stain: 0.05,
    isFood: true,
};
elements.ketchup_gas = {
    color: "#ffb5ad",
    behavior: behaviors.GAS,
    temp: 150,
    density: 0.6,
    state: "gas",
    tempLow: 95,
    stateLow: "ketchup",
    category: "gases",
    reactions: {
        "plague": { "elem1": "poisoned_ketchup_gas", "elem2": null},
        "ketchup_gas": { "elem1": null, "elem2": "ketchup_cloud", "chance":0.3, "y":[0,15], "setting":"clouds" },
        "ketchup_cloud": { "elem1": "ketchup_cloud", "chance":0.4, "y":[0, 12], "setting":"clouds" },
        "ketchup_rain_cloud": { "elem1": "ketchup_rain_cloud", "chance":0.4, "y":[0, 12], "setting":"clouds" },
        "infection": { "elem1": "poisoned_ketchup_gas"},
        "radiation": { "elem1": "poisoned_ketchup_gas", chance:25},
        "fallout": { "elem1": "poisoned_ketchup_gas", chance:25},
        "gloomwind": { "elem1": "poisoned_ketchup_gas", "elem2": null},
    },
};
elements.poisoned_ketchup_gas = {
    color: "#e096a6",
    behavior: behaviors.POISONED_GAS,
    temp: 150,
    density: 0.6,
    state: "gas",
    tempLow: 95,
    stateLow: "poisoned_ketchup",
    category: "gases",
    reactions: {
        "poisoned_ketchup_gas": { "elem1": null, "elem2": "poisoned_ketchup_cloud", "chance":0.3, "y":[0,15], "setting":"clouds" },
        "poisoned_ketchup_cloud": { "elem1": "poisoned_ketchup_cloud", "chance":0.4, "y":[0, 12], "setting":"clouds" },
        "ketchup_rain_cloud": { "elem1": "poisoned_ketchup_rain_cloud", "chance":0.4, "y":[0, 12], "setting":"clouds" },
    },
};
elements.fry_sauce = {
    color: "#E8AA7B",
    behavior: behaviors.LIQUID,
    viscosity: 50000,
    category: "liquids",
    state: "liquid",
    density: 1149,
    stain: 0.05,
    isFood: true,
};
elements.ketchup_powder = {
    color: "#E06320",
    behavior: behaviors.POWDER,
    density: 1879,
    reactions: {
        "plague": { "elem1": "poisoned_ketchup_powder", "elem2": null},
        "infection": { "elem1": "poisoned_ketchup_powder", "elem2": null},
        "radiation": { "elem1": "poisoned_ketchup_powder", chance:25},
        "fallout": { "elem1": "poisoned_ketchup_powder", chance:25},
        "gloomwind": { "elem1": "poisoned_ketchup_powder", "elem2": null},
    },
    state: "solid",
    category: "powders",
    isFood: true,
};
elements.poisoned_ketchup_powder = {
    color: "#e0204a",
    behavior: behaviors.POISONED_POWDER,
    density: 1879,
    state: "solid",
    category: "powders",
};
elements.cumin = {
    color: "#8B7778",
    behavior: behaviors.POWDER,
    category: "food",
    density: 405,
    state: "solid",
    tempHigh: 400,
    stateHigh: "ash",
    burn: 40,
    burnTime: 40,
    burnInto: "ash",
    isFood: true,
};
elements.eketchup_spout = {
    name: "E-Ketchup Spout",
    color: "#c75600",
    behavior: behaviors.WALL,
    behaviorOn: [
        "XX|CR:poisoned_ketchup%0.001 AND CR:ketchup|XX",
        "CR:poisoned_ketchup%0.001 AND CR:ketchup|XX|CR:poisoned_ketchup%0.001 AND CR:ketchup",
        "XX|CR:poisoned_ketchup%0.001 AND CR:ketchup|XX",
    ],
    category: "machines",
    conduct: 1,
    insulate: true,
    colorOn: "#fff200",
};
elements.ketchup_metal = {
    color: "#ff5c5c",
    behavior: behaviors.WALL,
    category: "solids",
    conduct: 0.47,
    tempHigh: 1500,
    density: 7197,
};
elements.antiketchup = {
    color: "#00CEE6",
    behavior: behaviors.AGLIQUID,
    viscosity: 50000,
    category:"special",
    state: "liquid",
    density: 1092,
    stain: 0.05,
};
elements.dirty_ketchup = {
    color: "#851a0d",
    behavior: behaviors.LIQUID,
    viscosity: 50000,
    category: "liquids",
    state: "liquid",
    tempHigh: 100,
    stateHigh: ["ketchup_gas", "carbon_dioxide"],
    tempLow: 0,
    stateLow: "frozen_ketchup",
    density: 1140,
    hidden: true,
    stain: 0.05,
};
elements.ketchup_gold = {
    color: ["#eb8a8a", "#bf3939", "#ff6161"],
    behavior: behaviors.WALL,
    category: "solids",
    conduct: 0.64,
    tempHigh: 1025,
    density: 10598,
}
 // alloys
 elements.molten_ketchup_metal = {
    reactions: {
        "molten_gold": { "elem1": null, "elem2": "molten_ketchup_gold" },
    }
 }

 // f&m only things
runAfterLoad(function() {
    if (enabledMods.includes("mods/fey_and_more.js")) {
        // making ketchup fairies die to iron and silver
        eLists.FAIRY.push("ketchup_fairy");
        elements.iron.behavior = [
            "XX|DL:"+eLists.FAIRY+"|XX",
            "DL:"+eLists.FAIRY+"|XX|DL:"+eLists.FAIRY+"",
            "XX|DL:"+eLists.FAIRY+"|XX"
        ];
        elements.silver.behavior = [
            "XX|DL:"+eLists.FAIRY+"|XX",
            "DL:"+eLists.FAIRY+"|XX|DL:"+eLists.FAIRY+"",
            "XX|DL:"+eLists.FAIRY+"|XX"
        ];
        
        // ketchup fairy reaction
        elements.fairy.reactions ??= {};
		elements.fairy.reactions.ketchup = { "elem1": "ketchup_fairy"};

        // f&m only elements
        elements.ketchup_fairy = {
            color: ["#d4b0b0", "#e8c5c5", "#e89595"],
            state: "solid",
            behavior: [
                "XX|M1|M1",
                "XX|FX%5|XX",
                "XX|CR:ketchup%0.1 AND CR:fairy_dust%0.005 AND M1|M1",
            ],
            category: "fey",
        };
    };
 });

/*
Changelog
Mod made by Nubo318. Contributors include DeviantEquinox and An Orbit.
Version 1.3.3

Version 1.3.3 (23rd of August 2023)
+ All liquids added on this mod can now stain stuff, with the exception of molten metals
+ Certain elements can now be mixed with dough and batter
~ Fixed reactions that turned clouds into pyrocumulus when in contact with with smoke or ash
~ Optimized the way in which new reactions of vanilla elements are coded
~ Changed the initial temperature of multiple elements
~ Fixed a bug that caused Ketchup Snow and its poisoned variant to not display their info properly
~ Ketchup clouds now work more similarly to vanilla clouds

Version 1.3.2 (22nd of August 2023)
- Removed some elements due to their inclusion or some form of it in the vanilla game, including:
    - Tomato
    - Tomato Sauce
    - Sugary Tomato Sauce
- Removed a vanilla reaction which turned ketchup into sauce when exposed to radiation

Version 1.3.1 (20th of January 2022)
~ Ketchup fairies are now killed by iron and silver

Version 1.3.0 (20th of January 2022)
+ Ketchup Gold, an alloy between ketchup metal and gold
+ Dirty Ketchup
+ Ketchup clouds can now react with smoke to form pyrocumulus
+ Infection now poisons ketchup stuff
+ Tomatoes and cumin now turn into ash at high temperatures
+ Radiation can poison ketchup stuff
+ Ketchup Fairies (Needs Fey & More)
+ Gloomwind can poison ketchup stuff (Needs Fey & More)
~ Changed the density of poisoned ketchup
~ Moved the ketchup powders to the "Powders" category and tomatoes and cumin to the "Food" category

Version 1.2.1 (16th of January 2022)
+ Ketchup gases can now form ketchup clouds when high up
~ Moved ketchup clouds to gases category
~ E-Ketchup Spout now has the id eketchup_spout, though remains called E-Ketchup Spout
~ Updated to Sandboxels 0.9
~ Now used with the in-game mod manager

Version 1.2.0 (10th of January 2022)
+ Ketchup Gas + a poisoned variant
+ Fry Sauce
+ Combining mayonnaise and ketchup creates fry sauce
+ Ketchup Powder + a poisoned variant
+ Tomatos and Tomato Sauce
+ Smashing tomatos with rocks creates tomato sauce
+ Tomato sauce can be combined with sugar to make sugary tomato sauce, which can then be combined with vinegar to make ketchup
+ Cumin
+ Combining plague with ketchup stuff changes it to its poisoned variant
+ E-Ketchup Spout, a ketchup spout that works only with electricity
+ Ketchup Metal
+ Antiketchup
~ Made the density of ketchup more accurate (hopefully).
~ Updated to Sandboxels 0.8.2
~ Poisoned stuff doesn't kill diagonally anymore
~ Technical: Element properties don't use quotation marks anymore.

Version 1.1.0 (6th of January 2022)
+ Ketchup Snow (+poisoned and cloud variants)
+ Mayonnaise
+ Mustard
~ Fixed: Ketchup can now freeze again

Version 1.0.1 (6th of January 2022)
~ Updated to Sandboxels 0.8.1
~ Frozen ketchup and frozen poisoned ketchup now starth with a temperature of 0C

Version 1.0.0 (technically not the first version, but I'm to lazy to see in which order we added these things)
+ Frozen Ketchup
+ Ketchup Spout - Water spout but ketchup, also has a 0.001% chance of spawning poisoned ketchup because why not.
+ Poisoned Ketchup - Ketchup that kills animals
+ Frozen Poisoned Ketchup
+ Ketchup Cloud - Rain cloud but ketchup
+ Poisoned Ketchup Cloud
*/
elements.chowder = {
	color: "#c7c98b",
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
   reactions: {
        "water": { elem1: null, elem2: "soup" },
		    },
		};
		
		elements.soup = {
	color: "#c28719",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
	stateHigh: "chowder",
	tempHigh: 100
		};
		
		elements.rice = {
	color: "#f6f8ed",
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
   reactions: {
	   "broth": { elem1: "risotto", elem2: null },
	   "beans": { elem1: null, elem2: "feijoada"},
            },
		};
		
		elements.risotto = {
	color: "#ffff7f",
	behavior: behaviors.SUPPORTPOWDER,
	category: "food",
	state: "solid",
		};
		
		elements.feijoada = {
	color: "#291800",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "liquid",
	viscosity: 9
		};
		
		elements.mentos = {
	color: "#a9fff9",
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
		reactions: {
		"soda": { elem1: "foam", elem2: "foam" },
		"sprite": { elem1: "foam", elem2: "foam" } ,
	}
		};
		
		elements.sprite = {
	color: "#b2f3ad",
    behavior: elements.soda.behavior,
	category: "food",
	state: "liquid",
		};
		
		elements.fanta = {
	color: "#ffd500",
    behavior: elements.soda.behavior,
	category: "food",
	state: "liquid",
		};
		
		elements.steampunk_soda = {
	color: "#0fda2f",
    behavior: [
    "XX|CR:radiation,foam%2|XX",
    "M2 AND CR:radiation%2|XX|M2 AND CR:radiation%2",
    "M1|M1|M1",
],
	category: "food",
	state: "liquid",
		};
		
		elements.lime = {
	color: "#b4ff15",
    behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	    reactions: {
        "seltzer": { elem1: null, elem2: "sprite" },
    },
		};
		
		elements.orange = {
	color: "#ffa500",
    behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	    reactions: {
        "seltzer": { elem1: null, elem2: "fanta" },
    },
		};
		
		elements.steampunk_syrup = {
	color: "#0fda2f",
    behavior: behaviors.RADLIQUID,
	category: "food",
	state: "liquid",
		  reactions: {
        "seltzer": { elem1: null, elem2: "steampunk_soda" },
		"flour": { elem1: "steampunk_dough", elem2: null },
    },
		};
		
		elements.steampunk_dough = {
	color: "#0fda2f",
    behavior: [
	"XX|CR:radiation%2|XX",
    "M2 AND CR:radiation%2|XX|M2 AND CR:radiation%2",
    "XX|M1|XX",
	],
	category: "food",
	state: "liquid",
	tempHigh: 135,
	stateHigh: "steampunk_bread",
		};
		
		elements.steampunk_bread = {
	color: "#0fda2f",
    behavior: behaviors.RADSOLID,
	category: "food",
	state: "solid",
	tempHigh: 135,
	stateHigh: "steampunk_syrup",
		};
		
		elements.salami = {
	color: ["#bb0e0e", "#bb0e0e", "#bb0e0e", "#ffffff"],
    behavior: behaviors.SOLID,
	category: "food",
	state: "solid",
	reactions: {
        "flour": { elem1: "slommi", elem2: null },
    },
		};
		
		elements.slommi = {
	color: ["#bb0e0e", "#ffb1b1"],
    behavior: behaviors.SOLID,
	category: "food",
	state: "solid",
	hidden: true,
		};
		
		if (!elements.milk.reactions) elements.milk.reactions = {};
elements.milk.reactions.corn = { elem1: null, elem2: "chowder" }
/*
A Sandboxels mod dedicated to creating yummy ice cream creations! My first Sandboxels mod.
Made by rottenEgghead @ https://github.com/rottenEgghead

Current elements: Waffle cone, Strawberry, Sprinkles, Chocolate chips, Oreos, M&Ms, Cherries, Banana, Coconut (shavings/water)
Current renamed elements: Chocolate -> Chocolate bar, Nut -> Peanut
Current tools: Freeze

** v.1.0 **
N/A
*/

var mainCat = "food";
var smallDensity = 233.95;
var foodTempHigh = 176;
var defChance = 0.05;

if (!elements.ice_cream.reactions) { elements.ice_cream.reaction = {}; };
elements.ice_cream.temp = -15;
elements.ice_cream.reactions = {
    "strawberry": { color1: ["#f5dad7", "#ffbfbf", "#f7a3a3"], chance: defChance },
    "gingerbread": { color1: ["#f0cbad", "#dec4af"], chance: defChance },
    "coffee": { color1: [], chance: defChance },
    "crumb": { color1: ["#f0cbad", "#dec4af"], chance: defChance },
    "oreo_crumb": { color1: ["#e8e2e1", "#666161", "#8a8888"], chance: defChance },
    "oreo": { color1: ["#e8e2e1", "#666161", "#8a8888"], chance: defChance },
    "mnms": { color1: ["#ebe6e6", "#ebe6e6", "#ffd9d9", "#fffcd9", "#ddffd9", "#d9d9ff"], chance: defChance },
    "nut_butter": { color1: ["#f0ece9", "#f5cd98", "#cfaf84"], chance: defChance },
    "melted_chocolate": { color1: ["#785E4C", "#8c664c", "#b37449"], chance: defChance },
};

elements.chocolate.name = "Chocolate Bar";
elements.chocolate.behavior = behaviors.WALL;
elements.chocolate.breakInto = "chocolate_chips";

elements.coffee.tempLow = -15;
elements.coffee.hidden = false;

elements.nut.name = "Peanut";
elements.nut_butter.name = "Peanut Butter";
elements.nut_meat.name = "Peanut Meat";
elements.nut_milk.name = "Peanut Milk";



/* Tools */
elements.freeze = {
    color: ["#BCE7FF", "#65C7FF", "#BCE7FF", "#65C7FF", "#BCE7FF", "#65C7FF"],
    tool: function (pixel) {
        if (!shiftDown) {
            pixel.temp -= 0.5;
            pixelTempCheck(pixel);
        } else {
            pixel.temp -= 1;
            pixelTempCheck(pixel);
        }
    },
    category: "energy",
    excludeRandom: true,
};



/* Elements */
elements.strawberry = {
    color: "#e63e57",
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    hidden: false,
    isFood: true,

    breakInto: "juice",
    breakIntoColor: "#db4f64",
    stateHigh: ["steam", "sugar"],
    density: 1154,
};
elements.banana = {
    color: ["#F5D273", "#FFE093"],
    behavior: behaviors.STURDYPOWDER,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempHigh: 142,
    density: 876,
};
elements.coconut = {
    color: ["#503733", "#402926"],
    behavior: behaviors.WALL,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempLow: 0,
    burnInto: "steam",
    breakInto: ["coconut_shavings", "coconut_water", "coconut_water"],
    density: 352,
};
elements.coconut_shavings = {
    color: ["#E7E1DF", "#F5F1F0"],
    behavior: behaviors.POWDER,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempLow: 0,
    burnInto: "steam",
    density: 233,
};
elements.coconut_water = {
    color: "#D7E0DF",
    behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
    hidden: true,
    isFood: true,

    tempLow: 0,
    burnInto: "steam",
    density: 1000,
};
elements.waffle_cone = {
    color: ["#d49d66", "#bf8449"],
    behavior: behaviors.WALL,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempHigh: foodTempHigh,
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke", "smoke", "smoke", "ash"],
    breakInto: "crumb",
    breakIntoColor: "#d49d66",
    density: smallDensity,
};
elements.sprinkles = {
    color: ["#eb726a", "#ebca6a", "#88eb6a", "#6aaceb", "#eb6ade"],
    behavior: behaviors.POWDER,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempHigh: foodTempHigh,
    stateHigh: "caramel",
    density: smallDensity,
};
elements.chocolate_chips = {
    color: "#382a20",
    behavior: behaviors.POWDER,
    category: mainCat,
    state: "solid",
    hidden: true,
    isFood: true,

    tempHigh: 31,
    stateHigh: "melted_chocolate",
    density: 1325,
};
elements.oreo = {
    color: "#302c2b",
    behavior: behaviors.STURDYPOWDER,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempHigh: foodTempHigh,
    stateHigh: "caramel",
    breakInto: "oreo_crumb",
    density: smallDensity,
};
elements.oreo_crumb = {
    color: "#302c2b",
    behavior: behaviors.POWDER,
    category: mainCat,
    state: "solid",
    hidden: true,
    isFood: true,

    tempHigh: foodTempHigh,
    stateHigh: "caramel",
    density: smallDensity,
};
elements.mnms = {
    name: "M&Ms",
    color: ["#f71f14", "#f2d622", "#2279f2", "#45f222", "#5e3f32"],
    behavior: behaviors.POWDER,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempHigh: 31,
    stateHigh: "melted_chocolate",
    density: 1325,
};
elements.cherry = {
    name: "Cherries",
    color: "#ab261d",
    behavior: behaviors.WALL,
    category: mainCat,
    state: "solid",
    hidden: false,
    isFood: true,

    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 1154,
    breakInto: "jelly",
    breakIntoColor: ["#8c142a", "#800a20"],
};
// changelog

// 1.0 update - the base update
// added seasoning
// added seasoned_water

// 1.1 update - soup update
// adds soup
// changed seasoning to a SUPPORT behaviour
// seasoned water at high temp is soup
// changed seasoning density

elements.seasoning = {
    color: "#876461",
    behavior: behaviors.SUPPORT,
    category: "food",
    tempHigh: 9000,
    stateHigh: "ash",
    state: "solid",
    reactions: {
        "water": { elem1: "seasoned_water", elem2: "null" },
        "salt_water": { elem1: "seasoned_water", elem2: "null" },
    },
    density: 3000,
};

elements.seasoned_water = {
    color: "#73d627",
    behavior: behaviors.LIQUID,
    tempHigh: 100,
    stateHigh: "soup",
    tempLow: 0,
    stateLow: "ice",
    category: "liquids",
    heatCapacity: 4.184,
    reactions: {
        "dirt": { 
            elem1: null, 
            elem2: "mud",
        },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "salt": { elem1: "salt_water", elem2: null, temp1:-20 },
        "sugar": { elem1: "sugar_water", elem2: null },
        "honey": { elem1: "sugar_water" },
        "caramel": { elem1: "sugar_water" },
        "molasses": { elem1: "sugar_water" },
        "dust": { elem1: "dirty_water", elem2: null },
        "ash": { elem1: "dirty_water", elem2: null },
        "cyanide": { elem1: "dirty_water", elem2: null },
        "cyanide_gas": { elem1: "dirty_water", elem2: null },
        "carbon_dioxide": { elem1: "seltzer", elem2: null, oneway:true },
        "sulfur": { elem1: "dirty_water", elem2: null },
        "rat": { elem1: "dirty_water", chance:0.005 },
        "plague": { elem1: "dirty_water", elem2: null },
        "rust": { elem1: "dirty_water", chance:0.005 },
        "lead": { elem1: "dirty_water", chance:0.005 },
        "solder": { elem1: "dirty_water", chance:0.005 },
        "fallout": { elem1: "dirty_water", chance:0.25 },
        "radiation": { elem1: "dirty_water", chance:0.25 },
        "uranium": { elem1: "dirty_water", chance:0.25 },
        "rotten_meat": { elem1: "dirty_water", chance:0.25 },
        "rotten_cheese": { elem1: "dirty_water", chance:0.25 },
        "cancer": { elem1: "dirty_water", chance:0.25 },
        "oil": { elem1: "dirty_water", chance:0.005 },
        "dioxin": { elem1: "dirty_water", chance:0.1 },
        "quicklime": { elem1: "slaked_lime", elem2: "slaked_lime", temp2:100, temp1:100, chance:0.05 },
        "rock": { elem2: "wet_sand", chance: 0.00035 },
        "limestone": { elem2: "wet_sand", chance: 0.00035 },
        "tuff": { elem2: "wet_sand", color2:"#7a6b5c", chance: 0.00035 },
        "ruins": { elem2: "rock", chance: 0.00035 },
        "mudstone": { elem2: "mud", chance: 0.00035 },
        "methane": { elem1:"primordial_soup", elem2:"primordial_soup", tempMin:60, charged:true },
        "ammonia": { elem1:"primordial_soup", elem2:"primordial_soup", tempMin:60, charged:true },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cured_meat": { elem1:"salt_water", elem2:"meat" },
        "aluminum": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.0025 },
        "zinc": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.015 },
        "steel": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.0125 },
        "iron": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.0125 },
        "tin": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.01 },
        "brass": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.001 },
        "bronze": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.001 },
        "copper": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.0075 },
        "silver": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.0075 },
        "gold": { elem1:["hydrogen","hydrogen","oxygen"], charged:true, chance:0.0075 },
    },
    state: "liquid",
    density: 999,
    conduct: 0.02,
    stain: -0.9,
    extinguish: true
};

elements.soup = {
	color: "#e8c238",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
    density: 7000,
};
/*addMod("mossstuff.js");
removeMod("pizzasstuff.js");

reload(); */

alert("THIS MOD IS NO LONGER SUPPORTED!\nThe mod 'pizzasstuff.s' and all of its contents have been moved to mossstuff.js.\nPlease install mossstuff.js to continue getting updates.");


elements.freeze_ray = {
	color: ["#8cf9ff","#5c59ff"],
    tick: function(pixel) {
        var x = pixel.x;
        for (var y = pixel.y; y < height; y++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.05) { continue }
                createPixel("flash", x, y);
                pixelMap[x][y].color = "#96b6ff";
                pixelMap[x][y].temp = -257;
            }
            else {
                if (elements[pixelMap[x][y].element].isGas) { continue }
                if (elements[pixelMap[x][y].element].id === elements.heat_ray.id) { break }
                pixelMap[x][y].temp -= 100;
                pixelTempCheck(pixelMap[x][y]);
                break;
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    temp: -257,
    category: "energy",
    state: "gas",
    excludeRandom: true,
    noMix: true
};

elements.devil_ray = {
	color: ["#ba0000","#8f0000"],
    tick: function(pixel) {
        var x = pixel.x;
        for (var y = pixel.y+1; y < height; y++) {
            if (outOfBounds(x, y)) {
                break;
            }
            if (isEmpty(x, y)) {
                if (Math.random() > 0.1) { continue }
                createPixel("flash", x, y);
				pixelMap[x][y].color = ["#990000"];
            }
            else {
                if (elements[pixelMap[x][y].element].id === elements.flash.id) { continue }
                if (elements[pixelMap[x][y].element].id === elements.god_ray.id) { break }
                if (!elements[pixelMap[x][y].element].isGas && isEmpty(x, y-1)) {
                    createPixel("curse", x, y-1);
                }
                if (Math.random() > 0.1) { continue }
                elements.bless.tool(pixelMap[x][y])
            }
        }
        deletePixel(pixel.x, pixel.y);
    },
    category: "energy",
    state: "gas",
    density: 1,
    excludeRandom: true,
    noMix: true
};

elements.beer = {
	color: ["#ffc43d","#ffc43d"],
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 100,
    stateHigh: ["fire","steam","steam"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.root_beer = {
	color: ["#8b2f02","#732803"],
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    tempHigh: 100,
    stateHigh: ["fire","steam","steam"],
    isFood: true,
};

elements.fruit_slushy = {
	color: ["#d43968","#ec5885","#f57ca1","#fba9c2","#ffe3eb"],
	stateLowColorMultiplier: 1.3,
	stateLow: "slushy_ice",
	tempLow: "-50",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 100,
    stateHigh: ["fire","steam","steam"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.mold = {
	color: ["#b6d7a8","#6d9d5c","#ad8d6f"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
};

elements.chocolate_slushy = {
	color: ["#c3ae9a","#ae967f","#977b5f","#876b4f","#816346"],
	stateLowColorMultiplier: 1.3,
	tempLow: "-50",
	stateLow: "slushy_ice",
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 100,
    stateHigh: ["fire","steam","steam"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.chocolate_sauce = {
	color: ["#491904","#54240b","#5e2d0b","#69371b","#764636"],
	density: 10,
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.chocolate_ice_cream = {
	color: ["#a47551","#523a28"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 1096,
	tempHigh: 15,
	stateHigh: "cream",
	temp: 0,
    isFood: true,
};

elements.fruit_ice_cream = {
	color: ["#f8d8d8","#f6c1c1","#e39898"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 1096,
	tempHigh: 15,
	stateHigh: "cream",
	temp: 0,
    isFood: true,
};

elements.snow_cone = {
	color: ["#ebfeed","#f4fff5","#fefaff","#fff3fe","#fcf2fb"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 1096,
	tempHigh: 15,
	stateHigh: "smashed_ice",
	temp: 0,
    isFood: true,
};

elements.mint_ice_cream = {

	color: ["#ebfdff","#d5fff7","#ceffe9","#dfffde","#daffd5"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 1096,
	tempHigh: 15,
	stateHigh: "cream",
	temp: 0,
    isFood: true,
	reactions: {
        "chocolate": { elem1: "mint_chocolate_ice_cream", elem2: null },
	}
};

elements.mint_chocolate_ice_cream = {
	color: ["#311e08","#d5fff7","#ceffe9","#dfffde","#daffd5",],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 1096,
	tempHigh: 15,
	stateHigh: "cream",
	temp: 0,
    isFood: true,
};


elements.chocolate_yogurt = {
	color: ["#a87848","#a57e57","#c1a07f","#e2c5ac","#efd0b1"],
	stateLowColorMultiplier: 1.3,
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	tempLow: 0,
	stateHigh: ["fire","steam","steam"],
	tempHigh: 450,
	stateLow: "frozen_chocolate_yogurt",
    isFood: true,
};

elements.fruit_yogurt = {
	color: ["#ffc3d8","#ffabd6","#ff96c5","#ff84c2","#ff5daf"],
	stateLowColorMultiplier: 1.3,
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	tempLow: 0,
	stateLow: "frozen_fruit_yogurt",
    isFood: true,
	stateHigh: ["fire","steam","steam"],
	tempHigh: 450,
};

elements.frozen_fruit_yogurt = {
	color: ["#ffdfdf","#ffc0c0","#ff9b9b"],
	stateHighColorMultiplier: 0.7,
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 902,
	tempHigh: 0,
	stateHigh: "fruit_yogurt",
	temp: 0,
    isFood: true,
};

elements.frozen_chocolate_yogurt = {
	color: ["#a87848","#a57e57","#c1a07f","#e2c5ac","#efd0b1"],
	stateHighColorMultiplier: 0.7,
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	density: 902,
	tempHigh: 0,
	stateHigh: "chocolate_yogurt",
	temp: 0,
    isFood: true,
};

elements.frying_oil = {
	color: "#c4ab4f",
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "solid",
	reactions: {
        "meat": { elem1: null, elem2: "chicken_nuggets" },
		"potato": { elem1: null, elem2: "fries" },
		"advanced_dough": { elem1: null, elem2: "churros" },
		"snow": { elem1: null, elem2: "fried_snow" },
	},
    tempHigh: 350,
    stateHigh: ["fire","steam","steam"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.chicken_nuggets = {
	color: ["#8f411c","#a35935"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.advanced_dough = {
	color: ["#f3e6c6","#f9e8a2","#ebd27b","#dba94e","#c08932"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	tempHigh: 94,
	stateHigh: "croissant",
	reactions: {
        "electric": { elem1: "steampunk_pancakes", elem2: null },
	}
};

elements.fries = {
	color: ["#f4c63e","#f6d165","#f8dd8b"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
};

elements.fried_snow = {
	color: ["#f6c66a","#d29829","#905c1b"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.battery_acid = {
	color: ["#8fff00","#1de446"],
	behavior: behaviors.LIQUID,
	category: "machines",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["steam","dioxin","stench"],
    burn:3,
    burnTime:500,
    burnInto: ["steam","dioxin","stench"],
    isFood: true,
};


elements.steampunk_pancakes = {
	color: "#252a33",
	behavior: behaviors.POWDER,
	category: "machines",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
	//I have no idea why i added this, but when i removed it and started the mod, the mod removed itself. Words can't explain my fucking confusion.
};


elements.churros = {
	color: ["#ce9958","#b8732d","#9f633b"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
	reactions: {
		"chocolate": { elem1: "chocolate_churros", elem2: null },
		"chocolate_sauce": { elem1: "chocolate_churros", elem2: null },
	}
};

elements.chocolate_churros = {
	color: ["#9f6204","#875200","#764100","#582c00","#492100"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
};

/*elements.color_pick = {
	color: ["#ff0000","#ffd100","#00ff4b","#0005ff"],
    behavior: [
        "CF|CF|CF",
        "CF|DL%5|CF",
        "CF|CF|CF",
    ],
    category: "tools",
    maxSize: 0,
    darkText: true,
    canPlace: false,
    desc: "Use on a pixel to select its element."
};*/

elements.croissant = {
	color: ["#c68028","#ad7023","#905c1b","#794d16","#674112"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	breakInto: "crumb",
	tempHigh: 550,
	stateHigh: "ash",
	burnInto: "smoke"
};

elements.eggy_dough = {
	color: ["#df8c43","#e5a369","#ecba8e","#f2d1b4","#f9e8d9"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	tempHigh: 75,
	stateHigh: "french_toast",
	burnInto: "smoke"
};

elements.french_toast = {
	color: ["#a77644","#af7b4b","#af7f57"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "crumb",
	tempHigh: 550,
	stateHigh: "ash",
	burnInto: "smoke"
};

elements.rose_sauce = {
	color: ["#db2300","#e24f33"],
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.seasoning = {
	color: ["#945239","#896251"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.parmesan = {
	color: ["#ffffdd","#ffffe4","#ffffeb","#fffff1","#fffff8"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.baking_powder = {
	color: "#fffaed",
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	reactions: {
        "flour": { elem1: null, elem2: "advanced_dough" },
    },
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    isFood: true,
};

elements.smashed_ice = {
	color: ["#e3fdff","#d1f7ff","#c0f7ff"],
	behavior: behaviors.LIQUID,
	category: "food",
	state: "solid",
	 reactions: {
        "grape": { elem1: null, elem2: "fruit_slushy" },
        "blood_orange": { elem1: null, elem2: "fruit_slushy" },
        "canary_melon": { elem1: null, elem2: "fruit_slushy" },
        "honeydew_melon": { elem1: null, elem2: "fruit_slushy" },
        "cranberry": { elem1: null, elem2: "fruit_slushy" },
        "pitaya": { elem1: null, elem2: "fruit_slushy" },
        "coconut": { elem1: null, elem2: "fruit_slushy" },
        "cloudberry": { elem1: null, elem2: "fruit_slushy" },
        "crabapple": { elem1: null, elem2: "fruit_slushy" },
        "cactus_pear": { elem1: null, elem2: "fruit_slushy" },
        "pear": { elem1: null, elem2: "fruit_slushy" },
        "purpleberry": { elem1: null, elem2: "fruit_slushy" },
        "yellowberry": { elem1: null, elem2: "fruit_slushy" },
        "pomegranate": { elem1: null, elem2: "fruit_slushy" },
        "guava": { elem1: null, elem2: "fruit_slushy" },
        "raspberry": { elem1: null, elem2: "fruit_slushy" },
        "gooseberry": { elem1: null, elem2: "fruit_slushy" },
        "fig": { elem1: null, elem2: "fruit_slushy" },
        "durian": { elem1: null, elem2: "fruit_slushy" },
		"passionfruit": { elem1: null, elem2: "fruit_slushy" },
		"starfruit": { elem1: null, elem2: "fruit_slushy" },
		"rambutan": { elem1: null, elem2: "fruit_slushy" },
		"nance": { elem1: null, elem2: "fruit_slushy" },
		"nectarine": { elem1: null, elem2: "fruit_slushy" },
		"loganberry": { elem1: null, elem2: "fruit_slushy" },
		"currant": { elem1: null, elem2: "fruit_slushy" },
		"banana": { elem1: null, elem2: "fruit_slushy" },
		"blackberry": { elem1: null, elem2: "fruit_slushy" },
		"blueberry": { elem1: null, elem2: "fruit_slushy" },
		"green_apple": { elem1: null, elem2: "fruit_slushy" },
		"lemon": { elem1: null, elem2: "fruit_slushy" },
		"green_grape": { elem1: null, elem2: "fruit_slushy" },
		"cherry": { elem1: null, elem2: "fruit_slushy" },
		"apple": { elem1: null, elem2: "fruit_slushy" },
		"orange": { elem1: null, elem2: "fruit_slushy" },
		"kiwi": { elem1: null, elem2: "fruit_slushy" },
		"strawberry": { elem1: null, elem2: "fruit_slushy"},
		"chocolate": { elem1: null, elem2: "chocolate_slushy" },
		"chocolate_sauce": { elem1: null, elem2: "chocolate_slushy" },
    },
	density: 100,
	tempHigh: 25,
	stateHigh: "water",
	tempLow: -100,
	stateLow: "snow_cone",
};

elements.anti_torch = {
	color: "#d68542",
    behavior: [
        "XX|CR:cold_fire|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    reactions: {
        "water": { elem1:"wood" },
        "sugar_water": { elem1:"wood" },
        "salt_water": { elem1:"wood" },
        "seltzer": { elem1:"wood" },
        "dirty_water": { elem1:"wood" },
        "pool_water": { elem1:"wood" },
        "steam": { elem1:"wood" },
        "smog": { elem1:"wood" },
        "rain_cloud": { elem1:"wood" },
        "cloud": { elem1:"wood" },
        "snow_cloud": { elem1:"wood" },
        "hail_cloud": { elem1:"wood" },
        "thunder_cloud": { elem1:"wood" },
        "ice_nine": { elem1:"wood" }
    },
    temp:-250,
    category: "special",
    breakInto: "sawdust",
	insulate: true,
};

elements.moss = {
	color: ["#355438","#416044","#4c7450","#68946c","#81a984"],
	behavior: behaviors.STURDYPOWDER,
	category: "life",
	state: "solid",
	burn: 5,
	burnTime: 15,
	density: 1400,
	breakInto: "dead_plant",
	tempHigh: 120,
	stateHigh: "dead_plant",
	tempLow: -4,
	stateLow: "frozen_plant",
	alias: "mercedes benz",
	reactions: {
        "dna": { elem1: "moth", elem2: null },
	}
	
};

elements.moth = {
	color: ["#df8830","#e9b477","#a1591a","#a87a46","#4e3212"],
	behavior: behaviors.FLY,
	category: "life",
	state: "solid",
	burn: 95,
	burnTime: 25,
	density: 600,
	breakInto: "dead_bug",
	tempHigh: 100,
	stateHigh: "ash",
	tempLow: 0,
	stateLow: "dead_bug",
};

elements.holy_fire = {
	color: ["#FEFFF8","#FFF0CE","#FFE792"],
    behavior: [
        "M1|M1|M1",
        "M2|CH:bless%8|M2",
        "XX|M2|XX",
    ],
    reactions: {
        "fire": { elem1: "bless", elem2: "bless" },
        "plasma": { elem1: "light", elem2: "light" }
    },
    temp:750,
    tempLow:200,
	tempHigh:1200,
	stateLow: "bless",
    stateHigh: "bless",
    category: "energy",
    state: "gas",
    density: 0.1,
    ignoreAir: true
};

elements.curse = {
	color: ["#d27979","#bf4040","#752727"],
    tool: function(pixel) {
        if (elements.bless.ignore.indexOf(pixel.element) !== -1) { return; }
        if (pixel.burning) { // stop burning
            delete pixel.burning;
            delete pixel.burnStart;
        }
        if (pixel.temp > 100) {
            pixel.temp = (pixel.temp+100)/2;
            pixelTempCheck(pixel);
            if (pixel.del) {return}
        }
        if (pixel.temp < -200) {
            pixel.temp = (pixel.temp-200)/2;
            pixelTempCheck(pixel);
            if (pixel.del) {return}
        }
        if (pixel.origColor) {
            pixel.color = "rgb("+pixel.origColor.join(",")+")";
            delete pixel.origColor;
        }
        if (pixel.charge) {
            delete pixel.charge;
            pixel.chargeCD = 16;
        }
        if (elements.bless.reactions[pixel.element] && Math.random()<0.25) {
            var r = elements.bless.reactions[pixel.element];
            var elem2 = r.elem2;
            if (elem2 !== undefined) {
                if (Array.isArray(elem2)) { elem2 = elem2[Math.floor(Math.random()*elem2.length)]; }
                if (elem2 === null) { deletePixel(pixel.x,pixel.y) }
                else { changePixel(pixel, elem2); }
            }
            if (r.func) { r.func(pixel,pixel) }
        }
    },
    ignore: ["sun"],
    behavior: [
        "M2|M1|M2",
        "M1|DL%25|M1",
        "M2|M1|M2",
    ],
    reactions: {
        "cell": { elem2: "cancer" },
        "iron": { elem2: "rust" },
        "copper": { elem2: "oxidized_copper" },
        "antibody": { elem2:["blood",null] },
        "antibody_ice": { elem2:"blood_ice" },
        "dirty_water": { elem2: "water" },
        "dna": { elem2: "plague" },
        "antibody": { elem2: ["infection",null] },
        "infection": { elem2: ["infection",null] },
        "antidote": { elem2: "poison" },
        "meat": { elem2: "rotten_meat" },
        "cheese": { elem2: "rotten_cheese" },
        "oxygen": { elem2: "carbon_dioxide" },
        "hydrogen": { elem2: "acid_gas" },
        "cloud": { elem2: "fire_cloud" },
        "perfume": { elem2: "liquid_stench" },
        "fragrance": { elem2: "stench" },
        "seltzer": { elem2: "soda" },
        "cloud": { elem2: "smog" },
        "water": { elem2: "broth" },
        "bless": { elem2: "plasma" },
        "metal_scrap": { elem2: "grenade" },
        "smoke": { elem2: "greek_fire" },
        "rock": { elem2: "uranium", chance: 0.01},
        "magma": { elem2: "molten_uranium", chance: 0.01},
        "ice": { elem2: "ice_nine", chance: 0.01},
        "frog": { elem2: "frozen_frog" },
        "worm": { elem2: "frozen_worm" },
        "rock": { elem2: "molten_thermite", chance: 0.01},
        "glass": { elem2: "rad_glass", chance: 0.2 },
        "shard": { elem2: "rad_shard", chance: 0.2 },
        "steam": { elem2: "rad_steam", chance: 0.2 },
        "rain_cloud": { elem2: "rad_cloud", chance: 0.2 },
        "ball": { elem2: "ball", chance: 0.2 },
        "bone": { elem2: "bone_marrow", chance: 0.2 },
        "plant": { elem2: "dead_plant" },
        "rock": { elem2: "rock", chance: 0.01 },
        "magma": { elem2: "molten_slag", chance: 0.01 },
        "light": { elem2: "laser", chance: 0.2 },
        "flash": { elem2: "light", chance: 0.2 },
        "wood": { elem2: "torch", chance: 0.01 },
        "gold": { elem2: "lead", chance: 0.2 },
        "molten_gold": { elem2: "molten_lead", chance: 0.2 },
        "grass": { elem2: null },
        "rainbow": { elem2: "static" },
    },
    temp:20,
    state: "gas",
    density: 0.001,
    canPlace: true,
    category: "energy",
    stain: -0.5
};

elements.parrot = {
	color: ["#234d20","#36802d","#77ab59","#c9df8a","#f0f7da","#f90f0b","#f7ab4d","#fdfc0d","#0564b2","#60a3e6"],
	behavior: behaviors.FLY,
	category: "life",
	state: "solid",
	burn: 40,
	burnTime: 100,
	density: 400,
	breakInto: ["feather","blood"],
	tempHigh: 120,
	stateHigh: "cooked_meat",
	tempLow: -18,
	stateLow: "frozen_meat",
	reactions: {
        "fly": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "firefly": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "bee": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "worm": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "ant": { elem2:null, chance:0.025, func:behaviors.FEEDPIXEL },
        "dead_bug": { elem2:null, chance:0.04, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.04, func:behaviors.FEEDPIXEL },
        "termite": { elem2:null, chance:0.025, func:behaviors.FEEDPIXEL },
        "flea": { elem2:null, chance:0.025, func:behaviors.FEEDPIXEL },
        "mushroom_cap": { elem2:null, chance:0.025, func:behaviors.FEEDPIXEL },
        "mushroom_gill": { elem2:null, chance:0.025, func:behaviors.FEEDPIXEL },
        "seeds": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "flower_seed": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "wheat_seed": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "corn_seed": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "potato_seed": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "grass_seed": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.025, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "plague": { elem1:"plague", chance:0.05 },
        "oxygen": { elem2:"carbon_dioxide", chance:0.5 }
    },
    foodNeed: 20,
    temp: 41,
    tempHigh: 120,
    stateHigh: "cooked_meat",
    stateHighColor: "#E4CFB9",
    tempLow: -18,
    stateLow: "frozen_meat",
    category:"life",
    burn:50,
    burnTime:100,
    breakInto: ["feather","blood"],
    state: "solid",
    density: 400,
    conduct: 0.5
};

elements.cherry = {
	color: ["#ff0000","#e30202","#c00000","#9c0101"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: "#450008",
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#bf4545","#982828"] },
	}
};

elements.strawberry = {
	color: ["#fb2943","#ff0033"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#bf0147","#c61548","#cc2857","#c62354","#c11848"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#a82953","#941540"] },
	}
};

elements.apple = {
	color: ["#fc3434","#f91515","#d30404","#9f0606","#aa0404"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffda69","#ffdb84"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#f4ff49","#ffec2f"] },
	}
};

elements.green_apple = {
	color: ["#a8da61","#66cc00","#66cc33","#00cc00","#009900"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffda69","#ffdb84"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#f4ff49","#ffec2f"] },
	}
};

elements.orange = {
	color: ["#ff9a00","#ffc100","#ff8100"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	breakIntoColor: ["#ffc659","#ffb646","#ffa700","#ff8d00"],
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fbd808","#ff9005"] },
	}
};

elements.kiwi = {
	color: ["#a9c77e","#61ab5a"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#a9c77e","#bad98f"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#a5d04c","#bbdc79"] },
	}
};

elements.blueberry = {
	color: ["#3e476f","#49598c","#5076b0","#5086c1","#8aa4ff"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#8abeee","#8aacf4","#9591ee","#787fdb","#7c74ce"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#5086c1","#5076b0"] },
	}
};

elements.plum = {
	color: ["#b62d82","#951661","#7c1249","#52001e","#360011"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#bf66c9","#d499db","#eacced"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#d8b2d8","#b266b2"] },
	}
};

elements.blackberry = {
	color: ["#2b0521","#3e0930","#4f123e","#601a4c","#6b2356"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#a941a1","#ba59b2","#c570bf"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ba59b2","#c570bf"] },
	}
};

elements.peach = {
	color: ["#f6a192","#f6b092","#f6c492","#f6cf92","#f6d992"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#fce5b8","#fcdab8","#fccfb8"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffe7dc","#ffdac8"] },
	}
};

elements.lemon = {
	color: ["#ffaa1d","#ffd300","#ffdf00","#ffff00","#fff44f"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#f8ff80","#f6ff6c","#f5ff57","#f3ff39","#f0ff00"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffffd8","#fffecf"] },
	}
};

elements.green_grape = {
	color: ["#b6f271","#a1f02f","#97d60c","#65ba14","#8bc33a"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	breakIntoColor: ["#5f8536","#7ba84a"],
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ecffdc","#c3ffa8"] },
	}
};
elements.banana = {
	color: ["#ffb400","#ffc100","#ffdb00","#ffe700","#f0ff00"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: "#f0f060",
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fdf8d6","#f9efa6"] },
	}
};

elements.blood_orange = {
	color: ["#db4437","#fc3d39","#e5302d","#f6602d","#f65026"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff4600","#ff8353"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffc7b4","#ffa485"] },
	}
};

elements.canary_melon = {
	color: ["#e9ff0c","#e9ff0c","#ffed0c"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffff9e","#fffcaa"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#e5ffb3","#ecff9c"] },
	}
};

elements.honeydew_melon = {
	color: ["#b9ffa3","#c9ffa3","#d9ffa3"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#e9ffa3","#f9ffa3"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#e8ffc9","#e8ffc8"] },
	}
};

elements.cranberry = {
	color: ["#471016","#7a1927","#69202f"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "sauce",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ba4242","#7a1717"],
	reactions: {
        "soda": { elem1: null, elem2: "sprite_cranberry" },
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffc0c5","#ff8f99"] },
	}
};

elements.pitaya = {
	color: ["#f6a9d8","#d4306e","#6ab81f"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff84ae","#ffafca"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffd4e3","#ffafca"] },
	}
};

elements.coconut = {
	color: ["#6b3314","#583203","#673e1c"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "milk",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#f7e5d8","#fdefe5","#fff7f1"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fff2db","#ffefd4"] },
	}
};

elements.cloudberry = {
	color: ["#ff9636","#ffb169","#ffc896"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffe1c7","#fff9f3"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffd7ab","#ffcb93"] },
	}
};

elements.crabapple = {
	color: ["#850b0b","#a32d2d","#ab4545"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff8fcf","#ffb2de"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffd2ec","#ffb2de"] },
	}
};

elements.cactus_fruit = {
	color: ["#ff95b0","#ff80a0","#ff7489"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#75d802","#72d202"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#bbffc1","#84ff90"] },
	}
};

elements.pear = {
	color: ["#669900","#669933","#9ec419"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#c8e39e","#99cc99"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#c3ff9c","#bcff92"] },
	}
};

elements.purpleberry = {
	color: ["#8b04a8","#a236b9","#b968cb"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#c08cc3","#e49cc2"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fee6e4","#fbc3c4"] },
	}
};

elements.yellowberry = {
	color: ["#ffe505","#fffb05","#fdfa72"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#fffec8","#fffdaf"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fffec8","#fffdaf"] },
	}
};

elements.pomegranate = {
	color: ["#950000","#c93434","#df5555","#8f163f","#6d0606"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ee717f","#e94254"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#f4a1a9","#ee717f"] },
	}
};

elements.guava = {
	color: ["#1ae132","#44e788","#0a7a22"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff5a76","#ff8fa2"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#f6c8cd","#f2acb5"] },
	}
};

elements.raspberry = {
	color: ["#f90064","#980036","#60081a"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#f23a72","#fb79a0"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffb1f4","#ff91ce"] },
	}
};

elements.gooseberry = {
	color: ["#63041c","#760024","#81052a"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#8b0031","#920436"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#f1ffdb","#e3ffb7"] },
	}
};

elements.fig = {
	color: ["#1d1d3b","#2a2854","#402459"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff4a4a","#ea3838"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ff8d8d","#ffabab"] },
	}
};

elements.durian = {
	color: ["#b07939","#c09461","#d0af88"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#faffaf","#fbffbf"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#feffe7","#f9ffb3"] },
	}
};

elements.passionfruit = {
	color: ["#9d3385","#b15c9d","#c485b6"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffdede","#ffe4e4"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#d8adce","#c485b6"] },
	}
};

elements.starfruit = {
	color: ["#d5eb00","#ddef33","#e6f366"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#f2d553","#f5dd75"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#faeeba","#f7e698"] },
	}
};

elements.rambutan = {
	color: ["#ff4a4a","#ea3838"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#faffaf","#fbffbf"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fde0e0","#f4c1c1"] },
	}
};

elements.nance = {
	color: ["#ffff00","#ffff33"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffff66","#ffff99"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#fffee0","#fffec8"] },
	}
};

elements.nectarine = {
	color: ["#c92c0f","#cc4c58","#ea6161"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ffbd8b","#ffdbc0"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#ffc3ad","#ffa584"] },
	}
};

elements.loganberry = {
	color: ["#db1515","#e53939","#fd5f5f"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff8f8f","#ffb7b7"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#9c91a5","#bdb5c3"] },
	}
};

elements.currant = {
	color: ["#ff1828","#ff505c"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#ff878f","#ffbcc0"],
	reactions: {
		"sugar": { elem1: "jelly", elem2: null, tempMin: 100, color1: ["#cc6b69","#bb3a37"] },
	}
};

elements.sprite_cranberry = {
	color: ["#65000f","#89001c","#b40024"],
	behavior: [
        "XX|CR:foam%2|XX",
        "M2|XX|M2",
        "M2|M1|M2",
    ],
	category: "liquids",
	state: "solid",
};

elements.mint = {
	color: ["#72e88d","#53bd6c"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	reactions: {
        "cream": { elem1: null, elem2: "toorhpaste" },
		"ice_cream": { elem1: null, elem2: "mint_ice_cream" },
	}
};

elements.broccoli = {
	color: ["#004909","#046b00","#0b8500"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#00b215","#0b8500"],
};

elements.broccoli_seed = {
    color: "#b6c981",
    behavior: [
        "XX|M2%0.25|XX",
        "XX|L2:broccoli AND C2:broccoli%30|XX",
        "XX|M1|XX",
    ],
    tempHigh: 400,
    stateHigh: "fire",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 50,
    burnTime: 20,
    breakInto: null,
    category: "life",
    state: "solid",
    density: 769,
    hidden: true,
    cooldown: defaultCooldown,
    seed: true,
};

elements.hot_pepper = {
	color: ["#ffd013","#fb8a24","#ff5c3a","#d61439","#81032d"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	reactions: {
        "sauce": { elem1: null, elem2: "hot_sauce" },
	}
};

elements.hot_sauce = {
	color: ["#ff0000","#f00000","#d20000","#c50000","#b00000"],
	behavior: behaviors.LIQUID,
	density: 10,
	category: "food",
	state: "solid",
};

elements.squash = {
	color: ["#f2ab15","#f5bc44","#f7cd73"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#efbe79","#ffd599"],
};

elements.zuchinni = {
	color: ["#375822","#58704a","#73816a"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	breakIntoColor: ["#80a568","#a3c88c"],
};

elements.olive = {
	color: ["#445626","#52682d","#6e8b3d"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "olive_oil",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.eggplant = {
	color: ["#490b43","#30093a","#23033a"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	breakInto: "juice",
	breakIntoColor: ["#674ea7","#351c75"],
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.onion = {
	color: ["#62121b","#a92940","#c04b65","#d8699e"],
	behavior: 
	[
		["XX","CH:onion>stench","XX"],
		["XX","XX","XX"],
		["XX","M1","XX"]
	],
	category: "food",
	state: "solid",
	breakInto: ["stench", null, null, null, null],
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.cinnamon = {
	color: ["#cda67a","#986544","#6a462f"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.garlic = {
	color: ["#f7f3e1","#f6f3c3","#f0e6bd"],
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	breakInto: "garlic_clove",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.garlic_clove = {
	color: ["#b8b17f","#6b5628"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.carrot = {
	color: ["#ea820b","#e89116","#e8a32b","#efb538"],
	density: 675,
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	burnInto: "ash",
	burn: 10,
	burnTime: 300,
	breakInto: "juice",
	breakIntoColor: "#f1b956",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.asparagus = {
	color: ["#77ab56","#92bc78","#adcd9a"],
	density: 675,
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	tempHigh: 173,
	stateHigh: "roasted_asparagus",
	burnInto: "ash",
	burn: 10,
	burnTime: 300,
	breakInto: "juice",
	breakIntoColor: "#c9ddbb",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.roasted_asparagus = {
	color: ["#849273","#9aa58d","#c0cbb3"],
	density: 675,
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	breakInto: "juice",
	breakIntoColor: ["#849273","#9aa58d","#c0cbb3"],
	tempHigh: 400,
	stateHigh: "ash",
	burnInto: "ash",
	burn: 20,
	burnTime: 300,
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.oreo = {
	color: "#120600",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
	reactions: {
		"toorhpaste": { elem1: "poison_oreo", elem2: null },
	}
};

elements.poison_oreo = {
	color: "#001112",
	behavior: behaviors.STURDYPOWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.sprinkles = {
	color: ["#fbfa8f","#c5ecbd","#7ac7bf","#f29fa9","#e1848e"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.whipped_cream = {
	color: ["#fffff0","#fffff3","#fffff6","#fffff9","#fffffc"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
	tempHigh: 130,
	stateHigh: "steam",
	isFood: true,
};

elements.olive_oil = {
	color: ["#efcc3f","#efd672","#f1e09a"],
	density: 675,
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "liquid",
	burn: 10,
	burnTime: 300,
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.seafoam = {
	color: ["#a3c1ad","#a0d6b4","#5f9ea0","#317873","#49796b"],
	behavior: behaviors.LIQUID,
	category: "life",
	state: "solid",
};

elements.pipis = {
	color: ["#00BFFF","#0085B0"],
	behavior: behaviors.POWDER,
	category: "life",
	state: "solid",
	tempHigh: 256,
	stateHigh: "steam",
	isFood: true,
};

elements.frog_bomb = {	
    color: ["#0f2105","#274e13","#6aa84f"],
    behavior: [
        "XX|EX:10>frog|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10>frog|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    excludeRandom: true,
    cooldown: defaultCooldown
},

elements.cash_bomb = {	
    color: ["#e69138","#f1c232","#f6b26b"],
    behavior: [
        "XX|EX:10>gold_coin|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10>gold_coin|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    excludeRandom: true,
    cooldown: defaultCooldown
},

elements.pi_pis = {	
    color: ["#0b5394","#073763","#3d85c6"],
    behavior: [
        "XX|EX:10>pipis|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:10>pipis|M2",
    ],
    behaviorOn: [
        "XX|XX|XX",
        "XX|EX:6>metal_scrap,fire,fire,fire%1|XX",
        "XX|XX|XX",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    excludeRandom: true,
    conduct: 1,
    cooldown: defaultCooldown,
    nocheer: true
},

elements.holy_hand_grenade = {	
    color: ["#ffd966","#ffc000","#fff2cc"],
    behavior: [
		"XX|EX:20>bless,holy_fire%1|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:20>bless,holy_fire%1|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    tempHigh: 1455.5,
    stateHigh: "bless",
    excludeRandom: true,
    cooldown: defaultCooldown
},

elements.unholy_feet_bomb = {	
    color: ["#661a0e","#6b1f13","#803226"],
    behavior: [
		"XX|EX:20>curse,fire%1|XX",
        "XX|XX|XX",
        "M2|M1 AND EX:20>curse,fire%1|M2",
    ],
    category: "weapons",
    state: "solid",
    density: 1300,
    tempHigh: 1455.5,
    stateHigh: "curse",
    excludeRandom: true,
    cooldown: defaultCooldown,
},

//for(i = 1, i++, i>10){
 
//}
/*
for (let i = 0; i < 100; i++) {
	if(unholy_feet_bomb.hidden == false) {
		if(curse.hidden == false) {
			if(holy_hand_grenade.hidden == false) {
				unholy_feet_bomb.hidden = false;
			}
		}
	}
	i = 0;
  }
  */


elements.chocolate_fountain = {
    color: "#3e1d07",
    behavior: [
        "XX|CR:melted_chocolate|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    category:"special",
    tempHigh: 1455.5,
    stateHigh: "molten_steel",
    conduct: 0.42,
	state: "solid",
};

elements.legacy_rocket = {
	color: "#ff0000",
    behavior: [
        "XX|M1|XX",
        "XX|DL%1|XX",
        "CR:smoke|CR:fire|CR:smoke",
    ],
    category: "legacy",
    hidden:true,
    state: "solid",
    temp:700,
    density: 7300,
    conduct: 0.73,
    tempHigh: 1455.5,
    stateHigh: "molten_steel"
};

elements.legacy_dough = {
	color: "#bfac91",
    behavior: behaviors.STURDYPOWDER,
    onMix: function(dough,ingredient) {
        if (elements[ingredient.element].isFood && elements[ingredient.element].id !== elements.dough.id && elements[ingredient.element].id !== elements.flour.id && elements[ingredient.element].id !== elements.batter.id && elements[ingredient.element].id !== elements.bread.id) {
            var rgb1 = dough.color.match(/\d+/g);
            var rgb2 = ingredient.color.match(/\d+/g);
            // average the colors
            var rgb = [
                Math.round((parseInt(rgb1[0])+parseInt(rgb2[0]))/2),
                Math.round((parseInt(rgb1[1])+parseInt(rgb2[1]))/2),
                Math.round((parseInt(rgb1[2])+parseInt(rgb2[2]))/2)
            ];
            changePixel(ingredient, "dough")
            // convert rgb to hex
            var hex = RGBToHex(rgb);
            dough.color = pixelColorPick(dough, hex);
            // 50% change to delete ingredient
            if (Math.random() < 0.5) { deletePixel(ingredient.x, ingredient.y); }
            else {
                ingredient.color = pixelColorPick(ingredient, hex);
            }
        }
    },
    reactions: {
        "milk": { elem2:"broth", color2:"#ECC891", tempMin:70 },
        "cream": { elem2:"broth", color2:"#ECC891", tempMin:70 },
    },
    category: "legacy",
    tempHigh: 94,
    stateHigh: "bread",
    //stateHighColorMultiplier: 0.9,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "solid",
    density: 526.9,
    isFood: true
};

elements.legacy_batter = {
	color: "#d4bc85",
    behavior: behaviors.LIQUID,
    onMix: function(batter,ingredient) {
        if (elements[ingredient.element].isFood && elements[ingredient.element].id !== elements.batter.id && elements[ingredient.element].id !== elements.flour.id && elements[ingredient.element].id !== elements.yolk.id && elements[ingredient.element].id !== elements.dough.id && elements[ingredient.element].id !== elements.baked_batter.id) {
            var rgb1 = batter.color.match(/\d+/g);
            var rgb2 = ingredient.color.match(/\d+/g);
            // average the colors
            var rgb = [
                Math.round((parseInt(rgb1[0])+parseInt(rgb2[0]))/2),
                Math.round((parseInt(rgb1[1])+parseInt(rgb2[1]))/2),
                Math.round((parseInt(rgb1[2])+parseInt(rgb2[2]))/2)
            ];
            changePixel(ingredient, "batter")
            // convert rgb to hex
            var hex = RGBToHex(rgb);
            batter.color = pixelColorPick(batter, hex);
            // 50% change to delete ingredient
            if (Math.random() < 0.5) { deletePixel(ingredient.x, ingredient.y); }
            else {
                ingredient.color = pixelColorPick(ingredient, hex);
            }
        }
    },
    category: "legacy",
    tempHigh: 94,
    stateHigh: "baked_batter",
    stateHighColorMultiplier: 0.9,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "liquid",
    viscosity: 10000,
    density: 1001,
    hidden: true,
    isFood: true
};

elements.legacy_lattice = {
	color: "#cb4cd9",
    behavior: [
        "CL|XX|CL",
        "XX|XX|XX",
        "CL|XX|CL",
    ],
    hidden: true,
    category:"legacy",
    excludeRandom: true
};

elements.top_lattice = {
	color: "#cb4cd9",
    behavior: [
        "CL|XX|CL",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    hidden: true,
    category:"special",
    excludeRandom: true
};

elements.bottom_lattice = {
	color: "#cb4cd9",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "CL|XX|CL",
    ],
    hidden: true,
    category:"special",
    excludeRandom: true
};

elements.right_lattice = {
	color: "#cb4cd9",
    behavior: [
        "XX|XX|CL",
        "XX|XX|XX",
        "XX|XX|CL",
    ],
    hidden: true,
    category:"special",
    excludeRandom: true
};

elements.left_lattice = {
	color: "#cb4cd9",
    behavior: [
        "CL|XX|XX",
        "XX|XX|XX",
        "CL|XX|XX",
    ],
    hidden: true,
    category:"special",
    excludeRandom: true
};

elements.amethyst = {
	color: ["#9868e0","#482888","#7848b8","#c898f0","#a878f0"],
    behavior: behaviors.POWDER,
    hidden: true,
    category: "powders",
};

elements.quartz = {
	color: ["#f6fff9","#f3f9f9","#f6fcf9","#fefefe","#fdfffe"],
    behavior: behaviors.POWDER,
    hidden: true,
    category: "powders",
	tempHigh: 1900,
	stateHigh: "magma",
	reactions: {
		"molten_iron": { elem1: "amethyst", elem2: null },
	}
};

elements.ruby = {
	color: ["#850014","#ae001a","#e10531","#a50727","#6b0015"],
    behavior: behaviors.POWDER,
    category: "powders",
    tempHigh: 900,
    stateHigh: "carbon_dioxide",
    state: "solid",
    density: 3515,
    hardness: 1,
	alias: "Lamp Oil, Rope, Bombs, you want it? It's yours my friend, as long as you have enough rubies.",
};

elements.slushy_ice = {
	color: ["#f6fff9","#f3f9f9","#f6fcf9","#fefefe","#fdfffe"],
    behavior: behaviors.WALL,
    temp: -5,
    tempHigh: 5,
    stateHigh: "smashed_ice",
    category: "states",
    state: "solid",
    density: 917,
    breakInto: "smashed_ice",
	isFood: true,
};

elements.toorhpaste = {
	color: ["#31ffe0","#65ffe8","#97ffef","#c9fff7","#f3fffd"],
	behavior: behaviors.LIQUID,
	category: "liquids",
	state: "solid",
	reactions: {
		"juice": { elem1: "poison", elem2: null },
	},
	tempHigh: 170,
	stateHigh: "steam",
	isFood: true,
};

if (!elements.lettuce.reactions) elements.lettuce.reactions = {};
elements.lettuce.reactions.ice_cream = { elem1: "moss", elem2: null }

if (!elements.advanced_dough.reactions) elements.advanced_dough.reactions = {};
elements.advanced_dough.reactions.yolk = { elem1: "eggy_dough", elem2: null }

if (!elements.yeast.reactions) elements.yeast.reactions = {};
elements.yeast.reactions.flour = { elem1: "beer", elem2: null }

if (!elements.beer.reactions) elements.beer.reactions = {};
elements.beer.reactions.fiber = { elem1: "root_beer", elem2: null }

if (!elements.cheese.reactions) elements.cheese.reactions = {};
elements.cheese.reactions.seasoning = { elem1: "parmesan", elem2: null }

if (!elements.sodium.reactions) elements.sodium.reactions = {};
elements.sodium.reactions.neutral_acid = { elem1: "baking_powder", elem2: null }

if (!elements.toast.reactions) elements.toast.reactions = {};
elements.toast.reactions.chocolate = { elem1: "oreo", elem2: null }

if (!elements.ketchup.reactions) elements.ketchup.reactions = {};
elements.ketchup.reactions.mayo = { elem1: "rose_sauce", elem2: null }

if (!elements.bread.reactions) elements.bread.reactions = {};
elements.bread.reactions.rotten_cheese = { elem1: "mold", elem2: null }

if (!elements.bread.reactions) elements.bread.reactions = {};
elements.bread.reactions.dirty_water = { elem1: "mold", elem2: null }

if (!elements.toast.reactions) elements.toast.reactions = {};
elements.toast.reactions.rotten_cheese = { elem1: "mold", elem2: null }

if (!elements.toast.reactions) elements.toast.reactions = {};
elements.toast.reactions.dirty_water = { elem1: "mold", elem2: null }

if (!elements.baked_batter.reactions) elements.baked_batter.reactions = {};
elements.baked_batter.reactions.rotten_cheese = { elem1: "mold", elem2: null }

if (!elements.baked_batter.reactions) elements.baked_batter.reactions = {};
elements.baked_batter.reactions.dirty_water = { elem1: "mold", elem2: null }

if (!elements.bread.reactions) elements.bread.reactions = {};
elements.bread.reactions.worm = { elem1: "mold", elem2: null }

if (!elements.bread.reactions) elements.bread.reactions = {};
elements.bread.reactions.mud = { elem1: "mold", elem2: null }

if (!elements.toast.reactions) elements.toast.reactions = {};
elements.toast.reactions.worm = { elem1: "mold", elem2: null }

if (!elements.toast.reactions) elements.toast.reactions = {};
elements.toast.reactions.mud = { elem1: "mold", elem2: null }

if (!elements.baked_batter.reactions) elements.baked_batter.reactions = {};
elements.baked_batter.reactions.worm = { elem1: "mold", elem2: null }

if (!elements.baked_batter.reactions) elements.baked_batter.reactions = {};
elements.baked_batter.reactions.mud = { elem1: "mold", elem2: null }

elements.sugar_ice.breakInto = "smashed_ice"

elements.algae.breakInto = "seafoam"

elements.battery.breakInto = "battery_acid"

elements.art.burn = 5
elements.art.burnTime = 300
elements.art.burnInto = ["ember","charcoal","fire"]


elements.herb.breakInto = "seasoning"

elements.chocolate.breakInto = "chocolate_sauce"

elements.magma.stateLow = ["basalt","basalt","basalt","basalt","basalt","basalt","basalt","rock","quartz"]

if (!elements.bless.reactions) elements.bless.reactions = {};
elements.bless.reactions.mold = { elem2: null }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.broccoli = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.squash = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.zuchinni = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.olive = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.eggplant = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.onion = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.garlic = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.garlic_clove = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.asparagus = { elem1: null, elem2: "pickle" }

if (!elements.vinegar.reactions) elements.vinegar.reactions = {};
elements.vinegar.reactions.asparagus = { elem1: null, elem2: "pickle" }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.grape = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.jelly = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.cherry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.orange = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.kiwi = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.green_grape = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.blood_orange = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.canary_melon = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.honeydew_melon = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.cranberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.pitaya = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.coconut = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.cloudberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.crabapple = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.cactus_fruit = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.pear = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.purpleberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.yellowberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.pomegranate = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.guava = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.raspberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.gooseberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.fig = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.durian = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.passionfruit = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.starfruit = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.rambutan = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.nance = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.nectarine = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.loganberry = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.currant = { elem1: "fruit_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.chocolate = { elem1: "chocolate_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.chocolate_sauce = { elem1: "chocolate_ice_cream", elem2: null }

if (!elements.ice_cream.reactions) elements.ice_cream.reactions = {};
elements.ice_cream.reactions.melted_chocolate = { elem1: "chocolate_ice_cream", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.grape = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.green_grape = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.cherry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.kiwi = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.orange = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.jelly = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.chocolate = { elem1: "chocolate_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.chocolate_sauce = { elem1: "chocolate_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.melted_chocolate = { elem1: "chocolate_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.blood_orange = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.canary_melon = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.honeydew_melon = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.cranberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.pitaya = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.coconut = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.cloudberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.crabapple = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.cactus_fruit = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.pear = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.purpleberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.yellowberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.pomegranate = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.guava = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.raspberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.gooseberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.fig = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.durian = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.passionfruit = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.starfruit = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.rambutan = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.nance = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.nectarine = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.loganberry = { elem1: "fruit_yogurt", elem2: null }

if (!elements.yogurt.reactions) elements.yogurt.reactions = {};
elements.yogurt.reactions.currant = { elem1: "fruit_yogurt", elem2: null }


//dev notes area below
/*
uhhhh i just finished changing every color in the mod and now i have enough hex codes for a lifetime
oh god i added like 2 million new fruits
*/
/*
 * Mod created by Tisquares
 * Every dessert idea is provided by the community. 
 * Don't see your favorite dessert? Let me know!
 * 
 * Got questions? Contact tisqbisque on Discord!
 * 
 * This version: 2.0
 */
// Other mods can add to this list [:
eListAdd("FRUITS",["apple","banana","blackberry","blueberry","grape","kiwi","mango","orange","peach","plum","pomegranate","rambutan","strawberry"]);
function fruitLength() {
    return eLists.FRUITS.length;
}

// Dulce de leche items
elements.dulce_de_leche = {
    alias: "manjar",
    color: ["#c56600", "#f7a204", "#ca6400", "#893604"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    reactions: {
        "cream_cheese": { elem1: "dulce_de_leche", elem2: null, color1: ["#DFAB73", "#fbcc75", "#e2aa73", "#be9075"], oneway: true }, // for recipe accuracy :3
    },
    tempLow: -20,
    stateLow: "candy",
    tempHigh: 250,
    stateHigh: ["fragrance", "smoke", "smoke"],
    viscosity: 500,
    stain: 0.02,
    density: 1284.93,
    hidden: true,
    isFood: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by heating Sweetened Condensed Milk at 175C+.\nFrom undexconocidox_26419.\n"
}
elements.sweetened_condensed_milk = {
    alias: "sweet_milk",
    color: ["#ffe9ba", "#fbd396", "#fde2a9"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    onMix: function(cmilk, jamcheck) {
        if(shiftDown && elements[jamcheck.element].id === elements.jam.id && Math.random() < 0.06) {
            changePixel(cmilk,"mousse");
            pixelMap[cmilk.x][cmilk.y].color = shiftColor(rgbToHex(jamcheck.color),"#272727","add");
            deletePixel(jamcheck.x,jamcheck.y);
        }
    },
    tempLow: 0,
    stateLow: ["ice_cream", "sugar"],
    tempHigh: 175,
    stateHigh: "dulce_de_leche",
    viscosity: 5,
    stain: 0.015,
    density: 1050.83,
    hidden: true,
    isFood: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by mixing Milk and Sugar at 85C+.\n",
}

// Chocotorta items
elements.cream_cheese = {
    color: ["#ebe9ea", "#e4dfdd", "#eeeeee"],
    category: "Community",
    state: "solid",
    behavior: behaviors.STURDYPOWDER,
    //reactions: {
    // For future use
    //},
    tempHigh: 65,
    stateHigh: "melted_cheese",
    stateHighColor: ["#fbffff", "#f6f6f6"],
    hardness: 0.01,
    density: 980.61,
    hidden: true,
    isFood: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by mixing Acid with Milk or Cream at 90C-.\n",
}
elements.cocoa_bean = {
    color: ["#e16f51", "#e28e67", "#e18550", "#84574d"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    // Has no reactions
    breakInto: "cocoa_powder",
    density: 593,
    tempHigh: 179.4,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    // not hidden by default
    // not food don't eat it
    desc: "Added in version 1.0 of Community Desserts.\n",
}
elements.cocoa_powder = {
    color: ["#855344", "#6d4c41", "#40271d"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    onMix: function (powder, doughcheck) {
        if (elements[doughcheck.element].id == elements.dough.id && shiftDown && Math.random() < 0.25) {
            deletePixel(powder.x, powder.y);
            changePixel(doughcheck, "chocolate_biscuit_dough");
        }
    },
    density: 363.5,
    tempHigh: 50,
    stateHigh: "smoke",
    hidden: true,
    isFood: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by Smashing Cocoa Bean.\n",
}
elements.chocolate_biscuit_dough = {
    color: "#623727",
    category: "Community",
    state: "solid",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 94,
    stateHigh: "chocolate_biscuit",
    burn: 40,
    burnTime: 25,
    burnInto: "ash",
    density: 526.9,
    isFood: true,
    hidden: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by hard mixing Cocoa Powder with Dough.\n",
}
elements.chocolate_biscuit = {
    color: "#864B36",
    category: "Community",
    state: "solid",
    behavior: behaviors.STURDYPOWDER,
    breakInto: "crumb",
    breakIntoColor: ["#af8264", "#b28461", "#aa7852", "#a8744b"],
    tempHigh: 232.2,
    stateHigh: ["smoke", "smoke", "smoke", "ash"],
    density: 233.96,
    isFood: true,
    hidden: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by cooking Choco Biscuit Dough at 94C+.\nCan be layered with other items to make chocotorta, from undexconocidox_26419.\n",
}

// Haupia items
elements.coconut = {
    color: ["#793b1e", "#995c31", "#5f3015"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    breakInto: ["coconut_milk", "tinder"],
    tempHigh: 225,
    stateHigh: ["steam", "ash", "smoke"],
    density: 822,
    desc: "Added in version 1.0 of Community Desserts.\n",
}
elements.coconut_milk = {
    color: ["#f3f3f3", "#e4ddcb", "#f8f8f8"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    reactions: {
        "sugar": { elem1: null, elem2: "haupia_mix", tempMin: 90 },
    },
    tempHigh: 102,
    stateHigh: "steam",
    tempLow: -0.5,
    stateLowName: "coconut_ice",
    viscosity: 1.8,
    density: 1031.33,
    hidden: true,
    isFood: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by smashing Coconut.\n",
}
elements.haupia_mix = {
    color: ["#f3f3f3", "#e4ddcb", "#f8f8f8"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    tempHigh: 105,
    stateHigh: "steam",
    tempLow: 3,
    stateLow: "haupia",
    viscosity: 2.3,
    density: 1242.67,
    hidden: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by mixing Coconut Milk and Sugar at 90C+.\n",
}
elements.haupia = {
    color: ["#ffffff", "#f8f8f8", "#f7f9f8"],
    category: "Community",
    state: "solid",
    behavior: behaviors.SUPPORT,
    tempHigh: 105,
    stateHigh: ["steam", "fragrance"],
    density: 1300,
    hidden: true,
    isFood: true,
    desc: "Added in version 1.0 of Community Desserts.\nMade by cooling Haupia Mix at 3C-.\nFrom tisqbisque.\n"
}

// Pie crust items
elements.pie_crust_batter = {
    alias: "pie_batter",
    color: ["#efdbae", "#ffe6ab", "#eacb88"],
    category: "Community",
    state: "solid",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 180,
    stateHigh: "pie_crust",
    density: 233.96,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by mixing Dough and Butter.\n",
}
elements.pie_crust = {
    color: ["#c18d45", "#b07f3c", "#d0a352", "#b27f3a"],
    category: "Community",
    state: "solid",
    behavior: behaviors.STURDYPOWDER,
    breakInto: "crumb",
    breakIntoColor: ["#af8264", "#b28461", "#aa7852", "#a8744b"],
    tempHigh: 232.2,
    stateHigh: ["smoke", "smoke", "smoke", "ash"],
    density: 233.96,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by cooking Pie Crust Batter at 180C+.\n",
}

// Jam and fruit items
elements.jam = {
    color: ["#e14a4a","#f64040","#e72225"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    tick: function (pixel) {
        var madeJelly = false;
        // Check left, right, up, down from jam pixel..
        if(pixel.temp >= 95) {
            if(Math.random() < 0.05 && pixel.x-1 !== 0) {
                if (!isEmpty(pixel.x-1,pixel.y) && pixelMap[pixel.x-1][pixel.y].element === "water") {
                    changePixel(pixelMap[pixel.x-1][pixel.y],"jelly");
                    pixelMap[pixel.x-1][pixel.y].color = shiftColor(rgbToHex(pixel.color),"#272727","sub");
                    madeJelly = true;
                };
            };
            if(Math.random() < 0.05 && pixel.x+1 !== width) {
                if (!isEmpty(pixel.x+1,pixel.y) && pixelMap[pixel.x+1][pixel.y].element === "water") {
                    changePixel(pixelMap[pixel.x+1][pixel.y],"jelly");  
                    pixelMap[pixel.x+1][pixel.y].color = shiftColor(rgbToHex(pixel.color),"#272727","sub");
                    madeJelly = true;
                };
            };
            if(Math.random() < 0.05 && pixel.y-1 !== 0) {
                if (!isEmpty(pixel.x,pixel.y-1) && pixelMap[pixel.x][pixel.y-1].element === "water") {
                    changePixel(pixelMap[pixel.x][pixel.y-1],"jelly");
                    pixelMap[pixel.x][pixel.y-1].color = shiftColor(rgbToHex(pixel.color),"#272727","sub");
                    madeJelly = true;
                };
            };
            if(Math.random() < 0.05 && pixel.y+1 !== height) {
                if (!isEmpty(pixel.x,pixel.y+1) && pixelMap[pixel.x][pixel.y+1].element === "water") {
                    changePixel(pixelMap[pixel.x][pixel.y+1],"jelly");
                    pixelMap[pixel.x][pixel.y+1].color = shiftColor(rgbToHex(pixel.color),"#272727","sub");
                    madeJelly = true;
                };
            };
            if(madeJelly) {
                deletePixel(pixel.x,pixel.y);
            }
        }
    },
    tempHigh: 160,
    stateHigh: ["smoke", "smoke", "sugar"],
    tempLow: -5,
    stateLowName: "frozen_jam",
    stateLowColorMultiplier: 1.1,
    viscosity: 200000,
    stain: 0.3,
    density: 1333.5,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by smashing a fruit.\n",
}
elements.frozen_jam = {
    stateHighColorMultiplier: 0.91,
}
elements.fruit_seed = { // similar to pinecone
    color: ["#5c3333","#472727","#311b1b"],
    tick: function(pixel) {
        if (!tryMove(pixel,pixel.x,pixel.y+1) && pixelTicks-pixel.start > 50) {
            if (pixel.h === undefined) { // set to even number between 8 and 26
                pixel.h = Math.floor(Math.random()*9)*2+8;
                pixel.lh = pixel.h;
            }
            if (Math.random() < 0.02 && pixel.h > 0 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) { // grow roots
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel && (eLists.SOIL.indexOf(dirtPixel.element) !== -1  || dirtPixel.element === "grass")) {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1) && tryMove(pixel,pixel.x,pixel.y-1)) {
                    createPixel("wood",pixel.x,pixel.y+1);
                    pixel.h --;
                }
            }
            else if (pixel.h === 0) {
                changePixel(pixel,"fruit_tree");
                pixelMap[pixel.x][pixel.y].h = pixel.lh;
            }
        }
        doDefaults(pixel);
    },
    tempHigh: 500,
    stateHigh: "wood",
    burn: 5,
    burnTime: 100,
    category: "Community",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    desc: "Added in version 2.0 of Community Desserts.\nGrows into Fruit Tree.\n"
}
elements.fruit_tree = { // like sapling
    color: ["#007a00","#0a910a","#036903"],
    tick: function (pixel) {
        if (pixel.h > 0 && pixelTicks % (50+pixel.h) === 0) {
            // extend to the left and right, giving the next h-1
            // The taller the tree, the longer the umbrella
            if (isEmpty(pixel.x-1,pixel.y)) {
                createPixel("fruit_tree",pixel.x-1,pixel.y);
                pixelMap[pixel.x-1][pixel.y].h = pixel.h-2;
            }
            if (isEmpty(pixel.x+1,pixel.y)) {
                createPixel("fruit_tree",pixel.x+1,pixel.y);
                pixelMap[pixel.x+1][pixel.y].h = pixel.h-2;
            }
            if (isEmpty(pixel.x,pixel.y-1)) {
                createPixel("fruit_tree",pixel.x,pixel.y-1);
            }
        }
        else if(isEmpty(pixel.x,pixel.y+1) && Math.random() < 0.0005 ) {
            createPixel(eLists.FRUITS[Math.floor(Math.random()*fruitLength())],pixel.x,pixel.y+1);
        }
        doDefaults(pixel);
    },
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category: "Community",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:45,
    burnTime:75,
    burnInto: ["dead_plant","dead_plant","dead_plant","dead_plant","fruit_seed"],
    breakInto: ["dead_plant","dead_plant","dead_plant","dirt","sap"],
    state: "solid",
    density: 1050,
    seed: "fruit_seed",
    hidden: true,
    movable: false,
    desc: "Added in version 2.0 of Community Desserts.\nMay drop a random fruit. Current # of fruits: " + (fruitLength()-1) +".\n",
}
elements.apple = {
    color: ["#c6de70","#efdc5c","#c75833","#bd3838"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#f5cb40" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#f5cb40" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#f5cb40" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#f5cb40" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#f5cb40" },
        "acid": { elem1:"juice", color1:"#f5cb40" },
        "acid_gas": { elem1:"juice", color1:"#f5cb40" },
    },
    breakInto: "jam",
    breakIntoColor: ["#ddae16","#fdcd53","#fed75e","#e9b429"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 460.72,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.banana = {
    color: ["#f8e662","#ffe312","#fee402","#fed601"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#fae7b5" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#fae7b5" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#fae7b5" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#fae7b5" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#fae7b5" },
        "acid": { elem1:"juice", color1:"#fae7b5" },
        "acid_gas": { elem1:"juice", color1:"#fae7b5" },
    },
    breakInto: "jam",
    breakIntoColor: ["#d6aa46","#e3b544","#cda23a","#e3c869"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 634.01,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.blackberry = {
    color: ["#5c2f3e","#281c2a","#02060f","#19252c"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#7b1e57" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#7b1e57" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#7b1e57" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#7b1e57" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#7b1e57" },
        "acid": { elem1:"juice", color1:"#7b1e57" },
        "acid_gas": { elem1:"juice", color1:"#7b1e57" },
    },
    breakInto: "jam",
    breakIntoColor: ["#481317","#50030d","#250b0c","#62020d"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 608.65,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.blueberry = {
    color: ["#385f9e","#386891","#4874b5","#4b8ee3"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#933487" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#933487" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#933487" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#933487" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#933487" },
        "acid": { elem1:"juice", color1:"#933487" },
        "acid_gas": { elem1:"juice", color1:"#933487" },
    },
    breakInto: "jam",
    breakIntoColor: ["#48132c","#6f3a56","#13030d","#351123"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 625.56,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.kiwi = {
    color: ["#be8456","#cb8a3e","#bc7742","#975e25"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#eef299" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#eef299" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#eef299" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#eef299" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#eef299" },
        "acid": { elem1:"juice", color1:"#eef299" },
        "acid_gas": { elem1:"juice", color1:"#eef299" },
    },
    breakInto: "jam",
    breakIntoColor: ["#beb43c","#b7ac41","#8d7614","#755e11"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 748.14,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.mango = {
    color: ["#ff1f25","#f97231","#fdeb1d","#85b624"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#ffbf34" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#ffbf34" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#ffbf34" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#ffbf34" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#ffbf34" },
        "acid": { elem1:"juice", color1:"#ffbf34" },
        "acid_gas": { elem1:"juice", color1:"#ffbf34" },
    },
    breakInto: "jam",
    breakIntoColor: ["#ef9d00","#fdb005","#fed803","#fbdd00"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 697.41,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.orange = {
    color: ["#ffa500","#ff951d","#ffb20a","#f68310"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#f7ca05" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#f7ca05" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#f7ca05" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#f7ca05" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#f7ca05" },
        "acid": { elem1:"juice", color1:"#f7ca05" },
        "acid_gas": { elem1:"juice", color1:"#f7ca05" },
    },
    breakInto: "jam",
    breakIntoColor: ["#edb848","#f6b23e","#e59e12","#eca528"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 435, // these oranges have peels so they float [:
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.peach = {
    color: ["#ffc612","#f78a00","#d43d22","#a41622"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#ffc663" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#ffc663" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#ffc663" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#ffc663" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#ffc663" },
        "acid": { elem1:"juice", color1:"#ffc663" },
        "acid_gas": { elem1:"juice", color1:"#ffc663" },
    },
    breakInto: "jam",
    breakIntoColor: ["#f59400","#f29e04","#e9a230","#eead37"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 650.92,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.plum = {
    color: ["#952444","#5a2346","#3e2141","#450a1a"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#a10013" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#a10013" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#a10013" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#a10013" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#a10013" },
        "acid": { elem1:"juice", color1:"#a10013" },
        "acid_gas": { elem1:"juice", color1:"#a10013" },
    },
    breakInto: "jam",
    breakIntoColor: ["#a9050c","#55081a","#781123","#4f1e2f"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 697.41,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.pomegranate = {
    color: ["#fd4127","#be2216","#aa1519","#330104"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#c9002c" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#c9002c" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#c9002c" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#c9002c" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#c9002c" },
        "acid": { elem1:"juice", color1:"#c9002c" },
        "acid_gas": { elem1:"juice", color1:"#c9002c" },
    },
    breakInto: "jam",
    breakIntoColor: ["#4b0000","#6b0900","#a3000e","#c80402"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 1150,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.rambutan = {
    color: ["#9a1408","#eb2814","#9bf05f","#f6ffff"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#eae6dd" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#eae6dd" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#eae6dd" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#eae6dd" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#eae6dd" },
        "acid": { elem1:"juice", color1:"#eae6dd" },
        "acid_gas": { elem1:"juice", color1:"#eae6dd" },
    },
    breakInto: "jam",
    breakIntoColor: ["#60271a","#773119","#841e01","#953810"],
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 281,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.strawberry = {
    color: ["#c53415","#ea1720","#f1232d","#ea7e72"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"juice", chance:0.1, color1:"#f53c28" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#f53c28" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#f53c28" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#f53c28" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#f53c28" },
        "acid": { elem1:"juice", color1:"#f53c28" },
        "acid_gas": { elem1:"juice", color1:"#f53c28" },
    },
    breakInto: "jam",
    // Jam is strawberry-colored by default akschully
    tempHigh: 256,
    stateHigh: ["steam", "sugar"],
    density: 642.47,
    isFood: true,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\n"
}

// Vanilla items
elements.vanilla_bean = {
    alias: "vanilla",
    color: ["#362C1D","#6f4a3b","#764735","#593b30"],
    category: "Community",
    state: "solid",
    behavior: behaviors.POWDER,
    reactions: {
        "rock": { elem1:"vanilla_extract", chance:0.1 },
        "concrete": { elem1:"vanilla_extract", chance:0.1 },
        "basalt": { elem1:"vanilla_extract", chance:0.1 },
        "limestone": { elem1:"vanilla_extract", chance:0.1 },
        "tuff": { elem1:"vanilla_extract", chance:0.1 },
        "acid": { elem1:"vanilla_extract" },
        "acid_gas": { elem1:"vanilla_extract", },
    },
    breakInto: "vanilla_extract",
    tempHigh: 315,
    stateHigh: ["steam","ash"],
    density: 1100,
    desc: "Added in version 2.0 of Community Desserts.\n"
}
elements.vanilla_extract = {
    // Will have more application one day
    color: ["#5e1b00","#321501"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    tempHigh: 285,
    stateHigh: ["steam", "alcohol_gas"],
    density: 879.16,
    viscosity: 5000,
    stain: 0.45,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by smashing Vanilla Bean.\nFrom lethanaero.\n",
}

// Mousse items
elements.mousse = {
    color: ["#fffdce","#fffee2","#fffff5"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    tempHigh: 286,
    stateHigh: ["steam", "smoke", "smoke", "sugar"],
    density: 1707.61,
    viscosity: 5000000, // is there a limit?
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by hard mixing Jam and Sweetened Condensed Milk.\nFrom brickmaster0513.\n",
}

// Tiramisu items
elements.egg_ribbons = {
    color: ["#ffdc5e","#ffe07c"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    tempHigh: 150,
    stateHigh: ["smoke","hard_yolk"],
    tempLow: 0,
    stateLow: ["sugar","hard_yolk"],
    density: 1227.5,
    viscosity: 300,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by hard mixing Yolk and Sugar.\n",
}
elements.mascarpone = {
    color: ["#faf9f1","#faf9f7"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    reactions: {
        "egg_ribbons": { elem1:"tiramisu_cream", elem2:null }
    },
    tempHigh: 218,
    stateHigh: ["smoke","smoke"],
    density: 946.79,
    viscosity: 30000,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by mixing Acid with Milk or Cream at 85C+.\n",
}
elements.tiramisu_cream = {
    color: ["#fff0d1","#fbefd7"],
    category: "Community",
    state: "liquid",
    behavior: behaviors.LIQUID,
    tempHigh: 218,
    stateHigh: ["smoke","smoke"],
    density: 946.79,
    viscosity: 30000,
    hidden: true,
    desc: "Added in version 2.0 of Community Desserts.\nMade by mixing Egg Ribbons with Mascarpone.\nCan be layered with other items to make tiramisu, from tisqbisque.\n",
}

// Adjusting existing elements here
if (!elements.milk.reactions) { elements.milk.reactions = {} };
elements.milk.reactions.acid = { elem1: null, elem2: "cream_cheese", chance: 0.8 };
elements.milk.reactions.sugar = { elem1: "sweetened_condensed_milk", elem2: null, chance: 0.05, tempMin: 85 };

if (!elements.cream.reactions) { elements.cream.reactions = {} };
elements.cream.reactions.acid = { elem1: "cream_cheese", elem2: null, chance: 0.8, tempMax:90 };
if (!elements.acid.reactions) { elements.acid.reactions = {} };
elements.acid.reactions.cream = { elem1: null, elem2: "mascarpone", chance: 0.5, tempMin:85 };

if (!elements.dough.reactions) { elements.dough.reactions = {} };
elements.dough.reactions.butter = { elem1: "pie_crust_batter", elem2: null, chance: 0.05 };

if(elements.sugar.reactions.grape) { delete elements["sugar"].reactions.grape; }; // I would remove the reactions entirely but I don't want to mess with other mods
if(elements.caramel.reactions.grape) { delete elements["caramel"].reactions.grape; };
if(elements.grape.reactions.water) { delete elements["grape"].reactions.water };
if(elements.grape.reactions.sugar_water) { delete elements["grape"].reactions.sugar_water };
if (!elements.grape.hidden) { elements.grape.hidden = true };
elements.grape.breakInto = "jam";

if (!elements.jelly.desc) { elements.jelly.desc = "Changed in version 2.0 of Community Desserts.\nMade by mixing Jam and Water at temperatures 95C+.\n" };
if (!elements.jelly.hidden) { elements.jelly.hidden = true };
elements.jelly.viscosity = 150000;
elements.jelly.stain = 0.25;

elements.yolk.onMix = function(pixel,sugarcheck) {
    if (elements[sugarcheck.element].id == elements.sugar.id && shiftDown && Math.random() < 0.35) {
        deletePixel(sugarcheck.x, sugarcheck.y);
        changePixel(pixel, "egg_ribbons");
    }
}

// Mod items first
elements.acid.ignore = ["cream_cheese", "cream", "milk", "mascarpone",
    "glass", "rad_glass", "glass_shard", "rad_shard", "stained_glass", "baked_clay", "acid_gas", "neutral_acid", "acid_cloud", "water", "salt_water", "sugar_water", "dirty_water", "copper", "gold", "porcelain", "plastic", "bead", "microplastic", "molten_plastic", "pool_water", "chlorine", "hydrogen", "gold_coin", "silver", "nickel", "calcium", "bone"];

// For new colors
function shiftColor(base, change, direction) {
    const colorRegEx = /^\#?[A-Fa-f0-9]{6}$/;

    // Missing parameter(s)
    if (!base || !change) {
        console.log("Parameter absent!");
        return '#000000';
    }
    // Invalid parameter(s)
    if (!base.match(colorRegEx) || !change.match(colorRegEx)) {
        console.log("Parameter bad!");
        return '#000000';
    }

    // Remove any '#'
    base = base.replace(/\#/g, '');
    change = change.replace(/\#/g, '');

    // Build new color
    let newColor = '';
    for (let i = 0; i < 3; i++) {
        const basePiece = parseInt(base.substring(i * 2, i * 2 + 2), 16);
        const changePiece = parseInt(change.substring(i * 2, i * 2 + 2), 16);
        let newPiece = '';

        if (direction === 'add') { // Adding a lighter color makes it darker. #000000 does effectively nothing! #ffffff makes it fully white!
            newPiece = (basePiece + changePiece);
            newPiece = newPiece > 255 ? 255 : newPiece;
        }
        if (direction === 'sub') { // Subtracting a darker color makes it closer to original. #000000 does effectively nothing! #ffffff makes it fully black!
            newPiece = (basePiece - changePiece);
            newPiece = newPiece < 0 ? 0 : newPiece;
        }

        newPiece = newPiece.toString(16);
        newPiece = newPiece.length < 2 ? '0' + newPiece : newPiece;
        newColor += newPiece;
    }

    return '#' + newColor;
}

function rgbToHex(rgbObj) {
    var values = rgbObj.substring(rgbObj.indexOf('(') + 1, rgbObj.lastIndexOf(')')).split(',');
    var r = parseInt(values[0]);
    var g = parseInt(values[1]);
    var b = parseInt(values[2]);
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function componentToHex(c) {
    let hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
//This mod was made by Adora the transfem, https://discord.com/users/778753696804765696 on discord and https://www.tiktok.com/@alextheagenenby?_t=8hoCVI3NRhu&_r=1 on tiktok. Current version: plans.js v1.1.0
let fruits = ["plum", "peach", "pear", "orange", "apple", "cherry", "mango", "pineapple", "sugarcane"];
let vineExclude = ["tomato", "grape", "fruit_vine", "kiwi"];
let vines = ['tomato', 'grape', 'kiwi', 'watermelon', 'strawberry', 'cucumber'];
let bushes = ["blackberry", "blueberry", "raspberry"];
let allFruits = fruits.concat(vines, bushes)
let rosaceae = ["plum", "peach", "pear", "apple", "cherry", "blackberry", "raspberry", "strawberry"]
function interpolateRgb(rgb1, rgb2, ratio) {
  const interpolatedRgb = {
    r: Math.round(rgb1.r + (rgb2.r - rgb1.r) * ratio),
    g: Math.round(rgb1.g + (rgb2.g - rgb1.g) * ratio),
    b: Math.round(rgb1.b + (rgb2.b - rgb1.b) * ratio),
  };
  return interpolatedRgb;
}

elements.fruit_branch = {
    color: elements.tree_branch.color,
    behavior: [
        "CR:fruit_leaves,fruit_branch%2|CR:fruit_leaves,fruit_leaves,fruit_leaves,fruit_branch%2|CR:fruit_leaves,fruit_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "wood",
    tempLow: -30,
    stateLow: "wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
    seed: "apple_seed",
  tick: function(pixel){
    for(var i = 0; i < adjacentCoords.length; i++){
      let x = pixel.x+adjacentCoords[i][0];
      let y = pixel.y+adjacentCoords[i][1];
      if(isEmpty(x, y) || outOfBounds(x, y)) { continue; }
      let pixel2 = pixelMap[x][y];
      if(pixel2.element == "fruit_branch" || pixel2.element == "fruit_leaves" || pixel2.element == "wood"){
        if(pixel.fruit && !pixel2.fruit){
          pixel2.fruit = pixel.fruit;
        } else if (!pixel.fruit && pixel2.fruit){
          pixel.fruit = pixel2.fruit;
        }
      }
    }
  }
}
elements.fruit_leaves = {
    color: elements.plant.color,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
    tick: function(pixel){
      if(pixelTicks == pixel.start + 1 && pixel.blooming == undefined){
        if(Math.floor(Math.random() * 3) == 2){
          pixel.blooming = true;
          pixel.color = "#FFE2E2";
        } else {
          pixel.blooming = false;
        }
      }
      for(var i = 0; i < adjacentCoords.length; i++){
        let x = pixel.x+adjacentCoords[i][0];
        let y = pixel.y+adjacentCoords[i][1];
        if(isEmpty(x, y) || outOfBounds(x, y)) { continue; }
        let pixel2 = pixelMap[x][y];
        if(pixel2.element == "fruit_branch" || pixel2.element == "fruit_leaves" || pixel2.element == "wood" || (elements[pixel2.element].properties && elements[pixel2.element].properties.type == "fruit") && pixel2.fruit != "pineapple"){
            if(pixel.fruit && !pixel2.fruit){
              pixel2.fruit = pixel.fruit;
            } else if (!pixel.fruit && pixel2.fruit){
              pixel.fruit = pixel2.fruit;
          }
        }
      }
      if(pixel.blooming){
        if(pixelTicks > pixel.start + 150){
          if(Math.floor(Math.random() * 400) == 3){
            if(pixel.fruit){
              if(pixel.fruit == "random"){
                changePixel(pixel, fruits[Math.floor(Math.random() * fruits.length)]);
              } else {
                changePixel(pixel, pixel.fruit);
              }
            }
          }
        }
      }
      if(pixel.fruit == "pineapple" && isEmpty(pixel.x, pixel.y-1) && !outOfBounds(pixel.x, pixel.y-1) && pixel.age < 300){
        pixel.blooming = false;
        pixel.color = elements.plant.color;
        createPixel("unripe_fruit", pixel.x, pixel.y-1);
        if(isEmpty(pixel.x, pixel.y-2)){
          createPixel("unripe_fruit", pixel.x, pixel.y-2);
        }
        if(isEmpty(pixel.x, pixel.y-3)){
          createPixel("fruit_leaves", pixel.x, pixel.y-3);
        }
        if(isEmpty(pixel.x-1, pixel.y-4)){
          createPixel("fruit_leaves", pixel.x-1, pixel.y-4);
        }
        if(isEmpty(pixel.x+1, pixel.y-4)){
          createPixel("fruit_leaves", pixel.x+1, pixel.y-4);
        }
    }
      pixel.age++;
  }
}

elements.apple_seed = {
    color: "#1A0E00",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves" || pixelMap[pixel.x][pixel.y+1].element == "wood"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "apple";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"apple"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.apple = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: "#ff0004",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#FF4747",
  isFood: true,
  properties: {
    fruit: "apple",
    type: "fruit",
  }
}
elements.pear_seed = {
    color: "#1A0E00",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "pear";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"pear"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.pear = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: "#97FF43",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#ABFF8D",
  isFood: true,
  properties: {
    fruit: "pear",
    type: "fruit",
  }
}
elements.cherry_seed = {
    color: "#b56233",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "cherry";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"cherry"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.cherry = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: "#750000",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#8a0000",
  isFood: true,
  properties: {
    fruit: "cherry",
    type: "fruit",
  }
}
elements.milk = {
  color: "#fafafa",
  behavior: behaviors.LIQUID,
  onMix: function(milk1, milk2) {
    if (shiftDown && Math.random() < 0.01) {
        changePixel(milk1,"butter")
    }
  },
  reactions: {
    "melted_chocolate": { elem1:"chocolate_milk", elem2:null },
    "chocolate": { elem1:"chocolate_milk", elem2:"melted_chocolate", chance:0.05 },
    "coffee_ground": { elem1:"chocolate_milk", chance:0.05 },
    "juice": { elem1:"fruit_milk", elem2:null, chance:0.05, func: function(pixel1, pixel2){
      let newrgb = interpolateRgb(getRGB('rgb(250,250,250)'), getRGB(pixel2.color), 0.25);
      pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }},
    "soda": { elem1:"pilk", elem2:null, chance:0.1 },
    "yolk": { elem1:"eggnog", elem2:null, chance:0.1 },
    "dirt": { elem1: null, elem2: "mud" },
    "sand": { elem1: null, elem2: "wet_sand" },
    "clay_soil": { elem1: null, elem2: "clay" },
    "caramel": { color1:"#C8B39A", elem2:null, chance:0.05 },
    "sugar": { elem2:null, chance:0.005},
  },
  tempLow: 0,
  stateLow: "ice_cream",
  stateLowColorMultiplier: [0.97,0.93,0.87],
  tempHigh: 93,
  stateHigh: "yogurt",
  viscosity: 1.5,
  category: "liquids",
  state: "liquid",
  density: 1036.86,
  isFood: true
}
elements.cream = {
  color: "#f7f7f7",
  behavior: behaviors.LIQUID,
  onMix: function(milk1, milk2) {
      if ((shiftDown && Math.random() < 0.01) || (elements[milk2.element].id === elements.milk.id && Math.random() < 0.00025)) {
          changePixel(milk1,"butter")
      }
  },
  reactions: {
      "dirt": { elem1: null, elem2: "mud" },
      "sand": { elem1: null, elem2: "wet_sand" },
      "clay_soil": { elem1: null, elem2: "clay" },
      "melted_chocolate": { color1:"#664934", elem2:null },
      "chocolate": { color1:"#664934", elem2:"melted_chocolate", chance:0.05 },
      "juice": { elem1:"fruit_milk", elem2:null, chance:0.05, func: function(pixel1, pixel2){
                 let newrgb = interpolateRgb(getRGB('rgb(250,250,250)'), getRGB(pixel2.color), 0.25);
                 pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
               }},
      "soda": { elem1:"pilk", elem2:null, chance:0.1 },
      "yolk": { elem1:"#eggnog", elem2:null, chance:0.1 },
      "caramel": { color1:"#C8B39A", chance:0.05 },
      "sugar": { elem2:null, chance:0.005},
  },
  viscosity: 1.5,
  tempHigh: 1000,
  stateHigh: ["smoke","smoke","smoke","steam","steam","calcium"],
  tempLow: 0,
  stateLow: "ice_cream",
  stateLowColorMultiplier: 0.97,
  category: "liquids",
  hidden: true,
  isFood: true,
  state: "liquid",
  density: 959.97,
}
function getRGB(rgb){
  let rgb2 = rgb.replace(")", "").replace("rgb(", "").replace(/,/g, "r").split("r")
  return { r: parseInt(rgb2[0]), g: parseInt(rgb2[1]), b: parseInt(rgb2[2]) };
}
elements.peach = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: ["#ffb485", "#ffa770", "#ff7b61", "#ff512e", "#ff350d"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#ffa74f",
  isFood: true,
  properties: {
    fruit: "peach",
    type: "fruit",
  }
}
elements.peach_seed = {
    color: "#240c00",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "peach";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"peach"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.plum = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: "#1c0030",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#d2880a",
  isFood: true,
  properties: {
    fruit: "plum",
    type: "fruit",
  }
}
elements.plum_seed = {
    color: "#240c00",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "plum";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"plum"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.juice.reactions.juice = {
  func: function(pixel1, pixel2){
    if(pixel1.color != pixel2.color){
      if(Math.floor(Math.random() * 1000) == 1){
      let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.5);
      pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
      pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
      }
    }
  }
}
elements.juice.onMix = function(pixel){
    let num = Math.floor(Math.random() * 4);
    let x = pixel.x + adjacentCoords[num][0];
    let y = pixel.y + adjacentCoords[num][1];
    if(!isEmpty(x,y) && !outOfBounds(x,y)){
      let pixel2 = pixelMap[x][y];
      if(pixel.color != pixel2.color && pixel2.element == "juice"){
        let condition;
        if(shiftDown == 0){
          condition = (Math.floor(Math.random() * 2) == 1); 
        } else {
          condition = true; 
        }
        if(condition){
          let newrgb = interpolateRgb(getRGB(pixel.color), getRGB(pixel2.color), 0.5);
          pixel.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
          pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
      }
    }
  }
elements.vine.behavior = [["XX", "ST:vine", "XX"],["ST:vine", "XX", "ST:vine"],["XX", "ST:vine AND M1", "XX"]]
elements.apricot = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: ["#ffa100", "#FF5D00", "#FF7A00", "#FF9700"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#ffa836",
  isFood: true,
  properties: {
    fruit: "apricot",
    type: "fruit",
  }
}
elements.apricot_seed = {
    color: "#291300",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "apricot";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"apricot"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.orange = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: "#FFB400",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#FFDB00",
  isFood: true,
  properties: {
    fruit: "orange",
    type: "fruit",
  }
}
elements.orange_seed = {
    color: "#291300",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "orange";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"orange"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.random_seed = {
    color: "#291300",
    tick: function(pixel) {
      if(pixel.start == pixelTicks){
        pixel.fruit = fruits[Math.floor(Math.random() * fruits.length)];
      }
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = pixel.fruit;
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.multi_seed = {
    color: "#291300",
    tick: function(pixel) {
      pixel.fruit = fruits[Math.floor(Math.random() * fruits.length)]
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "random";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.fruit_vine = {
  category: "life",
  color: elements.plant.color,
  behavior: [["XX", "ST:fruit_vine AND ST:wood", "XX"], ["ST:fruit_vine AND ST:wood", "XX", "ST:fruit_vine AND ST:wood"], ["XX", "ST:fruit_vine AND M1 AND ST:wood", "XX"]],
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(Math.floor(Math.random() * 100) == 1 && pixel.age > 25 && pixel.age < 500){
      for(var i = 0; i < squareCoords.length; i++){
        let x1 = pixel.x + squareCoords[i][0];
        let y1 = pixel.y + squareCoords[i][1];
        if(!isEmpty(x1,y1) && !outOfBounds(x1,y1) && !vineExclude.includes(pixelMap[x1][y1].element)){
          let randomNum = Math.floor(Math.random() * 4);
          let x2 = x1 + squareCoords[randomNum][0];
          let y2 = y1 + squareCoords[randomNum][1];
          if(isEmpty(x2,y2) && !outOfBounds(x2,y2)){
            createPixel("fruit_vine", x2, y2);
            pixelMap[x2][y2].fruit = pixel.fruit;
          }
        }
      }
    }
    pixel.age += 1;
    if(pixel.fruit){
      for(var i = 0; i < adjacentCoords.length; i++){
        let x = pixel.x + adjacentCoords[i][0];
        let y = pixel.y + adjacentCoords[i][1];
        if(isEmpty(x,y) && !outOfBounds(x,y) && Math.floor(Math.random() * 1000) == 5){
          createPixel(pixel.fruit, x, y);
        }
      }
    }
    if(!pixel.fruit){
      for(var i = 0; i < squareCoords.length; i++){
        let x = pixel.x + squareCoords[i][0];
        let y = pixel.y + squareCoords[i][1];
        if(isEmpty(x,y) || outOfBounds(x,y)){ continue; }
        let pixel2 = pixelMap[x][y];
        if(pixel2.fruit){
          pixel.fruit = pixel2.fruit;
        } else { continue; }
      }
    }
  }
}
elements.grape.behavior = [["XX", "ST:fruit_vine", "XX"], ["ST:fruit_vine", "XX", "ST:fruit_vine"], ["M2", "ST:fruit_vine AND M1", "M2"]];
elements.tomato.behavior = elements.grape.behavior;
elements.tomato_seed = {
  color: "#FFFAAD",
  category: "life",
  behavior: behaviors.POWDER,
  tick: function(pixel){
    if(pixel.age > 40){
      changePixel(pixel, "fruit_vine");
      pixel.fruit = "tomato";
    }
    pixel.age += 1;
  },
  properties: {
    age: 0,
  },
}
elements.grape_seed = {
  color: "#231A00",
  category: "life",
  behavior: behaviors.POWDER,
  tick: function(pixel){
    if(pixel.age > 40){
      changePixel(pixel, "fruit_vine");
      pixel.fruit = "grape";
    }
    pixel.age += 1;
  },
  properties: {
    age: 0,
  },
}
elements.kiwi = {
  behavior: elements.grape.behavior,
  color: "#403000",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#21A800",
  isFood: true,
  properties: {
    type: "fruit",
  }
}
elements.kiwi_seed = {
  color: "#231A00",
  category: "life",
  behavior: behaviors.POWDER,
  tick: function(pixel){
    if(pixel.age > 40){
      changePixel(pixel, "fruit_vine");
      pixel.fruit = "kiwi";
    }
    pixel.age += 1;
  },
  properties: {
    age: 0,
  },
}
elements.bush_base = {
  color: elements.wood.color,
  behavior: [
    ["CR:bush_cane%25", "XX", "CR:bush_cane%25"],
    ["XX", "XX", "XX"],
    ["XX", "XX", "XX"]
  ],
  tempHigh: 100,
  stateHigh: "dead_plant",
  tempLow: -40,
  stateLow: "frozen_plant",
  burn: 65,
  burnTime: 15,
  category: "life",
  state: "solid",
  tick: function(pixel){
    let caneCoords = [[-1,-1],[1,-1]];
    for(var i = 0; i < caneCoords.length; i++){
      let x = pixel.x + caneCoords[i][0];
      let y = pixel.y + caneCoords[i][1];
      if(!isEmpty(x,y) && !outOfBounds(x,y)){
        let pixel2 = pixelMap[x][y];
        if(pixel2.element == "bush_cane" && !pixel2.fruit){
          pixel2.fruit = pixel.fruit;
        }
      } 
    }
  }
};
elements.bush_cane = {
  color: elements.wood.color,
  tick: function(pixel){
    if(pixel.age < 200 && Math.floor(Math.random() * 40) == 1){
      if(!outOfBounds(pixel.x,pixel.y-1)){
        if(isEmpty(pixel.x,pixel.y-1)){
          createPixel("bush_cane",pixel.x,pixel.y-1);
          if(pixel.fruit){
            let pixel2  = pixelMap[pixel.x][pixel.y-1];
            pixel2.fruit = pixel.fruit;
            pixel2.age = pixel.age;
          }
        }
      }
    }
    if(pixel.fruit && Math.floor(Math.random() * 400) == 1 && pixel.age > 200){
      for(var i = 0; i < adjacentCoords.length; i++){
        let x = pixel.x + adjacentCoords[i][0];
        let y = pixel.y + adjacentCoords[i][1];
        if(isEmpty(x,y) && !outOfBounds(x,y)){
          createPixel("fruit_leaves", x, y);
          pixelMap[x][y].fruit = pixel.fruit;
          pixel.blooming = trueFalse(1, 1)[Math.floor(Math.random() * 2)];
        }
      }
    }
    pixel.age += 1;
  },
  properties: {
    age: 0,
  },
  category: "life",
  tempLow: -2,
  stateLow: "frozen_plant",
}
function trueFalse(numTrue, numFalse){
  let list = [];
  for(var i = 0; i < numTrue; i++){
    list.push(true);
  }
  for(var i = 0; i < numFalse; i++){
    list.push(false);
  }
  return list;
}
elements.raspberry_seed = {
  color: "#ffe099",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(pixel.age > 40){
      let x1 = pixel.x - 1;
      let y = pixel.y;
      let x2 = pixel.x + 1;
      if(isEmpty(x1,y) && !outOfBounds(x1,y)){
        createPixel("bush_base", x1, y);
        pixelMap[x1][y].fruit = "raspberry";
      }
      if(isEmpty(x2,y) && !outOfBounds(x2,y)){
        createPixel("bush_base", x2, y);
        pixelMap[x2][y].fruit = "raspberry";
      }
      if(!isEmpty(x1, y) && !isEmpty(x2, y)){
        deletePixel(pixel.x, pixel.y);
      }
    }
     pixel.age += 1;
  }
}
elements.raspberry = {
  behavior: [["XX", "ST:bush_cane", "XX"],["ST:bush_cane", "XX", "ST:bush_cane"],["M2", "ST:bush_cane AND M1", "M2"]],
  color: ["#b00009", "#bf000a", "#d10812", "#db1822"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#ff2b36",
  isFood: true,
  properties: {
    fruit: "raspberry",
    type: "fruit",
  }
}
elements.blueberry_seed = {
  color: "#ffe099",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(pixel.age > 40){
      let x1 = pixel.x - 1;
      let y = pixel.y;
      let x2 = pixel.x + 1;
      if(isEmpty(x1,y) && !outOfBounds(x1,y)){
        createPixel("bush_base", x1, y);
        pixelMap[x1][y].fruit = "blueberry";
      }
      if(isEmpty(x2,y) && !outOfBounds(x2,y)){
        createPixel("bush_base", x2, y);
        pixelMap[x2][y].fruit = "blueberry";
      }
      if(!isEmpty(x1, y) && !isEmpty(x2, y)){
        deletePixel(pixel.x, pixel.y);
      }
    }
     pixel.age += 1;
  }
}
elements.blueberry = {
  behavior: [["XX", "ST:bush_cane", "XX"],["ST:bush_cane", "XX", "ST:bush_cane"],["M2", "ST:bush_cane AND M1", "M2"]],
  color: ["#01082b", "#060e3d", "#111b52", "#1e2866"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#726778",
  isFood: true,
  properties: {
    fruit: "blueberry",
    type: "fruit",
  }
}
elements.blackberry_seed = {
  color: "#ffe099",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(pixel.age > 40){
      let x1 = pixel.x - 1;
      let y = pixel.y;
      let x2 = pixel.x + 1;
      if(isEmpty(x1,y) && !outOfBounds(x1,y)){
        createPixel("bush_base", x1, y);
        pixelMap[x1][y].fruit = "blackberry";
      }
      if(isEmpty(x2,y) && !outOfBounds(x2,y)){
        createPixel("bush_base", x2, y);
        pixelMap[x2][y].fruit = "blackberry";
      }
      if(!isEmpty(x1, y) && !isEmpty(x2, y)){
        deletePixel(pixel.x, pixel.y);
      }
    }
     pixel.age += 1;
  }
}
elements.blackberry = {
  behavior: [["XX", "ST:bush_cane", "XX"],["ST:bush_cane", "XX", "ST:bush_cane"],["M2", "ST:bush_cane AND M1", "M2"]],
  color: ["#0c0021", "#070014", "#080017", "#09001a"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#2e0000",
  isFood: true,
  properties: {
    fruit: "blackberry",
    type: "fruit",
  }
}
elements.mango = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: ["#d63a45", "#e97341", "#9d9f3e", "#e4791b"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#ffa300",
  isFood: true,
  properties: {
    fruit: "mango",
    type: "fruit",
  }
}
elements.mango_seed = {
    color: "#240c00",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                    if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                      pixelMap[pixel.x][pixel.y+1].fruit = "mango";
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
      fruit:"mango"
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
};
elements.seed_maker = {
  category: "machines",
  behavior: behaviors.WALL,
  noMix: true,
  movable: false,
  tick: function(pixel){
    for(var i = 0; i < adjacentCoords.length; i++){
      let x = pixel.x + adjacentCoords[i][0];
      let y = pixel.y + adjacentCoords[i][1]
      if(!isEmpty(x,y) && !outOfBounds(x,y)){
        let pixel2 = pixelMap[x][y];
        if(allFruits.includes(pixel2.element)){
          changePixel(pixel2, `${pixel2.element}_seed`)
        } else if (pixel2.element == "cocoa_pod"){
          changePixel(pixel2, "cocoa_bean");
        }
      }
    }
  }
}
function xyInRange(x, y, range){
  let i = 0;
  while (i < range.length) {
    if (x === range[i][0] && y === range[i][1]) {
      i++;
      return true;
    } else {
        i++;
      }

    }
    return false;

}
elements.watermelon = {
  behavior: behaviors.WALL,
  color: "#007706",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#C1674C",
  isFood: true,
  properties: {
    type: "fruit",
    age: 0,
  },
  tick: function(pixel){
    if(pixel.grow && pixel.age > 400){
      pixel.grow = false;
    }
    if(pixel.grow && pixel.range){
      for(var i = 0; i < adjacentCoords.length; i++){
        let x = pixel.x + adjacentCoords[i][0];
        let y = pixel.y + adjacentCoords[i][1];
        if(isEmpty(x,y) && xyInRange(x,y,pixel.range) && !outOfBounds(x,y)){
          if(Math.floor(Math.random() * 300) == 1){
            createPixel("watermelon", x, y);
          }
        }
        
      }
      for(var i = 0; i < adjacentCoords.length; i++){
        let x = pixel.x + adjacentCoords[i][0];
        let y = pixel.y + adjacentCoords[i][1];
        if(!isEmpty(x,y) && !outOfBounds(x,y)){
          let pixel2 = pixelMap[x][y];
          if(["wood","low_fruit_vine","watermelon"].includes(pixel.element)){
            if(!pixel2.range || !pixel2.grow){
              if(pixel.range && !pixel2.range){
                pixel2.range = pixel.range;
              }
              if(pixel.grow && !pixel2.grow){
                pixel2.grow = pixel.grow;
              }  
            }
            if(pixel2.range || pixel2.grow){
              if(!pixel.range && pixel2.range){
                pixel.range = pixel2.range;
              }
              if(!pixel.grow && pixel2.grow){
                pixel.grow = pixel2.grow;
              }
            }
          }
        }
      }
    }
    pixel.age++;
  }
}
let sizes = [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7, 9]
elements.low_fruit_vine = {
  color: elements.fruit_vine.color,
  behavior: behaviors.WALL,
  tick: function(pixel){
    if(pixel.fruiting && pixel.fruit == "watermelon"){
      pixel.fruiting = false;
      let size = pixel.size;
      let range = mouseRange(pixel.x, pixel.y + Math.floor(size / 2 + 1), size)
      if(isEmpty(pixel.x, pixel.y + 1) && !outOfBounds(pixel.x, pixel.y + 1)){
        createPixel("watermelon", pixel.x, pixel.y + 1);
        let pixel2 = pixelMap[pixel.x][pixel.y + 1];
        pixel2.range = range;
        pixel2.grow = true;
      }
    } else {
      if(isEmpty(pixel.x, pixel.y - 1) && !outOfBounds(pixel.x, pixel.y - 1) && Math.floor(Math.random() * 300) == 1 && pixel.fruit && ![undefined, "watermelon"].includes(pixel.fruit)){
        createPixel(pixel.fruit, pixel.x, pixel.y - 1);
      }
    }
    if(Math.floor(Math.random() * 100) == 1 && !["watermelon", undefined].includes(pixel.fruit)){
      eval((Math.floor(Math.random() * 2) == 1) ? `
      if(isEmpty(pixel.x + 1, pixel.y)){
        createPixel("low_fruit_vine", pixel.x + 1, pixel.y);
        pixelMap[pixel.x + 1][pixel.y].fruit = pixel.fruit;
      }`
       : `
       if(isEmpty(pixel.x - 1, pixel.y)){
        createPixel("low_fruit_vine", pixel.x - 1, pixel.y);
        pixelMap[pixel.x - 1][pixel.y].fruit = pixel.fruit;
        }`
        )
    }
  }
}
let sizeObj = {
  size3: [
    [0,1],
    [0,2],
    [1,3],
    [2,3]
  ],
  size5:[
    [0,1],
    [0,2],
    [0,3],
    [0,4],
    [1,5],
    [2,5],
    [3,5],
  ],
  size7: [
    [0,1],
    [0,2],
    [0,3],
    [0,4],
    [0,5],
    [0,6],
    [1,7],
    [2,7],
    [3,7],
    [4,7],
  ],
  size9: [
    [0,1],
    [0,2],
    [0,3],
    [0,4],
    [0,5],
    [0,6],
    [0,7],
    [0,8],
    [1,9],
    [2,9],
    [3,9],
    [4,9],
    [5,9],
  ]
}
elements.watermelon_seed = {
  color: "#231A00",
  category: "life",
  behavior: behaviors.STURDYPOWDER,
  tick: function(pixel){
    if(pixel.start == pixelTicks - 10){
      pixel.size = sizes[Math.floor(Math.random() * sizes.length)];
      pixel.direction = Math.floor(Math.random() * 2)
      pixel.grow = true;
    }
    if(pixel.grow && !isEmpty(pixel.x,pixel.y+1) && !outOfBounds(pixel.x,pixel.y+1) && pixelMap[pixel.x][pixel.y + 1].element == "dirt" && pixel.age > 100){
      pixel.fruit = "watermelon";
      let sizeList = sizeObj[`size${pixel.size}`];
      for(var i = 0; i < sizeList.length; i++){
        let x = (pixel.direction == 1) ? pixel.x - sizeList[i][0] : pixel.x + sizeList[i][0];
        let y = pixel.y - sizeList[i][1];
        if(isEmpty(x, y) && !outOfBounds(x, y)){
          createPixel("low_fruit_vine", x, y);
          if(i == sizeList.length - 1){
            pixelMap[x][y].fruiting = true;
            pixelMap[x][y].size = pixel.size;
            pixelMap[x][y].fruit = "watermelon";
            changePixel(pixel,"low_fruit_vine");
          }
        }
      }
    }
    pixel.age++;
  },
  properties: {
    age: 0,
  },
}
elements.strawberry = {
  behavior: behaviors.POWDER,
  color: "#e5080a",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#f9c0af",
  isFood: true,
  properties: {
    type: "fruit",
    age: 0,
  },
}
elements.strawberry_seed = {
  color: "#ffa371",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(pixel.age > 40){
      changePixel(pixel, "low_fruit_vine");
      pixel.fruit = "strawberry";
    }
     pixel.age += 1;
  }
}
elements.cucumber = {
  behavior: behaviors.POWDER,
  color: "#285a1b",
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#80b450",
  isFood: true,
  properties: {
    type: "fruit",
    age: 0,
  },
}
let ages = {
  pineapple: 140,
}
elements.cucumber_seed = {
  color: "#e9f5b5",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(pixel.age > 40){
      changePixel(pixel, "low_fruit_vine");
      pixel.fruit = "cucumber";
    }
     pixel.age += 1;
  }
}
elements.unripe_fruit = {
  color: "#9eba32",
  behavior: behaviors.WALL,
  category: "life",
  properties: {
    age: 0,
    fruit: "pineapple",
  },
  tick: function(pixel){
    if(pixel.age >= ages[pixel.fruit] && Math.floor(Math.random() * 100) == 1){
      changePixel(pixel, pixel.fruit);
    }
    pixel.age++;
  },
  breakInto: ["poison", "juice", "cyanide"],
  breakIntoColor: "#9eba32",
}
elements.pineapple = {
  behavior: [["XX", "ST:fruit_leaves", "XX"],["ST:fruit_leaves", "XX", "ST:fruit_leaves"],["M2", "ST:fruit_leaves AND M1", "M2"]],
  color: ["#ffcc56", "#e69f05", "#ffc061", "#fad32b"],
  category: "food",
  breakInto: "juice",
  breakIntoColor: "#ffd905",
  isFood: true,
  properties: {
    type: "fruit",
    age: 0,
  },
}
elements.pineapple_seed = {
  color: "#7b2700",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(pixel.age > 40){
      changePixel(pixel, "fruit_leaves");
      pixel.fruit = "pineapple";
    }
     pixel.age += 1;
  }
}
elements.cocoa_pod = {
  behavior: [["XX", "ST:fruit_leaves AND ST:fruit_branch", "XX"],["ST:fruit_leaves AND ST:fruit_branch", "XX", "ST:fruit_leaves AND ST:fruit_branch"],["M2", "ST:fruit_leaves AND ST:fruit_branch AND M1", "M2"]],
  color: "#9e5648",
  category: "food",
  breakInto: ["cocoa_butter", "cocoa_bean"],
  isFood: true,
  properties: {
    fruit: "cocoa_pod",
    type: "fruit",
  }
}
elements.cocoa_bean = {
  behavior: behaviors.POWDER,
  color: "#ebaf7b",
  category: "food",
  isFood: true,
  properties: {
    fruit: "cocoa_pod",
    type: "fruit",
    age: 0,
  },
  tempHigh: 122,
  stateHigh: "roasted_cocoa_bean",
  tick: function(pixel) {
      if (isEmpty(pixel.x,pixel.y+1)) {
          movePixel(pixel,pixel.x,pixel.y+1);
      }
      else {
          if (Math.random() < 0.02 && pixel.age > 650 && pixel.temp < 120) {
              if (!outOfBounds(pixel.x,pixel.y+1)) {
                  var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                  if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                      changePixel(dirtPixel,"root");
                  }
              }
              if (isEmpty(pixel.x,pixel.y-1)) {
                  movePixel(pixel,pixel.x,pixel.y-1);
                  createPixel(Math.random() > 0.5 ? "wood" : "fruit_branch",pixel.x,pixel.y+1);
                  if (pixelMap[pixel.x][pixel.y+1].element == "fruit_branch" || pixelMap[pixel.x][pixel.y+1].element == "fruit_leaves"){
                    pixelMap[pixel.x][pixel.y+1].fruit = "cocoa_pod";
                  }
              }
          }
          else if (pixel.age > 1650) {
              changePixel(pixel,"wood");
          }
          pixel.age++;
      }
      doDefaults(pixel);
  },
}

elements.cocoa_butter = {
  behavior: behaviors.STURDYPOWDER,
  color: "#ddc996",
  category: "food",
  isFood: true,
  tempHigh: 30,
  stateHigh: "melted_cocoa_butter",
}
elements.melted_cocoa_butter = {
  behavior: behaviors.LIQUID,
  color: "#c78b06",
  category: "states",
  isFood: true,
  viscosity: 2000,
  tempLow: 30,
  stateLow: "cocoa_butter",
  temp: 30,
  reactions: {
    sugar: { elem1: "melted_white_chocolate", elem2: "melted_white_chocolate" }
  }
}
elements.roasted_cocoa_bean = {
  behavior: behaviors.POWDER,
  color: "#6b3b24",
  category: "food",
  isFood: true,
  breakInto: "cocoa_powder",
}
elements.cocoa_powder = {
  behavior: behaviors.POWDER,
  color: "#451f16",
  category: "food",
  isFood: true,
  reactions: {
    melted_cocoa_butter: { elem1: "chocolate", elem2: "chocolate" }
  }
}
elements.extractor = {
  category: "machines",
  noMix: true,
  movable: false,
  behavior: behaviors.WALL,
  tick: function(pixel){
    for(var i = 0; i < adjacentCoords.length; i++){
      let x = pixel.x + adjacentCoords[i][0];
      let y = pixel.y + adjacentCoords[i][1]
      if(!isEmpty(x,y) && !outOfBounds(x,y)){
        let pixel2 = pixelMap[x][y];
        if (pixel2.element == "cocoa_pod"){
          changePixel(pixel2, "cocoa_butter");
        } else if (pixel2.element == "sugarcane"){
          changePixel(pixel2, "sugar");
        }
      }
    }
  }
}
elements.white_chocolate = {
      "color": "#f4e6cb",
      "behavior": [
          [
              "XX",
              "XX",
              "XX"
          ],
          [
              "XX",
              "XX",
              "XX"
          ],
          [
              "XX",
              "M1",
              "XX"
          ]
      ],
      "tempHigh": 31,
      "stateHigh": "melted_white_chocolate",
      "category": "food",
      "state": "solid",
      "density": 1325,
      "isFood": true,
      "movable": true
  }
elements.melted_white_chocolate = {
  behavior: behaviors.LIQUID,
      "color": "#f2d184",
      "tempLow": 0,
      "stateLow": "white_chocolate",
      "tempHigh": 99,
      "stateHigh": [
          "steam",
          "sugar"
      ],
      "category": "states",
      "viscosity": 40,
      "state": "liquid",
      "density": 1325,
      "hidden": true,
      "stain": 0.05,
      "isFood": true,
      "movable": true
  }
elements.sugarcane_seed = {
  color: "#c4ae7d",
  behavior: behaviors.STURDYPOWDER,
  category: "life",
  properties: {
    age: 0,
  },
  tick: function(pixel){
    if(isEmpty(pixel.x, pixel.y-1) && !outOfBounds(pixel.x, pixel.y-1) && Math.floor(Math.random() * 100) == 1 && pixel.age > 40){
      movePixel(pixel,pixel.x,pixel.y-1);
      createPixel("sugarcane",pixel.x,pixel.y+1);
    } else if (!isEmpty(pixel.x, pixel.y-1) && !outOfBounds(pixel.x, pixel.y-1) && pixelMap[pixel.x][pixel.y-1].element == "sugarcane_seed"){
      deletePixel(pixel.x, pixel.y-1);
    }
    if(!pixel.age){
      pixel.age = 1;
    } else {
      pixel.age++;
    }
    if(pixel.age == 550){
      changePixel(pixel, "sugarcane")
    }
  }
}
elements.sugarcane = {
  color: "#76881c",
  breakInto: ["sugar_water", "dead_plant", "dead_plant", "dead_plant"],
  isFood: true,
  behavior: behaviors.WALL,
  category: "food",
}
// created by SquareScreamYT
// the sequel to aChefsDream!

runAfterLoad(function() {
    console.log("Thanks for using aChefsDream2.js! -sqec")
})

var mods_to_include = ["mods/aChefsDream.js"]

var mods_included = mods_to_include.map(mod => enabledMods.includes(mod));
var all_mods_included = mods_included.reduce(function(a,b) { return a && b });

if(!all_mods_included) {
    var mods_needed = mods_to_include.filter(function(modPath) { return !(enabledMods.includes(modPath)) });

    mods_needed.forEach(function(modPath) {
		enabledMods.splice(enabledMods.indexOf("mods/aChefsDream2"),0,modPath);
	});
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
}

// Pork and Pigs

elements.pig = {
    color: ["#9c6732", "#dbb997", "#fcaeae"],
    behavior: [
        "M2%1|XX|M2%1",
        "M2%10|XX|M2%10",
        "XX|M1|XX",
    ],
    category:"life",
	state: "solid",
    reactions: {
        "petal": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "lettuce": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "wheat": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    },
    egg: "piglet",
    foodNeed: 10,
    temp: 40,
    tempHigh: 75,
    stateHigh: "cooked_pork",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "raw_pork",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 1117,
    conduct: 0.3,
    extractInto: "raw_pork",
};
elements.piglet = {
    color: ["#f7bebe", "#d1a88e"],
    behavior: [
        "M2%1|XX|M2%1",
        "M2%10|FX%5 AND CH:pig%0.1|M2%10",
        "XX|M1|XX",
    ],
    category: "life",
    state: "solid",
    foodNeed: 20,
    temp: 40,
    tempHigh: 75,
    stateHigh: "cooked_pork",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "blood",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    reactions: {
        "petal": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "lettuce": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "wheat": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    },
};

elements.barbecued_pork = {
    color:["#a1391f","#ab5e32"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.cooked_pork = {
    color: ["#e6bf8a", "#e3be96"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
    alias: "cooked_pork"
};

elements.raw_pork = {
    color: ["#ed5d47", "#e0423d"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "cooked_pork",
    temp:25,
    tempHigh: 200,
    stateHigh: "cooked_pork",
    reactions: {
        "charcoal": {elem1: "barbecued_pork", tempMin: 70},
        "fire": {elem1: "barbecued_pork"}
    }
};

// Extraction tool

elements.extract = {
    color: "#82452c",
    // other needed properties
    tool: (pixel) => {
        //store extractInto as a variable for legibility
        var extractInto = elements[pixel.element].extractInto;
        //if theres no extractInto, it should equal undefined, which is falsey and !undefined = true
        if (!extractInto) { return };
        //if extractInto is an array, randomly pick one of its elements
        if(extractInto instanceof Array) { extractInto = extractInto[Math.floor(Math.random() * extractInto.length)] };
        //change pixel into the (chosen) element
        if (shiftDown) {
            if (Math.random() < 0.5) {
                var thiselement = pixel.element;
                changePixel(pixel, extractInto)
                pixelTempCheck(pixel);
                if (elements[thiselement].extractIntoColor) {
                    pixel.color = pixelColorPick(pixel, elements[thiselement].extractIntoColor);
                }
            }
        }
        else if (!shiftDown) {
            if (Math.random() < 0.1) {
                var thiselement = pixel.element;
                changePixel(pixel, extractInto)
                pixelTempCheck(pixel);
                if (elements[thiselement].extractIntoColor) {
                    pixel.color = pixelColorPick(pixel, elements[thiselement].extractIntoColor);
                }
            }
        }
    },
    category: "tools",
    canPlace: false,
    desc: "Use on pixels to extract the essence from them, if possible. [BETA]"
}

// spices

elements.allspice = {
    color: ["#7B5B3A", "#A75B3D", "#B67B57", "#C19A6B"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

elements.cumin = {
    color: "#A58459",
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

elements.paprika = {
    color: ["#C72C29","#b22b02"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

elements.turmeric = {
    color: ["#E5B635","#D9A322"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

elements.saffron = {
    color: ["#b83b3b","#a82525"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

// sugarcane

elements.sugarcane_plant = {
    color: ["#fbc852","#dfad54"],
    behavior: [
        "XX|M2%2|XX",
        "XX|L2:sugarcane AND C2:sugarcane%10|XX",
        "XX|M1|XX",
    ],
    tick: behaviors.SEEDRISE,
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "sugarcane",
    burn: 30,
    burnTime: 100,
    category: "life",
    state: "solid",
    density: 686,
    breakInto: "cane_sugar",
    cooldown: defaultCooldown,
    seed: true
}
elements.sugarcane = {
    color: ["#7cc05c","#77a052"],
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 380,
    stateHigh: ["ember","fire","fire","fire"],
    burn: 10,
    burnTime: 200,
    burnInto: ["ember","fire","fire","fire"],
    category: "food",
    state: "solid",
    density: 686,
    breakInto: "cane_sugar",
    seed: "sugarcane_plant"
}
elements.cane_sugar = {
    color: "#ffeedb",
    behavior: behaviors.POWDER,
    reactions: {
        "grape": { elem1:null, elem2:"jelly", chance:0.005, tempMin:100 },
        "water": { elem1:null, elem2:"sugar_water"},
    },
    category: "food",
    tempHigh: 186,
    stateHigh: "caramel",
    state: "solid",
    density: 1590,
    isFood: true
}
elements.tea_leaves = {
    color: ["#3e6e26","#507e28","#759e2e"],
    reactions: {
        "water": { elem2:"tea", tempMin:80 },
        "salt_water": { elem2:"tea", tempMin:80 },
        "sugar_water": { elem2:"tea", tempMin:80 },
        "seltzer": { elem2:"tea", tempMin:80 },
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
    },
    behavior: behaviors.POWDER,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    tempLow: -2,
    stateLow: "frozen_plant",
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
}
elements.cinnamon = {
    color: "#986544",
    reactions: {
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
    },
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
    breakInto: "cinnamon_powder"
}
elements.cinnamon_powder = {
    color: "#D2691E",
    reactions: {
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
    },
    behavior: behaviors.POWDER,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
}
elements.cola_syrup = {
    color: "#4f0e0e",
    behavior: behaviors.LIQUID,
    tempHigh: 170,
    stateHigh: ["sugar","smoke","smoke"],
    tempLow: -15,
    category:"liquids",
    state: "liquid",
    viscosity: 15,
    hidden: true,
    density: 1400,
    reactions: {
        "seltzer": { elem1: ["cola_syrup", "cola_syrup", "foam"], elem2:"soda"},
        "soda": { elem1: "foam", chance:0.001},
    },
}
if (!elements.sugar_water.reactions) elements.sugar_water.reactions = {};
elements.sugar_water.reactions.lemon_juice = { elem1: "sugar_water", elem2: null, color1: "#fff7ba" }
if (!elements.sugar_water.reactions) elements.sugar_water.reactions = {};
elements.sugar_water.reactions.cinnamon_powder = { elem1: "cola_syrup", elem2: null }
// created by SquareScreamYT
// https://github.com/SquareScreamYT/aChefsDream.js

runAfterLoad(function() {
    console.log("Thanks for using aChefsDream.js! -sqec")
    console.log("aChefsDream is hosted at https://github.com/SquareScreamYT/aChefsDream.js")
})

function interpolateRgb(rgb1, rgb2, ratio) {
    const interpolatedRgb = {
      r: Math.round(rgb1.r + (rgb2.r - rgb1.r) * ratio),
      g: Math.round(rgb1.g + (rgb2.g - rgb1.g) * ratio),
      b: Math.round(rgb1.b + (rgb2.b - rgb1.b) * ratio),
    };
    return interpolatedRgb;
}
function getRGB(rgb){
    let rgb2 = rgb.replace(")", "").replace("rgb(", "").replace(/,/g, "r").split("r")
    return { r: parseInt(rgb2[0]), g: parseInt(rgb2[1]), b: parseInt(rgb2[2]) };
}
function findMostFrequent(arr) {
    let freqMap = {};
    
    if (arr) {
        if (arr.length === 0) {
            return "water";
        } else if (arr.length === 1) {
            return arr[0]
        } else {
            arr.forEach(item => {
            if(!freqMap[item]) {
                freqMap[item] = 0;
            }
            freqMap[item]++;
            });
        
            let max = 0;
            let mostFrequent = [];
        
            for (let item in freqMap) {
            if (freqMap[item] > max) {
                max = freqMap[item];
                mostFrequent = [item];
            } else if (freqMap[item] === max) {
                mostFrequent.push(item);
            }
            }
            return mostFrequent.join(', '); 
        }  
    }
}
behaviors.STURDYPOWDER2 = [
    "XX|XX|XX",
    "XX|XX|XX",
    "M2%30|M1|M2%30",
],

elements.knife = {
    color: "#adb5bd",
    // other needed properties
    tool: (pixel) => {
        //store cutInto as a variable for legibility
        var cutInto = elements[pixel.element].cutInto;
        //if theres no cutInto, it should equal undefined, which is falsey and !undefined = true
        if (!cutInto) { return };
        //if cutInto is an array, randomly pick one of its elements
        if(cutInto instanceof Array) { cutInto = cutInto[Math.floor(Math.random() * cutInto.length)] };
        //change pixel into the (chosen) element      
        //changePixel(pixel, cutInto)
        if (shiftDown) {
            if (Math.random() < 0.5) {
                var thiselement = pixel.element;
                changePixel(pixel, cutInto)
                pixelTempCheck(pixel);
                if (elements[thiselement].cutIntoColor) {
                    pixel.color = pixelColorPick(pixel, elements[thiselement].cutIntoColor);
                }
            }
        }
        else if (!shiftDown) {
            if (Math.random() < 0.1) {
                var thiselement = pixel.element;
                changePixel(pixel, cutInto)
                pixelTempCheck(pixel);
                if (elements[thiselement].cutIntoColor) {
                    pixel.color = pixelColorPick(pixel, elements[thiselement].cutIntoColor);
                }
            }
        }
    },
    category:"tools",
    canPlace: false,
    desc: "Use on pixels to cut them, if possible."
}
elements.whisk = {
    color: ["#a4a7b0","#a4a7b0","#a4a7b0","#bfc2c9","#e9eaf0","#bfc2c9","#a4a7b0"],
    // other needed properties
    tool: (pixel) => {
        //store whiskInto as a variable for legibility
        var whiskInto = elements[pixel.element].whiskInto;
        //if theres no whiskInto, it should equal undefined, which is falsey and !undefined = true
        if (!whiskInto) { return };
        //if whiskInto is an array, randomly pick one of its elements
        if(whiskInto instanceof Array) {whiskInto = whiskInto[Math.floor(Math.random() * whiskInto.length)] };
        //change pixel into the (chosen) element      
        //changePixel(pixel, whiskInto)
        if (shiftDown) {
            if (Math.random() < 0.5) {
                changePixel(pixel, whiskInto)
            }
        }
        else if (!shiftDown) {
            if (Math.random() < 0.1) {
                changePixel(pixel, whiskInto)
            }
        }
    },
    category:"tools",
    canPlace: false,
    desc: "Use on pixels to whisk them, if possible."
}
elements.freeze_dry = {
    color: "#3a65b5",
    tool: function(pixel) {
        if (elements[pixel.element].freezeDryInto !== undefined) {
            if (Math.random() < 0.2) {
                var freezeDryInto = elements[pixel.element].freezeDryInto;
                if (Array.isArray(freezeDryInto)) {
                    freezeDryInto = freezeDryInto[Math.floor(Math.random() * freezeDryInto.length)];
                }
                if (freezeDryInto === null) {
                    deletePixel(pixel.x,pixel.y);
                    return;
                }
                var previouselement = pixel.element;
                changePixel(pixel,freezeDryInto);
                pixelTempCheck(pixel);
                if (elements[previouselement].freezeDryIntoColor) {
                    pixel.color = pixelColorPick(pixel, elements[previouselement].freezeDryIntoColor);
                }
            }
        }
    },
    category: "tools",
    excludeRandom: true,
    desc: "Use on pixels to freeze dry them, if possible."
}

elements.food_paint = {
    color: ["#c27070","#c29c70","#c2c270","#70c270","#70c2c2","#7070c2","#c270c2"],
    tool: function(pixel) {
        if (elements[pixel.element].isFood == true) {
            if (!shiftDown) {
                pixel.color = pixelColorPick(pixel,currentColor)
            }
            else {
                var rgb = currentColor.replace("#","").match(/.{1,2}/g);
                for (var i = 0; i < rgb.length; i++) {
                    rgb[i] = parseInt(rgb[i],16);
                }
                pixel.color = "rgb(" + rgb.join(",") + ")"
            }
            delete pixel.origColor;
        }
    },
    customColor: true,
    category: "tools",
    canPlace: false,
    desc: "Use on edible pixels to change color."
}

elements.eat = {
    color: ["#ffba79","#efff79"],
    tool: function(pixel) {
        if (elements[pixel.element].isFood || elements[pixel.element].category === "food" || eLists.JUICEMIXABLE.includes(pixel.element) || elements[pixel.element].id === elements.uranium.id || elements[pixel.element].id === elements.mercury.id) {
            deletePixel(pixel.x, pixel.y);
        }
    },
    category: "tools",
    desc: "Eats pixels."
}
elements.drink = {
    color: ["#03c6fc","#03a1fc"],
    tool: function(pixel) {
        if (elements[pixel.element].state === "liquid") {
            deletePixel(pixel.x, pixel.y);
        }
    },
    category: "tools",
    desc: "Drinks pixels."
}

eLists.JUICEMIXABLE = ["juice"];

elements.chicken = {
    color: ["#c29046", "#f5d271", "#d4bd7d"],
    behavior: [
        "M2%1|M2%2|M2%1",
        "M2%10|XX|M2%10",
        "XX|M1%33|XX",
    ],
    category:"life",
	state: "solid",
    reactions: {
        "meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "chicken_nugget": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "worm": { elem2: "crushed_worm", chance:0.3},
        "cooked_meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "fish": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "rat": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "snail": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "frog": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "wheat_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "flower_seed": { elem2:null, chance:0.32, func:behaviors.FEEDPIXEL },
        "corn_seed": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "potato_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "grass_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "dead_bug": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "bee": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "ant": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "flea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "termite": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    },
    egg: "chicken_egg",
    foodNeed: 10,
    temp: 40,
    tempHigh: 75,
    stateHigh: "cooked_chicken",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "raw_chicken",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 1117,
    conduct: 0.3,
    cutInto: "raw_chicken",
};

elements.chicken_egg = {
    color: ["#e0d3ab","#d9cdb5"],
    behavior: behaviors.STURDYPOWDER2,
    tick: function(pixel) {
        if (Math.random() < 0.1 && pixel.temp > 20 && pixel.temp < 35) {
            changePixel(pixel,"chick")
        }
    doDefaults(pixel);
    },
    category: "food",
    state: "solid",
    temp: 20,
    tempLow: -18,
    stateLow: "frozen_chicken_egg",
    breakInto: ["yolk"],
    tempHigh: 400,
    stateHigh: ["calcium", "ash"],
    burn:50,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    reactions: {
        "water": { elem2:null, elem1:"hard_boiled_egg", chance:10, tempMin:80 }
    }
};
elements.water.reactions.egg = { elem1:null, elem2:"hard_boiled_egg", chance:10, tempMin:80 }
elements.frozen_chicken_egg = {
    color: ["#e0d3cf","#d9cdd3"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    temp: -20,
    tempHigh: 10,
    stateHigh: "chicken_egg",
    breakInto: ["calcium", "hard_yolk"],
    burn:50,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    hidden: true,
};

elements.hard_boiled_egg = {
	color: ["#e0d3ab","#d9cdb5","#e4d4b4","#f3f3ef"],
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
	hidden: "TRUE",
    tempHigh: 1000,
    stateHigh: ["ash", "smoke"],
    density: 820.33,
    isFood: true,
    hidden: true,
};

elements.chick = {
    color: ["#ffdf85", "#ffef5c"],
    behavior: [
        "M2%1|M2%2|M2%1",
        "M2%10|FX%5 AND CH:chicken%0.1|M2%10",
        "XX|M1%33|XX",
    ],
    category: "life",
    state: "solid",
    egg: "chicken_egg",
    foodNeed: 20,
    temp: 40,
    tempHigh: 75,
    stateHigh: "cooked_meat",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "blood",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    reactions: {
        "crushed_worm": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL},
        "meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "chicken_nugget": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "worm": { elem2: "crushed_worm", chance:0.3},
        "cooked_meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "fish": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "rat": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "snail": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "frog": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "wheat_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "flower_seed": { elem2:null, chance:0.32, func:behaviors.FEEDPIXEL },
        "corn_seed": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "potato_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "grass_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "dead_bug": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "bee": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "ant": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "flea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "termite": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    }
};

elements.barbecued_chicken = {
    color:["#bf743b", "#b57026","#8f5e29","#a87b11"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.barbecue_sauce = {
    color: "#571e1A",
    behavior: behaviors.LIQUID,
    viscosity: 50000,
    tempHigh: 260,
    stateHigh: ["carbon_dioxide","methane","steam","salt","sugar"],
    category:"food",
    state: "liquid",
    density: 1235,
    stain: 0.05,
    isFood: true,
}
if (!elements.ketchup.reactions) { elements.ketchup.reactions = {}; }
elements.ketchup.reactions.molasses = { elem1:"barbecue_sauce", elem2:"barbecue_sauce" }

elements.mustard = {
    color: "#e1ad01",
    behavior: behaviors.LIQUID,
    viscosity: 50000,
    tempHigh: 260,
    stateHigh: ["carbon_dioxide","methane","steam","sugar"],
    category:"food",
    state: "liquid",
    density: 1235,
    stain: 0.05,
    isFood: true
}

elements.soup = {
    color: "#fbd189",
    behavior: behaviors.LIQUID,
    tempHigh: 130,
    stateHigh: ["steam","steam","steam","fragrance"],
    tempLow: 0,
    category: "food",
    state: "liquid",
    density: 1052,
    conduct: 0.03,
    stain: -0.01,
    isFood: true,
    //thanks to nouser
    onMix: function(soup,ingredient) {
        if (elements[ingredient.element].id !== elements.soup.id && elements[ingredient.element].id !== elements.broth.id && ingredient.temp > 40) {
            if (elements[ingredient.element].isFood || elements[ingredient.element].category === "food" || elements[ingredient.element].category === "liquids") {
                var rgb1 = soup.color.match(/\d+/g);
                var rgb2 = ingredient.color.match(/\d+/g);
                // average the colors
                var rgb = [
                    Math.round((parseInt(rgb1[0])+parseInt(rgb2[0]))/2),
                    Math.round((parseInt(rgb1[1])+parseInt(rgb2[1]))/2),
                    Math.round((parseInt(rgb1[2])+parseInt(rgb2[2]))/2)
                ];
				if (!soup.elemlist){
				    soup.elemlist = [];
				}
				    soup.decidedHigh = soup.elemlist[Math.floor(Math.random()*soup.elemlist.length)];
				    soup.elemlist.push(ingredient.element)
				    soup.stateHigh = soup.elemlist;
                changePixel(ingredient, "soup");
                var hex = RGBToHex(rgb);
                soup.color = pixelColorPick(soup, hex);
                if (Math.random() < 0.5) { deletePixel(ingredient.x, ingredient.y); }
                else {
                    ingredient.color = pixelColorPick(ingredient, hex);
                    if (!ingredient.elemlist){
                        ingredient.elemlist = [];
                    }
                    ingredient.elemlist.push(soup.elemlist[Math.floor(Math.random() * soup.elemlist.length)])
                }
            }
		}
	},
    tick: function(pixel) {
		if (!pixel.decidedHigh){
			pixel.decidedHigh = "steam";
		}
		if (pixel.temp > 100){
			if (Math.random() < 0.5) {
				changePixel(pixel, "steam");
		    }
            else {
			    changePixel(pixel, pixel.decidedHigh)
		    }
		}
	},
    hoverStat: function(soup, ingredient) {
        if (findMostFrequent(soup.elemlist) == undefined) {
            return "Ingredients:None"
        } else {
            return "Ingredients:"+findMostFrequent(soup.elemlist)
        }
    },
}

if (!elements.broth.reactions) elements.broth.reactions = {};
elements.broth.reactions.water = { elem1: "soup", elem2: "soup", tempMin: 70 }

elements.noodles = {
    desc: "whatever noodles",
    color: ["#F3BA4F", "#F7D161"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    temp: 30,
    breakInto: ["crumb"],
    tempHigh: 130,
    stateHigh: ["toast"],
    burn:50,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    hidden: true,
};

if (!elements.batter.reactions) elements.batter.reactions = {};
elements.batter.reactions.water = {elem1: "noodles", tempMin: 70}

elements.battered_raw_chicken = {
    color: ["#eacfa9", "#ecd2af"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:25,
    tempHigh: 125,
    stateHigh: "cooked_chicken",
    reactions: {
        "crumb": { elem1: "raw_chicken_nugget", elem2: null },
    },
    hidden: true,
};

elements.steamed_chicken = {
    color:["#cfba8f", "#d2b788"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:50,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}

elements.smoked_chicken = {
    color:["#AF4523", "#AC481F"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}

elements.crushed_worm = {
    color: ["#e56932", "#c0714e"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 20,
    tempHigh: 50,
    stateHigh: ["ash", "smoke"],
    tempLow: -4,
    stateLow: "frozen_crushed_worm",
    density: 200.33,
    isFood: true,
    hidden: true,
};

elements.worm.reactions.rock = { elem1: "crushed_worm" }
elements.worm.breakInto = "crushed_worm"

elements.frozen_crushed_worm = {
    color: ["#2fcbae", "#3edabd", "#b2d5d9"],  
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: -4,
    tempHigh: 20,
    stateHigh: "crushed_worm",
    density: 200.33,
    isFood: false,
    hidden: true,
};

elements.cooked_chicken = {
    color: ["#c17c20", "#ebad2b", "#f7b846"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
};

elements.raw_chicken = {
    color: ["#dfc8bd", "#e2cdc0", "#b9a195"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "cooked_chicken",
    temp:25,
    tempHigh: 600,
    stateHigh: ["cooked_chicken"],
    reactions: {
        "batter": { elem1: "battered_raw_chicken", elem2: null },
        "smoke": {elem1: "smoked_chicken"},
        "steam": {elem1: "steamed_chicken"},
        "water": {elem1: "boiled_chicken", tempMin: 70},
        "nut_oil": {elem1: "fried_chicken", tempMin: 70},
        "charcoal": {elem1: "barbecued_chicken", tempMin: 70},
        "fire": {elem1: "barbecued_chicken"}
    }
};

elements.boiled_chicken = {
    color: ["#F9CC84", "#EDCE89", "#F8CB78"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 65,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
}

elements.fried_chicken = {
    color: ["#E87D1A", "#E77106", "#E77106"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 90,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
}

elements.raw_chicken_nugget = {
    color: ["#d6bc7e", "#d2b47a", "#c7a969"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "chicken_nugget",
    temp:25,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
    reactions: {
        "nut_oil": {elem1: "chicken_nugget", tempMin: 70}
    }
};

elements.chicken_nugget = {
    color: ["#D77105", "#D77105", "#EB8C2C", "#EB8C2C"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    tempLow: -20,
    stateLow: "frozen_chicken_nugget",
    isFood: true,
    density: 100,
    hidden: true,
};

elements.frozen_chicken_nugget = {
    color: ["#45a69c", "#73d9cd", "#3f9f95", "#389d8e"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: -20,
    tempHigh: 40,
    stateHigh: "chicken_nugget",
    isFood: false,
    density: 100,
    hidden: true,
};

elements.olive_wood = {
    color: "#632e1f",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
}
elements.olive_branch = {
    color: "#632e1f",
    behavior: [
        "CR:olive_leaves,olive_branch%2|CR:olive_leaves,olive_leaves,olive_leaves,olive_branch%2|CR:olive_leaves,olive_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "olive_wood",
    tempLow: -30,
    stateLow: "olive_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
    hidden: true,
}
elements.olive_leaves = {
    color: ["#407603","#376502","#2e5502"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:olive%0.15|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035}
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    seed: "olive_seed",
    hidden: true
}
elements.olive = {
    color: ["#6e8b3d","#7c9d45"],
    behavior: behaviors.POWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "rock": { elem1:"nut_oil", elem2:"rock", chance:0.035, color1: "#ffc844" },
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "nut_oil",
    breakIntoColor: "#ffc844",
    density: 1050,
    isFood: false
}

elements.olive_seed = {
    color: "#854610",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "olive_wood" : "olive_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"olive_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};
/*
elements.cooking_oil = {
    color: "#ffc844",
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 400,
    stateHigh: "fire",
    burn: 70,
    burnTime: 300,
    burnInto: ["carbon_dioxide","fire"],
    viscosity: 250,
    state: "liquid",
    density: 825,
    temp: 30,
    reactions: {
        "peeled_potato": {elem2: "fried_potato", tempMin: 70}
    }
},
*/
elements.pepper = {
    color: ["#1f190a", "#2b200d", "#362712", "#3b2211"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

elements.potato.cutInto = ["peeled_potato","peeled_potato","peeled_potato","potato_skin"]//{elem1: ["potato_skin","peeled_potato"] }

elements.potato_skin = {
    color: ["#DC8A5A", "#A86C36", "#DC9A59", "#A76B35"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    density: 1100,
    tempHigh: 250,
    stateHigh: ["ash", "smoke"],
}

elements.peeled_potato = {
    color: ["#D6C39F", "#D1C09D", "#D1C09D", "#CDBF9E"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 20,
    hidden: true,
    breakInto: "mashed_potato",
    tempHigh: 176,
    stateHigh: "baked_potato",
    density: 1100,
    reactions: {
        "nut_oil": { elem1: "fried_potato", tempMin: 70 }
    }
}

elements.fried_potato = {
    color: ["#DD7908", "#D57206", "#CA6801", "#D68001"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 35,
    hidden: true,
    tempHigh: 600,
    density: 1110,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.applewood = {
    color: "#632e1f",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.apple_branch = {
    color: "#632e1f",
    behavior: [
        "CR:apple_leaves,apple_branch%2|CR:apple_leaves,apple_branch%2|CR:apple_leaves,apple_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "applewood",
    tempLow: -30,
    stateLow: "applewood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
}
elements.apple_leaves = {
    color: ["#00d404","#0ec911","#109e12"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:apple%0.15|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.apple = {
    color: ["#eb1a1a","#f22c2c","#d62020"],
    behavior: behaviors.POWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "apple_juice",
    cutInto: "apple_slice",
    state: "solid",
    density: 1050,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#cfc540",
}

elements.apple_slice = {
    color: "#f0af37",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "apple_juice",
    state: "solid",
    density: 1050,
    hidden: true,
}

elements.apple_seed = {
    color: "#854610",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "applewood" : "apple_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"applewood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};

elements.apple_juice = {
    color: "#ffde55",
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#ffde55")
            }
        }
    },
    reactions: {
        "sugar": { elem1:"apple_jam", elem2:null, chance:0.35 },
        "yeast": { elem1:"apple_cider_vinegar", elem2:null, chance:0.35 }
    },
    tempLow: 0
};
eLists.JUICEMIXABLE.push("apple_juice");

elements.apple_jam = {
    color: "#ebc034",
    behavior: behaviors.LIQUID,
    category: "food",
    tempHigh: 400,
    stateHigh: ["sugar","smoke"],
    burn: 70,
    burnTime: 300,
    viscosity: 750,
    state: "liquid",
    density: 825,
    hidden: true
};

elements.cake = {
    color: ["#f2e5bf","#e8daba"],
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 550,
    stateHigh: "ash",
    category: "food",
    burn: 10,
    burnTime: 400,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    state: "solid",
    density: 233.96,
    hidden: true,
    isFood: true
};

elements.icing_sugar = {
    color: "#f8f8f1",
    behavior: behaviors.POWDER,
    onMix: function(icing_sugar1, icing_sugar2) {
        if (shiftDown && Math.random() < 0.2) {
            changePixel(icing_sugar1,"icing")
        }
    },
    tempHigh: 186,
    stateHigh: "caramel",
    viscosity: 1.5,
    category: "food",
    state: "solid",
    density: 1036.86,
    isFood: true
};

elements.icing = {
    color: "#fefefb",
    behavior: behaviors.LIQUID,
    onMix: function(icing_sugar1, icing_sugar2) {
        if ((shiftDown && Math.random() < 0.2) || (elements[icing_sugar2.element].id === elements.icing_sugar.id && Math.random() < 0.25)) {
            changePixel(icing_sugar1,"icing")
        }
    },
    tempHigh: 45,
    stateHigh: ["dry_icing"],
    stateLowColorMultiplier: 0.97,
    category: "food",
    isFood: true,
    state: "solid",
    density: 959.97,
    viscosity: 9000,
    hidden: true
};

elements.dry_icing = {
    color: "#fffefa",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 1000,
    stateHigh: ["smoke","smoke","smoke","steam","steam","calcium"],
    stateLowColorMultiplier: 0.97,
    category: "food",
    isFood: true,
    state: "solid",
    density: 959.97,
    viscosity: 9000,
    hidden: true
};

elements.cream.reactions.baked_batter = {elem2: "cake" }

elements.sugar.breakInto = {elem1: "icing_sugar"}

elements.boiler = {
	color: "#73fff8",
	behavior: behaviors.WALL,
	tick: function(pixel) {
		for (var i = 0; i < squareCoords.length; i++) {
                var coord = squareCoords[i];
                var x = pixel.x+coord[0];
                var y = pixel.y+coord[1];
                if (!isEmpty(x,y, true)) {
					if(pixelMap[x][y].temp < -230) {
                    pixelMap[x][y].temp = (pixelMap[x][y].temp + 7)
					} else if(pixelMap[x][y].temp > 270) {
						pixelMap[x][y].temp = (pixelMap[x][y].temp - 7)
					} else if (pixelMap[x][y].temp < 95) {
						pixelMap[x][y].temp = (pixelMap[x][y].temp + 2)
					} else if (pixelMap[x][y].temp > 95) {
						pixelMap[x][y].temp = (pixelMap[x][y].temp - 2)
					}
                }
            }
	},
	category:"machines",
	state:"solid",
	insulate: true,
	noMix: true,
	movable: false,
    temp: 110
};

elements.steamer = {
	color: "#45daff",
	behavior: [
        "CR:steam%90|CR:steam%90|CR:steam%90",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
	category:"machines",
	state:"solid",
	insulate: true,
	noMix: true,
	movable: false,
    temp: 110
};

elements.smoker = {
	color: "#bfa797",
	behavior: [
        "CR:smoke%90|CR:smoke%90|CR:smoke%90",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
	category:"machines",
	state:"solid",
	insulate: true,
	noMix: true,
	movable: false,
    temp: 110
};

elements.orange_wood = {
    color: "#a88c4a",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.orange_branch = {
    color: "#a88c4a",
    behavior: [
        "CR:orange_leaves,orange_branch%2|CR:orange_leaves,orange_branch%2|CR:orange_leaves,orange_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "orange_wood",
    tempLow: -30,
    stateLow: "orange_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
}
elements.orange_leaves = {
    color: ["#61c43d","#5ddb3d","#51d44c"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:orange%0.1|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.orange = {
    color: ["#eda137","#e39230","#d1882e"],
    behavior: behaviors.POWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "orange_juice",
    cutInto: ["orange_slice","orange_slice","orange_slice","orange_slice","orange_peels"],
    state: "solid",
    density: 1050,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#cf9f40",
}

elements.orange_slice = {
    color: "#f5b133",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "orange_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    reactions: {
        "sugar": { elem1:"marmalade", elem2:null, chance:0.35 }
    },
}

elements.orange_seed = {
    color: "#695531",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "orange_wood" : "orange_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"orange_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};

elements.orange_juice = {
    color: "#ffb326",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#ffde55")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0
};
eLists.JUICEMIXABLE.push("orange_juice");

elements.orange_peels = {
    color: "#d69c31",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "orange_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    reactions: {
        "sugar": { elem1:"marmalade", elem2:null, chance:0.35 }
    },
}

elements.marmalade = {
    color: "#fc9a38",
    behavior: behaviors.LIQUID,
    category: "food",
    tempHigh: 400,
    stateHigh: ["sugar","smoke"],
    burn: 70,
    burnTime: 300,
    viscosity: 750,
    state: "liquid",
    density: 825,
    hidden: true
};

elements.tuna = {
    color: ["#3D74BA", "#4A6FB1", "#4A6FB1"],
    behavior: [
        "XX|M2%5|SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14",
        "XX|FX%0.5|BO",
        "M2|M1|M2 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%5",
    ],
    category: "life",
    state: "solid",
    cutInto: "raw_tuna",
    conduct: 0.2,
    eggColor: ["#211316","#2C1A1D","#503734"],
    breakInto: "blood",
    burn:20,
    burnTime:200,
    temp: 20,
    tempHigh: 120,
    stateHigh: "cooked_tuna",
    tempLow: -20,
    stateLow: "frozen_fish",
    reactions: {
        "algae": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "plant": { elem2:null, chance:0.125, func:behaviors.FEEDPIXEL },
        "fly": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "firefly": { elem2:null, chance:0.6, func:behaviors.FEEDPIXEL },
        "worm": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "tadpole": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.5 },
        "dead_bug": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "broth": { elem2:"water", chance:0.2, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "herb": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "lettuce": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "dead_plant": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "yeast": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "yogurt": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "tea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "rotten_meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "cooked_meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "yolk": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "cell": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
    },
}

elements.salmon = {
    color: ["#C0C3CF", "#B7BAC3", "#ADB0B8"],
    behavior: [
        "XX|M2%5|SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14",
        "XX|FX%0.5|BO",
        "M2|M1|M2 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%5",
    ],
    category: "life",
    state: "solid",
    conduct: 0.2,
    eggColor: ["#e8961c","#faa82d"],
    breakInto: "blood",
    burn:20,
    burnTime:200,
    temp: 20,
    tempHigh: 120,
    stateHigh: "cooked_salmon",
    tempLow: -20,
    stateLow: "frozen_fish",
    reactions: {
        "algae": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "plant": { elem2:null, chance:0.125, func:behaviors.FEEDPIXEL },
        "fly": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "firefly": { elem2:null, chance:0.6, func:behaviors.FEEDPIXEL },
        "worm": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "tadpole": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.5 },
        "dead_bug": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "broth": { elem2:"water", chance:0.2, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "herb": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "lettuce": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "dead_plant": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "yeast": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "yogurt": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "tea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "rotten_meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "cooked_meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "yolk": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "cell": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
    },
    cutInto: "raw_salmon"
}

elements.raw_salmon = {
    color: ["#FD7E19", "#FE842F", "#FD8F45"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "cooked_salmon",
    temp:25,
    tempHigh: 80,
    stateHigh: "cooked_salmon",
    isFood: true,
    reactions: {
        "smoke": {elem1: "smoked_salmon"},
        "steam": {elem1: "steamed_salmon"},
        "water": {elem1: "boiled_salmon", tempMin: 70},
        "nut_oil": {elem1: "fried_salmon", tempMin: 70}
    }
}

elements.cooked_salmon = {
    color: ["#CB6132", "#D05D18", "#CC5926"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:25,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    isFood: true,
    hidden: true,
}

elements.smoked_salmon = {
    color: ["#B64431", "#B24932"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
    isFood: true,
}

elements.steamed_salmon = {
    color: ["#BB7B4B", "#B07B54"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:60,
    tempHigh: 600,
    hidden: true,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.boiled_salmon = {
    color: ["#F9B080", "#FFB78D"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:70,
    tempHigh: 600,
    hidden: true,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.fried_salmon = {
    color: ["#E06643", "#ED774B"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:70,
    tempHigh: 600,
    hidden: true,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.raw_tuna = {
    color: ["#EF4A5C", "#F74F65", "#E83A53"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:25,
    burnInto: "cooked_tuna",
    tempHigh: 80,
    stateHigh: "cooked_tuna",
    isFood: true,
    reactions: {
        "smoke": {elem1: "smoked_tuna"},
        "steam": {elem1: "steamed_tuna"},
        "water": {elem1: "boiled_tuna", tempMin: 70},
        "nut_oil": {elem1: "fried_tuna", tempMin: 70}
    }
}

elements.cooked_tuna = {
    color: ["#B76C71", "#C2787C", "#A86265"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    hidden: true,
    temp:50,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.smoked_tuna = {
    color: ["#9D5C24", "#A4632A"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    hidden: true,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.steamed_tuna = {
    color: ["#CFA578", "#D4AC82"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:60,
    tempHigh: 600,
    hidden: true,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.boiled_tuna = {
    color: ["#C79F65", "#D9B075"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    hidden: true,
    temp:70,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.fried_tuna = {
    color: ["#BF8251", "#9F6031"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    hidden: true,
    temp:70,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    isFood: true,
}

elements.watermelon_seed = {
    color: "#2b2118",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x+1,pixel.y) && Math.random() > 0.7) {
                    movePixel(pixel,pixel.x+1,pixel.y);
                    createPixel(Math.random() > 0.5 ? "watermelon_stem" : "watermelon_stem",pixel.x-1,pixel.y);
                }
                if (isEmpty(pixel.x-1,pixel.y) && Math.random() > 0.7) {
                    movePixel(pixel,pixel.x-1,pixel.y);
                    createPixel(Math.random() > 0.5 ? "watermelon_stem" : "watermelon_stem",pixel.x+1,pixel.y);
                }
                if (!isEmpty(pixel.x+1,pixel.y) && !isEmpty(pixel.x-1,pixel.y) &&isEmpty(pixel.x+1,pixel.y-1) && Math.random() > 0.7) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "watermelon_stem" : "watermelon_stem",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x-1,pixel.y) && !isEmpty(pixel.x+1,pixel.y) &&isEmpty(pixel.x-1,pixel.y-1) && Math.random() > 0.7) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "watermelon_stem" : "watermelon_stem",pixel.x+1,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"watermelon_stem");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%20|XX",
        "XX|M1|XX",
    ],
};

elements.watermelon_stem = {
    color: "#6ec938",
    behavior: [
        "ST:watermelon_stem|ST:watermelon_stem AND CR:watermelon%0.1|ST:watermelon_stem",
        "ST:watermelon_stem|XX|ST:watermelon_stem",
        "XX|XX|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
};

elements.watermelon = {
    color: ["#28b02d","#36bf3a"],
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "watermelon_juice",
    cutInto: "watermelon_flesh",
    state: "solid",
    density: 1050,
}

elements.watermelon_flesh = {
    color: "#f53527",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "watermelon_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#c43f33",
}

elements.watermelon_juice = {
    color: "#eb4034",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#eb4034")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0
};
eLists.JUICEMIXABLE.push("watermelon_juice");

elements.grape.breakInto = "grape_juice",

elements.grape_juice = {
    color: "#291824",
    behavior: behaviors.LIQUID,
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel, "#291824")
            }
        }
    },
    reactions: {
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "seltzer": { elem1: "soda", elem2: "foam" },
        "carbon_dioxide": { elem1: "soda", elem2: "foam" },
        "milk": { elem1: "fruit_milk", elem2: "fruit_milk" },
        "alcohol": { elem1: "wine", elem2: "wine" },
        "yeast": { elem1: ["wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","wine","cream_of_tartar"], elem2: null, chance:80 },
    },
    tempHigh: 160,
    stateHigh: ["steam","sugar"],
    tempLow: -10,
    stateLowColorMultiplier: 1.1,
    category: "liquids",
    state: "liquid",
    density: 1054,
    hidden: true,
    isFood: true
};
eLists.JUICEMIXABLE.push("grape_juice");

elements.cream_of_tartar = {
    color: ["#EFEFEF", "#EBEBEB", "#D8D8D6"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    density: 1500,
    isFood: true,
    hidden: true,
    reactions: {
        "sugar_water": {elem2: "corn_syrup", elem1: null, tempMin: 80},
        "carbonic_acid": {elem1: null, elem2: "carbon_dioxide"}
    }
}

elements.corn_syrup = {
    color: ["#FFCD0C", "#E47F00", "#FEB003"],
    behavior: behaviors.LIQUID,
    category: "food",
    state: "liquid",
    tempHigh: 100,
    stateHigh: "caramel",
    isFood: true,
    hidden: true,
    viscosity: 10000
}

if (!elements.baking_soda.reactions) elements.baking_soda.reactions = {};
elements.baking_soda.reactions.water = { elem1: "carbonic_acid", elem2: "carbonic_acid" }

elements.carbonic_acid = {
    color: ["#E0DEA5", "#DFDB9C", "#EBE8BC"],
    behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
    hidden: true,
}

elements.wine = {
    color: ["#6F0013", "#6D0112"],
    behavior: behaviors.LIQUID,
    category: "liquids",
    state: "liquid",
    /*onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel, "#6D0112")
            }
        }
    },*/
    tempHigh: 100,
    stateHigh: "steam",
    isFood: true,
    density: 1000,
    hidden: true,
    tempLow: 0
}
//eLists.JUICEMIXABLE.push("wine");

elements.shrimp = {
    color: ["#EE5422", "#E9683C", "#F3583F", "#EDA270"],
    behavior: [
        "SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14|M2%7.5|SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14",
        "SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14|FX%20|SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14",
        "M2 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14|M1|M2 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%14",
    ],
    category: "life",
    state: "solid",
    cutInto: "raw_shrimp",
    conduct: 0.2,
    breakInto: "raw_shrimp",
    burn:20,
    burnTime:200,
    temp: 20,
    tempHigh: 120,
    stateHigh: "cooked_shrimp",
    tempLow: -20,
    stateLow: "frozen_meat",
    reactions: {
        "algae": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "plant": { elem2:null, chance:0.125, func:behaviors.FEEDPIXEL },
        "fly": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "firefly": { elem2:null, chance:0.6, func:behaviors.FEEDPIXEL },
        "worm": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "tadpole": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.5 },
        "dead_bug": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "broth": { elem2:"water", chance:0.2, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "herb": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "lettuce": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "dead_plant": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "yeast": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "yogurt": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "tea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "rotten_meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "cooked_meat": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "yolk": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "cell": { elem2:null, chance:0.15, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
    },
}


elements.coconut_seed = {
    color: "#7a603d",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1) && pixel.height < 7) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "coconut_stem" : "coconut_stem",pixel.x,pixel.y+1);
                    
                    pixel.height++
                }
            }
            else if (pixel.age > 150 && pixel.height > 6 && Math.random() < 0.1) {
                changePixel(pixel,"coconut_tree_top");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "height": 0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};

elements.coconut_stem = {
    color: "#8f6c3f",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.coconut_tree_top = {
    color: "#8f6c3f",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    properties:{
        "leftleaves": 0,
        "rightleaves": 0,
    },
    hidden: true,
    tick: function(pixel) {
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 0) {
            if (isEmpty(pixel.x+1,pixel.y)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x+1,pixel.y);

                pixel.rightleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 1) {
            if (isEmpty(pixel.x+2,pixel.y)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x+2,pixel.y);

                pixel.rightleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 2) {
            if (isEmpty(pixel.x+3,pixel.y)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x+3,pixel.y);

                pixel.rightleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 3) {
            if (isEmpty(pixel.x+4,pixel.y+1)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x+4,pixel.y+1);

                pixel.rightleaves++
            }
        }


        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 0) {
            if (isEmpty(pixel.x-1,pixel.y)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x-1,pixel.y);

                pixel.leftleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 1) {
            if (isEmpty(pixel.x-2,pixel.y)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x-2,pixel.y);

                pixel.leftleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 2) {
            if (isEmpty(pixel.x-3,pixel.y)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x-3,pixel.y);

                pixel.leftleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 3) {
            if (isEmpty(pixel.x-4,pixel.y+1)) {
                createPixel(Math.random() > 0.5 ? "coconut_leaves" : "coconut_leaves",pixel.x-4,pixel.y+1);

                pixel.leftleaves++
            }
        }


        if (Math.random() < 0.1 && pixel.age > 70 && pixel.temp < 100 && pixel.leftleaves > 0 && pixel.rightleaves > 0) {
            if (isEmpty(pixel.x+1,pixel.y+1)) {
                createPixel(Math.random() > 0.5 ? "coconut" : "coconut",pixel.x+1,pixel.y+1);
            }
        }
        if (Math.random() < 0.1 && pixel.age > 70 && pixel.temp < 100 && pixel.leftleaves > 0 && pixel.rightleaves > 0) {
            if (isEmpty(pixel.x-1,pixel.y+1)) {
                createPixel(Math.random() > 0.5 ? "coconut" : "coconut",pixel.x-1,pixel.y+1);
            }
        }
        pixel.age++;
    doDefaults(pixel);
},
}
elements.coconut_leaves = {
    color: ["#569923","#5ea12b"],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.coconut = {
    color: "#6e4621",
    behavior: [
        "ST:coconut_tree_top|ST:coconut_leaves|ST:coconut_tree_top",
        "ST:coconut_stem|XX|ST:coconut_stem",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "coconut_milk",
    cutInto: ["cut_coconut"],
    state: "solid",
    density: 1050,
}

elements.coconut_milk = {
    color: "#fffcf2",
    behavior: behaviors.LIQUID,
    reactions: {
        "melted_chocolate": { elem1:"chocolate_milk", elem2:null },
        "chocolate": { elem1:"chocolate_milk", elem2:"melted_chocolate", chance:0.05 },
        "juice": { elem1:"fruit_milk", elem2:null, chance:0.05 },
        "soda": { elem1:"pilk", elem2:null, chance:0.1 },
        "yolk": { elem1:"eggnog", elem2:null, chance:0.1 },
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "caramel": { color1:"#C8B39A", elem2:null, chance:0.05 },
        "sugar": { elem2:null, chance:0.005},
    },
    tempLow: 0,
    stateLow: "ice_cream",
    stateLowColorMultiplier: [0.97,0.93,0.87],
    tempHigh: 93,
    stateHigh: "yogurt",
    viscosity: 1.5,
    category: "liquids",
    state: "liquid",
    density: 825,
    isFood: true
}

elements.tea.reactions.coconut_milk = { elem2:null, color1:"#ad8955", chance:0.005}
elements.coffee.reactions.coconut_milk = { elem2:"foam", color1:"#856545", chance:0.005}

elements.cut_coconut = {
    color: "#fff2cf",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "coconut_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#ede9b9",
}

elements.coconut_juice = {
    color: "#e9ebe4",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#e9ebe4")
            }
        }
    },
    behavior: behaviors.LIQUID,
    reactions: {
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "caramel": { color1:"#C8B39A", elem2:null, chance:0.05 },
    },
    tempLow: 0,
    tempHigh: 93,
    stateHigh: ["sugar","steam"],
    viscosity: 1.5,
    category: "liquids",
    state: "liquid",
    density: 1036.86,
    hidden: true,
    isFood: true
}
eLists.JUICEMIXABLE.push("coconut_juice");

elements.lemon_wood = {
    color: "#786531",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
}
elements.lemon_branch = {
    color: "#786531",
    behavior: [
        "CR:lemon_leaves,lemon_branch%2|CR:lemon_leaves,lemon_leaves,lemon_leaves,lemon_branch%2|CR:lemon_leaves,lemon_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "lemon_wood",
    tempLow: -30,
    stateLow: "lemon_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
    hidden: true,
}
elements.lemon_leaves = {
    color: ["#42b336","#46a83b"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:lemon%0.15|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035}
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    seed: "lemon_seed",
    hidden: true
}
elements.lemon = {
    color: ["#dbd937","#e0dd28"],
    behavior: behaviors.POWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "sugar": { elem1:"marmalade", elem2:null, color1:"#e0bf2b", chance:0.35 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "lemon_juice",
    state: "solid",
    density: 1050,
    isFood: true,
    cutInto: ["lemon_zest","lemon_slice","lemon_slice","lemon_slice","lemon_slice"],
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#b8af4b",
}

elements.lemon_juice = {
    color: "#e0d358",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#e0d358")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    hidden: true,
    tempLow: 0,
    reactions: {
        "sugar": {elem1:"lemonade", elem2: "null", chance:0.35}
    }
};
eLists.JUICEMIXABLE.push("lemon_juice");

elements.lemonade = {
    color: "#fff378",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#fff378")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    hidden: true,
    tempLow: 0
};

eLists.JUICEMIXABLE.push("lemonade");

elements.lemon_zest = {
    color: "#dbc535",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
    reactions: {
        "sugar": { elem1:"marmalade", elem2:null, color1:"#e0bf2b", chance:0.35 }
    },
}

elements.lemon_slice = {
    color: "#ebe431",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "lemon_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    reactions: {
        "sugar": { elem1:"marmalade", elem2:null, color1:"#e0bf2b", chance:0.35 }
    },
}

elements.lemon_seed = {
    color: "#854610",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "lemon_wood" : "lemon_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"lemon_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};


elements.carrot_seed = {
    color: "#b08d35",
    tick: function (pixel) {
        if (isEmpty(pixel.x, pixel.y + 1)) {
            movePixel(pixel, pixel.x, pixel.y + 1);
        }
        else {
            if (Math.random() < 0.1 && pixel.age > 100 && pixel.temp < 100 && pixel.leafgrown == true && pixel.growthpixel == 0) {
                if (!outOfBounds(pixel.x, pixel.y + 1)) {
                    var randomNumber1 = Math.round(Math.random());
                    pixel.growthpixel = pixel.growthpixel + randomNumber1;
                    var dirtPixel = pixelMap[pixel.x][pixel.y + 1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        deletePixel(pixel.x, pixel.y + 1);
                        movePixel(pixel, pixel.x, pixel.y + 1);
                        createPixel("carrot_leaves", pixel.x, pixel.y - 1);
                        pixel.growthpixel++;
                    }
                }
            }
            if (Math.random() < 0.1 && pixel.age > 100 && pixel.temp < 100 && pixel.leafgrown == true && pixel.growthpixel > 0 && pixel.growthpixel < 4) {
                if (!outOfBounds(pixel.x, pixel.y + 1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y + 1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        deletePixel(pixel.x, pixel.y + 1);
                        movePixel(pixel, pixel.x, pixel.y + 1);
                        createPixel("carrot", pixel.x, pixel.y - 1);
                        pixel.growthpixel++;
                    }
                }
            }
            if (!isEmpty(pixel.x, pixel.y + 1) && Math.random() > 0.95 && isEmpty(pixel.x - 1, pixel.y - 1) && isEmpty(pixel.x + 1, pixel.y - 1) && pixel.leafgrown == false) {
                var dirtPixel = pixelMap[pixel.x][pixel.y + 1];
                if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                    createPixel("carrot_leaves", pixel.x - 1, pixel.y - 1);
                    createPixel("carrot_leaves", pixel.x + 1, pixel.y - 1);
                    pixel.leafgrown = true;
                }
            }
            else if (pixel.age > 150 && pixel.growthpixel == 4 && Math.random() < 0.1) {
                changePixel(pixel, "carrot");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age": 0,
        "growthpixel": 0,
        "leafgrown": false
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};

elements.carrot_leaves = {
    color: ["#61cc3d","#58c234"],
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035}
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    seed: "carrot_seed",
    hidden: true
}
elements.carrot = {
    color: "#e39919",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "carrot_juice",
    state: "solid",
    density: 1050,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#ba8125",
}

elements.carrot_juice = {
    color: "#f5a742",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#f5a742")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    tempLow: 0,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
};
eLists.JUICEMIXABLE.push("carrot_juice");

elements.apple_cider_vinegar = {
    color: "#fffe75",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#fffe75")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0
};
eLists.JUICEMIXABLE.push("apple_cider_vinegar");

elements.turnip_seed = {
    color: "#994828",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 100 && pixel.temp < 100 && pixel.leafgrown == true && pixel.growthpixel == 0) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        deletePixel(pixel.x,pixel.y+1);
                        movePixel(pixel,pixel.x,pixel.y+1);
                        createPixel("turnip_leaves",pixel.x,pixel.y-1);
                        pixel.growthpixel++;
                    }
                }
                
            }
            if (pixel.age > 100 && pixel.temp < 100 && pixel.leafgrown == true && pixel.growthpixel > 0 && pixel.growthpixel < 3) {
                if (!outOfBounds(pixel.x-1,pixel.y)) {
                    var pixelleft = pixelMap[pixel.x-1][pixel.y];
                    if (pixelleft.element === "dirt" || pixelleft.element === "mud" || pixelleft.element === "sand" || pixelleft.element === "wet_sand" || pixelleft.element === "clay_soil" || pixelleft.element === "mycelium") {
                        deletePixel(pixel.x-1,pixel.y);
                        createPixel("turnip",pixel.x-1,pixel.y);
                    }
                }
                if (!outOfBounds(pixel.x+1,pixel.y)) {
                    var pixelright = pixelMap[pixel.x+1][pixel.y];
                    if (pixelright.element === "dirt" || pixelright.element === "mud" || pixelright.element === "sand" || pixelright.element === "wet_sand" || pixelright.element === "clay_soil" || pixelright.element === "mycelium") {
                        deletePixel(pixel.x+1,pixel.y);
                        createPixel("turnip",pixel.x+1,pixel.y);
                    }
                }
            }
            if (Math.random() < 0.1 && pixel.age > 100 && pixel.temp < 100 && pixel.leafgrown == true && pixel.growthpixel > 0 && pixel.growthpixel < 3) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        deletePixel(pixel.x,pixel.y+1);
                        movePixel(pixel,pixel.x,pixel.y+1);
                        createPixel("turnip",pixel.x,pixel.y-1);
                        pixel.growthpixel++;
                    }
                }
                
            }
            if (!isEmpty(pixel.x,pixel.y+1) && Math.random() > 0.95 && isEmpty(pixel.x-1,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1) && pixel.leafgrown == false) {
                var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                    createPixel("turnip_leaves",pixel.x-1,pixel.y-1);
                    createPixel("turnip_leaves",pixel.x+1,pixel.y-1);
                    pixel.leafgrown++
                }
            }
            else if (pixel.age > 150 && pixel.growthpixel == 3 && Math.random() < 0.1) {
                changePixel(pixel,"turnip");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "growthpixel": 0,
        "leafgrown": false
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.turnip_leaves = {
    color: ["#399431","#3b8c34"],
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035}
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    seed: "turnip_seed",
    hidden: true
}
elements.turnip = {
    color: ["#945bb3","#a05cbd","#a053b8","#b364c4"],
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "turnip_juice",
    state: "solid",
    density: 1050,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#79097d",
}

elements.turnip_juice = {
    color: "#700f5d",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#700f5d")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    tempLow: 0,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
};
eLists.JUICEMIXABLE.push("turnip_juice");

elements.corn.breakInto ="corn_starch"

elements.corn_starch = {
    color: ["#fcf2e1","#f2e7d3","#fcf3de"],
    behavior: behaviors.POWDER,
    name: "starch",
    reactions: {
        "water": { elem1: "dough", elem2: null },
        "salt_water": { elem1: "dough", elem2: null },
        "sugar_water": { elem1: "dough", elem2: null },
        "seltzer": { elem1: "dough", elem2: null },
        "pool_water": { elem1: "dough", elem2: null },
        "juice": { elem1: "dough", elem2: null },
        "yolk": { elem1: "cracker_dough", elem2: null, color1:"#dbd19a" },
        "yogurt": { elem1: "cracker_dough", elem2: null, color1:"#dbd19a" },
        "broth": { elem1:"dough", elem2:null },
        "soda": { elem1:"dough", elem2:null },
        "tea": { elem1:"dough", elem2:null },
        "blood": { elem1:"dough", elem2:null },
        "infection": { elem1:"dough", elem2:null },
        "antibody": { elem1:"dough", elem2:null },
        "milk": { elem1:"dough", elem2:null },
        "cream": { elem1:"dough", elem2:null },
        "melted_butter": { elem1:"sauce", elem2:null, color1:"#DF8D32" },
    },
    category: "food",
    tempHigh: 400,
    stateHigh: "fire",
    burn:40,
    burnTime:25,
    state: "solid",
    density: 600,
    isFood: true,
    alias:"starch"
}

elements.baking_powder = {
	color: "#fffaf0",
	behavior: behaviors.POWDER,
	category: "food",
	state: "solid",
    burn: 40,
    tempHigh: 400,
    stateHigh: ["salt","carbon_dioxide"],
    burnTime: 25,
    density: 600,
    isFood: true,
	reactions: {
        "flour": { elem1: "pancake_mix", elem2: null, color1: "#e8b77b"},
    },
};

if (!elements.baking_soda.reactions) elements.baking_soda.reactions = {};
elements.baking_soda.reactions.neutral_acid = { elem1: "baking_powder", elem2: null }

elements.pancake_mix = {
    color: ["#f2e9c7","#f7ebbe"],
    behavior: behaviors.POWDER,
    reactions: {
        "water": { elem1: "pancake_batter", elem2: null },
    },
    category: "food",
    tempHigh: 400,
    stateHigh: "fire",
    burn:40,
    burnTime:25,
    state: "solid",
    density: 600,
    isFood: true
},

elements.pancake_batter = {
    color: "#e6da9e",
    behavior: behaviors.LIQUID,
    category: "food",
    tempHigh: 70,
    stateHigh: "pancake",
    stateHighColorMultiplier: 0.9,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "liquid",
    viscosity: 10000,
    density: 1001,
    hidden: true,
    isFood: true
}
elements.sap.tempHigh = 104,
elements.sap.stateHigh = ["maple_syrup","maple_syrup","maple_syrup","sap"],
elements.maple_syrup = {
    color: ["#fabb34","#facc34","#fabb34"],
    behavior: behaviors.LIQUID,
    tempHigh: 170,
    stateHigh: ["sugar","smoke","smoke"],
    tempLow: -15,
    category:"liquids",
    state: "liquid",
    viscosity: 15,
    hidden: true,
    density: 1400
}
elements.pancake = {
    color: "#e0d080",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 95,
    stateHigh: "crispy_pancake",
    category: "food",
    burn: 10,
    burnTime: 400,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    state: "solid",
    density: 233.96,
    hidden: true,
    isFood: true
}
elements.crispy_pancake = {
    color: "#c7a34a",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 150,
    stateHigh: "burnt_pancake",
    category: "food",
    burn: 10,
    burnTime: 400,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    state: "solid",
    density: 233.96,
    hidden: true,
    isFood: true
}
elements.burnt_pancake = {
    color: "#332709",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 550,
    stateHigh: "ash",
    category: "food",
    burn: 10,
    burnTime: 400,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    state: "solid",
    density: 233.96,
    hidden: true,
    isFood: true
}
elements.strawberry_seed = {
    color: "#7a7133",
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(pixel,"strawberry_stem");
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    cooldown: defaultCooldown
}
elements.strawberry_stem = {
    color: "#419c2f",
    behavior: [
        "CR:strawberry_stem,strawberry_leaves,strawberry_leaves,strawberry_leaves,strawberry_leaves%3|CR:strawberry_stem,strawberry_leaves,strawberry_leaves,strawberry_leaves,strawberry_leaves%3|CR:strawberry_stem,strawberry_leaves,strawberry_leaves,strawberry_leaves,strawberry_leaves%3",
        "CR:strawberry_stem,strawberry_leaves,strawberry_leaves,strawberry_leaves,strawberry_leaves%3|XX|CR:strawberry_stem,strawberry_leaves,strawberry_leaves,strawberry_leaves,strawberry_leaves%3",
        "XX|M1|XX",
    ],
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    properties: {
        "age":0
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
}
elements.strawberry_leaves = {
    color: "#4bad37",
    behavior: [
        "XX|CR:strawberry%2|XX",
        "CR:strawberry%2|XX|CR:strawberry%2",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
}
elements.strawberry = {
    color: "#f04b3c",
    behavior: [
        "XX|ST:strawberry_stem,strawberry_leaves|XX",
        "ST:strawberry_stem,strawberry_leaves|XX|ST:strawberry_stem,strawberry_leaves",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "strawberry_juice",
    state: "solid",
    density: 1050,
    freezeDryInto: "freeze_dried_fruits",
}
elements.strawberry_juice = {
    color: "#e03a3a",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#e03a3a")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0,
    reactions: {
        "sugar": { elem1:"strawberry_jam", elem2:null, chance:0.35 },
        "milk": { elem1:"fruit_milk", elem2:null, chance:0.35, color1:"#f78888"},
    },
};
eLists.JUICEMIXABLE.push("strawberry_juice");

elements.cream.onMix = function(cream1, cream2) {
        if ((shiftDown && Math.random() < 0.01) || (elements[cream2.element].id === elements.cream.id && Math.random() < 0.1)) {
            changePixel(cream1,"whipped_cream")
        }
    }
elements.whipped_cream = {
    color: "#fafafa",
    behavior: behaviors.LIQUID,
    reactions: {
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "melted_chocolate": { color1:"#664934", elem2:null },
        "chocolate": { color1:"#664934", elem2:"melted_chocolate", chance:0.05 },
        "juice": { elem1:"fruit_milk", elem2:null, chance:0.05 },
        "soda": { elem1:"pilk", elem2:null, chance:0.1 },
        "yolk": { elem1:"#eggnog", elem2:null, chance:0.1 },
        "caramel": { color1:"#C8B39A", chance:0.05 },
        "sugar": { elem2:null, chance:0.005},
    },
    viscosity: 1.5,
    tempHigh: 1000,
    stateHigh: ["smoke","smoke","smoke","steam","steam","calcium"],
    tempLow: 0,
    stateLow: "ice_cream",
    stateLowColorMultiplier: 0.97,
    category: "food",
    hidden: true,
    isFood: true,
    state: "liquid",
    density: 959.97,
    viscosity: 2500000
}

elements.ginger = {
    color: ["#b88f30","#d6a73a"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2 AND CH:dirt,mud,sand,wet_sand,clay_soil,clay,mycelium,grass,color_sand>ginger,fiber%0.5|M1 AND CH:dirt,mud,sand,wet_sand,clay_soil,clay,mycelium,grass,color_sand>ginger,fiber,fiber%0.5|M2 AND CH:dirt,mud,sand,wet_sand,clay_soil,clay,mycelium,grass,color_sand>ginger,fiber%0.5",
    ],
    reactions: {
        "flour": { elem1:"gingerbread", elem2:null },
        "bread": { elem1:"gingerbread", elem2:null },
    },
    tempHigh: 275,
    stateHigh: "dirt",
    tempLow: -50,
    stateLow: "fiber",
    burn: 20,
    burnTime: 60,
    burnInto: "dirt",
    breakInto: "ginger_juice",
    cutInto: "cut_ginger",
    category: "food",
    state: "solid",
    density: 1250,
    conduct: 0.1,
    hidden: true
}
elements.cut_ginger = {
    color: "#ffdd80",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2|M1|M2",
    ],
    category:"food",
    tempHigh: 100,
    stateHigh: "steam",
    burn:15,
    burnTime:60,
    burnInto: "steam",
    breakInto: "juice",
    breakIntoColor:"#ffe396",
    state: "solid",
    density: 1050,
    hidden: true
}

elements.ginger_rhizome = {
    color: "#c7ad58",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"ginger");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("ginger_pseudostem",pixel.x,pixel.y+1);
                }
                if (isEmpty(pixel.x+1,pixel.y) && Math.random() < 0.2) {
                    createPixel("ginger_leaves",pixel.x+1,pixel.y);
                }
                if (isEmpty(pixel.x-1,pixel.y) && Math.random() < 0.2) {
                    createPixel("ginger_leaves",pixel.x-1,pixel.y);
                }
            }
            else if (pixel.age > 250) {
                changePixel(pixel,"ginger_leaves");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    breakInto: "ginger_juice",
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
    reactions: {
        "flour": { elem1:"gingerbread", elem2:null },
        "bread": { elem1:"gingerbread", elem2:null },
    },
};

elements.ginger_pseudostem = {
    color: "#69a82d",
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
}
elements.ginger_leaves = {
    color: "#52bd31",
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
}
elements.ginger_juice = {
    color: "#ccc056",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#ccc056")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0,
    reactions: {
        "flour": { elem1:"gingerbread", elem2:null },
        "bread": { elem1:"gingerbread", elem2:null },
    },
};
eLists.JUICEMIXABLE.push("ginger_juice");


elements.blueberry_seed = {
    color: "#7a7133",
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(pixel,"blueberry_stem");
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    cooldown: defaultCooldown
}
elements.blueberry_stem = {
    color: "#419c2f",
    behavior: [
        "CR:blueberry_stem,blueberry_leaves,blueberry_leaves,blueberry_leaves,blueberry_leaves%3|CR:blueberry_stem,blueberry_leaves,blueberry_leaves,blueberry_leaves,blueberry_leaves%3|CR:blueberry_stem,blueberry_leaves,blueberry_leaves,blueberry_leaves,blueberry_leaves%3",
        "CR:blueberry_stem,blueberry_leaves,blueberry_leaves,blueberry_leaves,blueberry_leaves%3|XX|CR:blueberry_stem,blueberry_leaves,blueberry_leaves,blueberry_leaves,blueberry_leaves%3",
        "XX|M1|XX",
    ],
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    properties: {
        "age":0
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
}
elements.blueberry_leaves = {
    color: "#4bad37",
    behavior: [
        "XX|CR:blueberry%2|XX",
        "CR:blueberry%2|XX|CR:blueberry%2",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
}
elements.blueberry = {
    color: "#5d4bc4",
    behavior: [
        "XX|ST:blueberry_stem,blueberry_leaves|XX",
        "ST:blueberry_stem,blueberry_leaves|XX|ST:blueberry_stem,blueberry_leaves",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "blueberry_juice",
    state: "solid",
    density: 1050,
    cutInto: "cut_blueberry",
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#33146e",
}
elements.blueberry_juice = {
    color: "#5030a1",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#5030a1")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0,
    reactions: {
        "sugar": { elem1:"blueberry_jam", elem2:null, chance:0.35 },
        "milk": { elem1:"fruit_milk", elem2:null, chance:0.35, color1: "#995fb3" },
    },
};

eLists.JUICEMIXABLE.push("blueberry_juice");
/*
elements.fruit_slushie = {
    color: "#ffcc54",
    behavior: behaviors.LIQUID,
    reactions: {
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" }
    },
    temp: -5,
    tempHigh: 18,
    tempLow: -20,
    stateLow: "ice",
    stateHigh: "water",
    category: "food",
    state: "liquid",
    density: 95,
    viscosity: 100,
    hidden: true
}
*/

elements.strawberry_jam = {
    color: "#c73c3e",
    behavior: behaviors.LIQUID,
    category: "food",
    tempHigh: 400,
    stateHigh: ["sugar","smoke"],
    burn: 70,
    burnTime: 300,
    viscosity: 750,
    state: "liquid",
    density: 825,
    hidden: true
};
elements.blueberry_jam = {
    color: "#281C4B",
    behavior: behaviors.LIQUID,
    category: "food",
    tempHigh: 400,
    stateHigh: ["sugar","smoke"],
    burn: 70,
    burnTime: 300,
    viscosity: 750,
    state: "liquid",
    density: 825,
    hidden: true
};
elements.cut_blueberry = {
    color: "#d4ed8a",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2|M1|M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "juice",
    breakIntoColor:"#add69a",
    state: "solid",
    density: 1050,
    hidden: true
}

if (!elements.yeast.reactions) elements.yeast.reactions = {};
elements.yeast.reactions.flour = { elem1: "advanced_dough", elem2: null }

elements.advanced_dough = {
    color: "#c49f58",
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "milk": { elem2:"broth", color2:"#ECC891", tempMin:70 },
        "cream": { elem2:"broth", color2:"#ECC891", tempMin:70 },
    },
    category: "food",
    tempHigh: 94,
    stateHigh: "bread",
    stateHighColorMultiplier: 0.9,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "solid",
    density: 526.9,
    isFood: true,
    hidden: true
}

if (!elements.melted_chocolate.reactions) elements.melted_chocolate.reactions = {};
elements.melted_chocolate.reactions.flour = { elem1: "cookie_dough", elem2: null }

elements.cookie_dough = {
    color: ["#946826","#9e783f","#8a6d41","#614925"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    tempHigh: 94,
    stateHigh: "cookie",
    stateHighColorMultiplier: 1.1,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "solid",
    density: 526.9,
    isFood: true,
    hidden: true
}

elements.cookie = {
    color: "#7d5f2e",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 605,
    stateHigh: "ash",
    category: "food",
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    breakIntoColor: "#7d6216",
    state: "solid",
    density: 233.96,
    isFood: true
}

elements.nut_oil.name = "cooking_oil"

elements.bread.behavior = behaviors.SUPPORT

elements.toast.behavior = behaviors.SUPPORT

if (!elements.caramel.reactions) elements.caramel.reactions = {};
elements.caramel.reactions.corn_starch = { elem1: "boba_dough", elem2: null, chance: 0.35, tempMin: 70}

elements.boba_dough = {
    color: ["#4a2007","#2b1304"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    tempHigh: 400,
    stateHigh: "ash",
    stateHighColorMultiplier: 0.8,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "solid",
    density: 526.9,
    reactions: {
        "water": { elem1:"boba", tempMin:60},
    },
    isFood: true,
    hidden: true
}

elements.boba = {
    color: "#59290c",
    behavior: behaviors.POWDER,
    tempHigh: 300,
    stateHigh: "fire",
    category: "food",
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakIntoColor: "#7d6216",
    state: "solid",
    density: 1500,
    isFood: true
}
elements.caramel.density = 1500
elements.freeze = {
    color: ["#42cbf5", "#42cbf5", "#42cbf5", "#75d3f0", "#42cbf5"],
    tool: function (pixel) {
        if (!shiftDown) {
            pixel.temp -= 0.2;
            pixelTempCheck(pixel);
        } else {
            pixel.temp -= 200;
            pixelTempCheck(pixel);
        }
    },
    category: "energy",
    canPlace: false,
    excludeRandom: true,
    desc: "Use on pixels to freeze them."
};
elements.warm = {
    color: ["#c7634a", "#c7634a", "#c7634a", "#e38f7b", "#c7634a"],
    tool: function (pixel) {
        if (!shiftDown) {
            pixel.temp += 0.2;
            pixelTempCheck(pixel);
        } else {
            pixel.temp += 200;
            pixelTempCheck(pixel);
        }
    },
    category: "energy",
    canPlace: false,
    excludeRandom: true,
    desc: "Use on pixels to warm them."
};
/*
elements.pineapple_seed = {
    color: "#695531",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (pixel.temp < 100 && pixel.temp > 20) {
                if (Math.random() < 0.02 && pixel.age > 50) {
                    if (!outOfBounds(pixel.x,pixel.y+1)) {
                        var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                        if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                            changePixel(dirtPixel,"root");
                            pixel.leaflength = pixel.leaflength+Math.round(Math.random())
                        }
                    }
                    if (isEmpty(pixel.x,pixel.y-1) && pixel.leafgrown==false) {
                        movePixel(pixel,pixel.x,pixel.y-1);
                        createPixel("pineapple_leaves",pixel.x,pixel.y+1);
                        if (isEmpty(pixel.x,pixel.y-1)) {
                            createPixel("pineapple",pixel.x,pixel.y-1);
                        }
                        if (isEmpty(pixel.x+1,pixel.y) && Math.random() < 0.5) {
                            createPixel("pineapple_leaves",pixel.x+1,pixel.y);
                            if (isEmpty(pixel.x+2,pixel.y-1) && Math.random() < 0.5) {
                                createPixel("pineapple_leaves",pixel.x+2,pixel.y-1);
                                if (pixel.leaflength == 4 && isEmpty(pixel.x+3,pixel.y-2) && Math.random() < 0.5) {
                                    createPixel("pineapple_leaves",pixel.x+3,pixel.y-2);
                                    pixel.leafgrown = true
                                }
                            }
                        }
                        if (isEmpty(pixel.x-1,pixel.y) && Math.random() < 0.5) {
                            createPixel("pineapple_leaves",pixel.x-1,pixel.y);
                            if (isEmpty(pixel.x-2,pixel.y-1) && Math.random() < 0.5) {
                                createPixel("pineapple_leaves",pixel.x-2,pixel.y-1);
                                if (pixel.leaflength = 3) {
                                    pixel.leafgrown = true
                                }
                                if (pixel.leaflength = 4 && isEmpty(pixel.x-3,pixel.y-2) && isEmpty(pixel.x+3,pixel.y-2) && Math.random() < 0.5) {
                                    createPixel("pineapple_leaves",pixel.x-3,pixel.y-2);
                                    createPixel("pineapple_leaves",pixel.x+3,pixel.y-2);
                                    pixel.leafgrown = true
                                }
                            }
                        }
                    }
                }
                else if (pixel.age > 500 && leafgrown == true && Math.random() < 0.1) {
                    changePixel(pixel,"pineapple_leaves");
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "leaflength":3,
        "leafgrown":false,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    temp:25,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};
*//*
function averageHexColor(color1, color2) {
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    const avgRed = Math.floor((rgb1[0] + rgb2[0]) / 2);
    const avgGreen = Math.floor((rgb1[1] + rgb2[1]) / 2);
    const avgBlue = Math.floor((rgb1[2] + rgb2[2]) / 2);
    const avgHex = rgbToHex(avgRed, avgGreen, avgBlue);
    return avgHex;
}

function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return [r, g, b];
}

function rgbToHex(r, g, b) {
    const rHex = r.toString(16).padStart(2, '0');
    const gHex = g.toString(16).padStart(2, '0');
    const bHex = b.toString(16).padStart(2, '0');
    return `${rHex}${gHex}${bHex}`;
}
*/
// test
//var color1 = "#FF0000";
//var color2 = "#0000FF";
//var averageColor = averageHexColor(color1, color2);
//console.log(averageColor)
/*
eLists.JUICEMIXABLE.forEach(function(element){
    elements[element].onMix = function(pixel1,pixel2) {
    if (shiftDown && eLists.JUICEMIXABLE.indexOf(pixel2.element) !== -1) {
        if (Math.random() < 0.2) {
            var hex1 = pixel1.color
            var hex2 = pixel2.color
            let rgb = pixel.color.replace("rgb(", "").replace(")", "").split(",");
            let rgbObj = { r: parseInt(rgb[0]), g: parseInt(rgb[1]), b: parseInt(rgb[2]) } //use this as one of the rgb objects
            var finalJuiceColor = interpolatedRgb(hex1,hex2,0.5)
            changePixel(pixel1,"juice")
            //pixel1.color = pixelColorPick(pixel,finalJuiceColor)
            pixel1.color = rgb(rgbObj)
        }
    }
}
})*/
elements.juice.onMix = function(pixel){
    let num = Math.floor(Math.random() * 4);
    let x = pixel.x + adjacentCoords[num][0];
    let y = pixel.y + adjacentCoords[num][1];
    if(!isEmpty(x,y) && !outOfBounds(x,y)){
      let pixel2 = pixelMap[x][y];
      if(pixel.color != pixel2.color && pixel2.element == "juice"){
        let condition;
        if(shiftDown == 0){
          condition = (Math.floor(Math.random() * 2) == 1); 
        } else {
          condition = true; 
        }
        if(condition){
          let newrgb = interpolateRgb(getRGB(pixel.color), getRGB(pixel2.color), 0.5);
          pixel.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
          pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
      }
    }
  }

elements.juice.stain = 0

elements.banana_seed = {
    color: "#594129",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1) && pixel.height < 7) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("banana_stem",pixel.x,pixel.y+1);
                    
                    pixel.height++
                }
            }
            else if (pixel.age > 150 && pixel.height > 6 && Math.random() < 0.1) {
                changePixel(pixel,"banana_tree_top");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "height": 0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.banana_stem = {
    color: "#698215",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "life",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.banana_tree_top = {
    color: "#718a21",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "life",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    properties:{
        "leftleaves": 0,
        "rightleaves": 0,
    },
    hidden: true,
    tick: function(pixel) {
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 0) {
            if (isEmpty(pixel.x+1,pixel.y)) {
                createPixel("banana_leaves",pixel.x+1,pixel.y);

                pixel.rightleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 1) {
            if (isEmpty(pixel.x+2,pixel.y)) {
                createPixel("banana_leaves",pixel.x+2,pixel.y);

                pixel.rightleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 2) {
            if (isEmpty(pixel.x+3,pixel.y)) {
                createPixel("banana_leaves",pixel.x+3,pixel.y);

                pixel.rightleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rightleaves == 3) {
            if (isEmpty(pixel.x+4,pixel.y+1)) {
                createPixel("banana_leaves",pixel.x+4,pixel.y+1);

                pixel.rightleaves++
            }
        }


        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 0) {
            if (isEmpty(pixel.x-1,pixel.y)) {
                createPixel("banana_leaves",pixel.x-1,pixel.y);

                pixel.leftleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 1) {
            if (isEmpty(pixel.x-2,pixel.y)) {
                createPixel("banana_leaves",pixel.x-2,pixel.y);

                pixel.leftleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 2) {
            if (isEmpty(pixel.x-3,pixel.y)) {
                createPixel("banana_leaves",pixel.x-3,pixel.y);

                pixel.leftleaves++
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.leftleaves == 3) {
            if (isEmpty(pixel.x-4,pixel.y+1)) {
                createPixel("banana_leaves",pixel.x-4,pixel.y+1);

                pixel.leftleaves++
            }
        }


        if (Math.random() < 0.1 && pixel.age > 70 && pixel.temp < 100 && pixel.leftleaves > 0 && pixel.rightleaves > 0) {
            if (isEmpty(pixel.x+1,pixel.y+2)) {
                createPixel("banana_peduncle",pixel.x+1,pixel.y+2);
            }
        }
        if (Math.random() < 0.1 && pixel.age > 70 && pixel.temp < 100 && pixel.leftleaves > 0 && pixel.rightleaves > 0) {
            if (isEmpty(pixel.x-1,pixel.y+2)) {
                createPixel("banana_peduncle",pixel.x-1,pixel.y+2);
            }
        }
        pixel.age++;
    doDefaults(pixel);
    },
}
elements.banana_leaves = {
    color: ["#3da324","#3cbd1c"],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.banana_peduncle = {
    color: "#8bb81a",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "life",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    hidden: true,
    tick: function(pixel) {
        if (Math.random() < 0.1 && pixel.temp < 100) {
            if (isEmpty(pixel.x+1,pixel.y+1)) {
                createPixel("hanging_banana_peduncle",pixel.x+1,pixel.y+1);
            }
            if (isEmpty(pixel.x-1,pixel.y+1)) {
                createPixel("hanging_banana_peduncle",pixel.x-1,pixel.y+1);
            }
            if (isEmpty(pixel.x+1,pixel.y+2)) {
                createPixel("hanging_banana_peduncle",pixel.x+1,pixel.y+2);
            }
            if (isEmpty(pixel.x-1,pixel.y+2)) {
                createPixel("hanging_banana_peduncle",pixel.x-1,pixel.y+2);
            }
        }
        pixel.age++;
    doDefaults(pixel);
    },
}
elements.hanging_banana_peduncle = {
    color: "#8bb81a",
    behavior: [
        "XX|XX|XX",
        "CR:banana%0.2|XX|CR:banana%0.2",
        "XX|XX|XX",
    ],
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "life",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    hidden: true,
}
elements.banana = {
    color: "#ebd834",
    behavior: [
        "XX|XX|XX",
        "ST:hanging_banana_peduncle|XX|ST:hanging_banana_peduncle",
        "XX|M1|XX",
    ],
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "banana_juice",
    state: "solid",
    density: 1050,
    cutInto: "cut_banana",
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#c4b939",
}
elements.cut_banana = {
    color: "#f2e56b",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2|M1|M2",
    ],
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "banana_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#c4b939",
}
elements.banana_juice = {
    color: "#dbc440",
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#dbc440")
            }
        }
    },
    reactions: {
        "bread": { elem1:"banana_bread", elem2:null, chance:0.35 },
        "milk": { elem1: "fruit_milk", elem2: "fruit_milk", chance: 0.35, color1:"#ede59a", color2:"#ede59a"},
        "coconut_milk": { elem1: "fruit_milk", elem2: "fruit_milk", chance: 0.35, color1:"#ede59a", color2:"#ede59a"},
        "nut_milk": { elem1: "fruit_milk", elem2: "fruit_milk", chance: 0.35, color1:"#ede59a", color2:"#ede59a"}
    },
    tempLow: 0
};
eLists.JUICEMIXABLE.push("banana_juice");

elements.banana_bread = {
    color: "#c2782f",
    desc: "delicious banana bread",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 176,
    stateHigh: "toast",
    category: "food",
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    state: "solid",
    density: 233.96,
    isFood: true
}
elements.sprinkles = {
    color: ["#eb726a", "#ebca6a", "#88eb6a", "#6aaceb", "#eb6ade"],
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    desc: "colorful edible sand",
    hidden: false,
    isFood: true,
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "sugar",
    breakIntoColor: ["#fb827a", "#fbda7a", "#98fb7a", "#7abcfb", "#fb7aee"],
    tempHigh: 176,
    stateHigh: "caramel",
    density: 277,
    cooldown: 2
}
elements.chocolate_chips = {
    color: "#6e4c1d",
    behavior: behaviors.POWDER,
    tempHigh: 31,
    stateHigh: "melted_chocolate",
    category: "food",
    state: "solid",
    density: 1325,
    isFood: true,
    desc: "chocolate chips yum",
    cooldown: 2
}
elements.chocolate.breakInto = "chocolate_chips"
//elements.fruit_milk.stateLowColorMultiplier = 0.9

elements.passion_fruit_vine = {
    color: "#00df00",
    behavior: [
        "ST:wood|ST:wood|ST:wood",
        "ST:wood AND CR:passion_fruit%0.02|XX|ST:wood AND CR:passion_fruit%0.02",
        "ST:wood|ST:wood AND M1|ST:wood",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    breakInto: "dead_plant"
}
elements.passion_fruit_seed = {
    color: "#6b4f36",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    if (!isEmpty(pixel.x+1,pixel.y-1) || !isEmpty(pixel.x-1,pixel.y-1)) {
                        movePixel(pixel,pixel.x,pixel.y-1);
                        createPixel("passion_fruit_vine",pixel.x,pixel.y+1);
                    }
                }
                if (!isEmpty(pixel.x+2,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1)) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel("passion_fruit_vine",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x-2,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1)) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel("passion_fruit_vine",pixel.x+1,pixel.y+1);
                }
                if (!isEmpty(pixel.x,pixel.y-1) && !isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x+1,pixel.y-1)) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel("passion_fruit_vine",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x,pixel.y-1) && !isEmpty(pixel.x-1,pixel.y) && isEmpty(pixel.x-1,pixel.y-1)) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel("passion_fruit_vine",pixel.x+1,pixel.y+1);
                }
                /*if (pixelMap[pixel.x+1][pixel.y-1].element !== "wood" && pixelMap[pixel.x-1][pixel.y-1].element !== "wood") {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("passion_fruit_vine",pixel.x,pixel.y+1);
                    if (isEmpty(pixel.x+1,pixel.y-1) && pixelMap[pixel.x+2][pixel.y-1].element === "wood") {
                        movePixel(pixel,pixel.x+1,pixel.y-1);
                        createPixel("passion_fruit_vine",pixel.x-1,pixel.y+1);
                    }
                    if (isEmpty(pixel.x-1,pixel.y-1) && pixelMap[pixel.x-2][pixel.y-1].element === "wood") {
                        movePixel(pixel,pixel.x-1,pixel.y-1);
                        createPixel("passion_fruit_vine",pixel.x+1,pixel.y+1);
                    }
                }*/
            }
            else if (pixel.age > 400 && Math.random() < 0.1) {
                changePixel(pixel,"passion_fruit_vine");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "ST:wood,passion_fruit_vine|ST:wood,passion_fruit_vine|ST:wood,passion_fruit_vine",
        "ST:wood,passion_fruit_vine|XX|ST:wood,passion_fruit_vine",
        "ST:wood,passion_fruit_vine|M1|ST:wood,passion_fruit_vine",
    ],
};

elements.passion_fruit = {
    color: "#78236f",
    behavior: [
        "ST:passion_fruit_vine%95|ST:passion_fruit_vine%95|ST:passion_fruit_vine%95",
        "ST:passion_fruit_vine%95|XX|ST:passion_fruit_vine%95",
        "ST:passion_fruit_vine%95|M1|ST:passion_fruit_vine%95",
    ],
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: ["passion_fruit_juice","passion_fruit_juice",/*"passion_fruit_seed"*/],
    state: "solid",
    density: 1050,
    cutInto: "passion_fruit_flesh",
    temp:20,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#412e6b"
}
elements.passion_fruit_flesh = {
    color: "#ffe205",
    behavior: behaviors.LIQUID,
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    viscosity: 999,
    burnInto: "dead_plant",
    breakInto: ["passion_fruit_juice","passion_fruit_juice",/*"passion_fruit_seed"*/],
    state: "solid",
    density: 1050,
    hidden: true,
    temp: 20
}
elements.passion_fruit_juice = {
    color: "#d6bf2b",
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 20,
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#d6bf2b")
            }
        }
    },
    tempLow: 0
};
eLists.JUICEMIXABLE.push("passion_fruit_juice");

elements.mango_wood = {
    color: "#966435",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.mango_branch = {
    color: "#966435",
    behavior: [
        "CR:mango_leaves,mango_branch%2|CR:mango_leaves,mango_branch%2|CR:mango_leaves,mango_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "mango_wood",
    tempLow: -30,
    stateLow: "mango_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
}
elements.mango_leaves = {
    color: ["#61b535","#5fba2f"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:mango%0.1|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.mango = {
    color: ["#cc5b3f","#cc8a3f","#ccb93f","#abcc3f"],
    behavior: behaviors.POWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "mango_juice",
    cutInto: "cut_mango",
    state: "solid",
    density: 1050,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#ccb50a",
}

elements.cut_mango = {
    color: "#ebcb2d",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "mango_juice",
    state: "solid",
    density: 1050,
    hidden: true,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#ccb50a",
}

elements.mango_seed = {
    color: "#9e8951",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "mango_wood" : "mango_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"mango_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};

elements.mango_juice = {
    color: "#f0c348",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#f0c348")
            }
        }
    },
    reactions: {
        "milk": { elem1: "fruit_milk", elem2: "fruit_milk", chance: 0.35, color1:"#fada70", color2:"#fada70"},
        "coconut_milk": { elem1: "fruit_milk", elem2: "fruit_milk", chance: 0.35, color1:"#fada70", color2:"#fada70"},
        "nut_milk": { elem1: "fruit_milk", elem2: "fruit_milk", chance: 0.35, color1:"#fada70", color2:"#fada70"}
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0
};
eLists.JUICEMIXABLE.push("mango_juice");

elements.pineapple_leaves = {
    color: "#3aab11",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.pineapple = {
    color: "#e8bc38",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "pineapple_juice",
    state: "solid",
    density: 1050,
    temp:20,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#ccb90a",
}
elements.pineapple_seed = {
    color: "#695531",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (pixel.temp < 100 && pixel.temp > 20) {
                if (Math.random() < 0.02 && pixel.age > 50) {
                    if (!outOfBounds(pixel.x,pixel.y+1)) {
                        var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                        if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                            changePixel(dirtPixel,"root");
                            if (isEmpty(pixel.x,pixel.y-1) && pixel.leafgrown==false) {
                                movePixel(pixel,pixel.x,pixel.y-1);
                                createPixel("pineapple_leaves",pixel.x,pixel.y+1);
                                if (isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x-1,pixel.y)) {
                                    createPixel("pineapple_leaves",pixel.x+1,pixel.y);
                                    createPixel("pineapple_leaves",pixel.x-1,pixel.y);
                                    if (isEmpty(pixel.x-2,pixel.y-1) && isEmpty(pixel.x+2,pixel.y-1)) {
                                        createPixel("pineapple_leaves",pixel.x+2,pixel.y-1);
                                        createPixel("pineapple_leaves",pixel.x-2,pixel.y-1);
                                        if (isEmpty(pixel.x,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1)) {
                                            createPixel("pineapple",pixel.x,pixel.y-1);
                                            createPixel("pineapple",pixel.x+1,pixel.y-1);
                                            createPixel("pineapple",pixel.x-1,pixel.y-1);
                                            if (isEmpty(pixel.x,pixel.y-2) && isEmpty(pixel.x+1,pixel.y-2) && isEmpty(pixel.x-1,pixel.y-2)) {
                                                createPixel("pineapple",pixel.x,pixel.y-2);
                                                createPixel("pineapple",pixel.x+1,pixel.y-2);
                                                createPixel("pineapple",pixel.x-1,pixel.y-2);
                                                if (isEmpty(pixel.x,pixel.y-3) && isEmpty(pixel.x+1,pixel.y-3) && isEmpty(pixel.x-1,pixel.y-3)) {
                                                    createPixel("pineapple",pixel.x,pixel.y-3);
                                                    createPixel("pineapple",pixel.x+1,pixel.y-3);
                                                    createPixel("pineapple",pixel.x-1,pixel.y-3);
                                                    if (isEmpty(pixel.x,pixel.y-4) && isEmpty(pixel.x+1,pixel.y-4) && isEmpty(pixel.x-1,pixel.y-4)) {
                                                        createPixel("pineapple",pixel.x,pixel.y-4);
                                                        createPixel("pineapple",pixel.x+1,pixel.y-4);
                                                        createPixel("pineapple",pixel.x-1,pixel.y-4);
                                                        if (isEmpty(pixel.x,pixel.y-5) && isEmpty(pixel.x+1,pixel.y-6) && isEmpty(pixel.x-1,pixel.y-6)) {
                                                            createPixel("pineapple_leaves",pixel.x,pixel.y-5);
                                                            createPixel("pineapple_leaves",pixel.x+1,pixel.y-6);
                                                            createPixel("pineapple_leaves",pixel.x-1,pixel.y-6);
                                                            pixel.leafgrown = true
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if (pixel.age > 500 && pixel.leafgrown == true && Math.random() < 0.1) {
                    changePixel(pixel,"pineapple_leaves");
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "leafgrown":false,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    temp:25,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.pineapple_juice = {
    color: "#d9ba32",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#d9ba32")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    tempLow: 0
};
eLists.JUICEMIXABLE.push("pineapple_juice");

elements.lime = {
    color: ["#549c2d","#4d9c22"],
    behavior: behaviors.POWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
    },
    category:"food",
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#5eab24",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "lime_juice",
    state: "solid",
    density: 1050,
    isFood: true,
    cutInto: ["lime_zest","lime_slice","lime_slice","lime_slice","lime_slice"],
}

elements.lime_juice = {
    color: "#85d14b",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#85d14b")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    hidden: true,
    tempLow: 0,
};
eLists.JUICEMIXABLE.push("lime_juice");

elements.lime_zest = {
    color: "#4f9e13",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
}

elements.lime_slice = {
    color: "#8acc33",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "lime_juice",
    state: "solid",
    density: 1050,
    hidden: true,
}

elements.snail.reactions.nut_oil = { elem1: "escargot", chance:30, tempMin:50 }

elements.escargot = {
    color: "#ab924d",
    behavior: behaviors.STURDYPOWDER2,
    tempHigh: 120,
    stateHigh: "steam",
    breakInto: "quicklime",
    category: "food",
    state: "solid",
    density: 1500,
    conduct: 0.16
}

elements.broccoli = {
    color: ["#49a82f","#429929"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "ST:broccoli_stem AND M2|ST:broccoli_stem AND M1|ST:broccoli_stem AND M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    isFood: true,
    density: 1050,
    cutInto: "cut_broccoli",
}
elements.broccoli_stem = {
    color: ["#51c431","#45ba25"],
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    cutInto: "cut_broccoli",
    state: "solid",
    density: 1050,
    hidden: true,
}

elements.cut_broccoli = {
    color: "#75d65a",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: "steam",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
}

elements.broccoli_seed = {
    color: "#9e8951",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.2 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1)) {
                    changePixel(pixel,"broccoli_stem");
                    createPixel("broccoli",pixel.x,pixel.y-1);
                    createPixel("broccoli",pixel.x+1,pixel.y-1);
                    createPixel("broccoli",pixel.x-1,pixel.y-1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"broccoli");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.freeze_dried_fruits = {
    color: "#ab1f31",
    behavior: behaviors.POWDER,
    tempHigh: 550,
    stateHigh: "ash",
    category: "food",
    burn: 15,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    state: "solid",
    density: 233.96,
    isFood: true,
}

elements.grape.freezeDryInto = "freeze_dried_fruits"
elements.grape.freezeDryIntoColor = "#5d156b"

elements.soapy_water = {
    color: "#72b8f2",
    behavior: [
        "XX|CR:bubble%0.25|XX",
        "M2%50|XX|M2%50",
        "M2%50|M1|M2%50",
    ],
    tempHigh: 100,
    stateHigh: "steam",
    tempLow: 0,
    category: "liquids",
    heatCapacity: 4.184,
    reactions: {
        "dirt": {elem1: null,elem2: "mud"},
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "salt": { elem1: "salt_water", elem2: null, temp1:-20 },
        "dust": { elem2: null, elem2: null },
        "plague": { elem2: null, elem2: null },
        "rust": { elem1: "iron", chance:0.005 },
        "fallout": {elem2: null, chance:0.25 },
        "radiation": { elem2: null, chance:0.25 },
        "uranium": { elem2: null, chance:0.25 },
        "rotten_meat": { elem2: "meat", chance:0.25 },
        "rotten_cheese": { elem2: "cheese", chance:0.25 },
        "cancer": { elem2: null, chance:0.25 },
        "oil": { elem2: null, chance:0.005 },
        "dioxin": { elem1: "dirty_water", chance:0.1 },
        "quicklime": { elem1: "slaked_lime", elem2: "slaked_lime", temp2:100, temp1:100, chance:0.05 },
        "rock": { elem2: "wet_sand", chance: 0.00035 },
        "limestone": { elem2: "wet_sand", chance: 0.00035 },
        "tuff": { elem2: "wet_sand", color2:"#7a6b5c", chance: 0.00035 },
        "mudstone": { elem2: "mud", chance: 0.00035 },
        "fly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "firefly": { elem2:"dead_bug", chance:0.1, oneway:true },
        "bee": { elem2:"dead_bug", chance:0.05, oneway:true },
        "stink_bug": { elem2:"dead_bug", chance:0.1, oneway:true },
        "cured_meat": {elem2:"meat" },
    },
    state: "liquid",
    density: 997,
    conduct: 0.02,
    stain: -1,
    extinguish: true
}

elements.soap.behavior = behaviors.STURDYPOWDER
elements.soap.state = "solid"
elements.soap.category = "powders"

elements.soap.reactions.water = {elem2: "soapy_water", elem1: null, chance: 10}
/*
if ([pixel.element].stain < 0 && [pixel.element] != "soap" && [pixel.element] != "soapy_water") {
    [pixel.element].stain = [pixel.element].stain/10
}
*/
elements.onion = {
    color: "#731066",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: "steam",
    burn:65,
    burnTime:60,
    burnInto: "steam",
    state: "solid",
    density: 1050,
    cutInto: "cut_onion",
    breakInto:"onion_powder",
    cutIntoEmit: "stench",
}
elements.cut_onion = {
    color: "#dcc5ed",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: "steam",
    burn:65,
    burnTime:60,
    burnInto: "steam",
    state: "solid",
    density: 1050,
    breakInto:"onion_powder",
    hidden: true,
    reactions:{ "nut_oil": {elem1:"fried_onion", tempMin: 70, chance:10}}
}
elements.fried_onion = {
    color: "#cf9344",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 500,
    stateHigh: "ash",
    burn:65,
    burnTime:60,
    burnInto: "ash",
    state: "solid",
    density: 1050,
    hidden: true,
}

elements.onion_seed = {
    color: "#1a0e02",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.2 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-2) && isEmpty(pixel.x,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1) && isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x-1,pixel.y)) {
                    createPixel("onion",pixel.x,pixel.y-1);
                    createPixel("onion",pixel.x+1,pixel.y-1);
                    createPixel("onion",pixel.x-1,pixel.y-1);
                    createPixel("onion",pixel.x,pixel.y-2);
                    createPixel("onion",pixel.x+1,pixel.y);
                    createPixel("onion",pixel.x-1,pixel.y);
                    if (isEmpty(pixel.x+1,pixel.y-3) && isEmpty(pixel.x-1,pixel.y-3)) {
                        createPixel("spring_onion_leaves",pixel.x+1,pixel.y-3);
                        createPixel("spring_onion_leaves",pixel.x-1,pixel.y-3);
                        changePixel(pixel,"onion");
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
}
elements.onion_powder = {
    color: "#e6d8b8",
    reactions: {
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
    },
    behavior: behaviors.POWDER,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
}
elements.unhusked_rice = {
    color: ["#c99a42","#b08638","#deb15d"],
    behavior: [
        "XX|XX|XX",
        "ST:rice_panicle|XX|ST:rice_panicle",
        "ST:rice_plant AND M2|ST:rice_panicle AND M1|ST:rice_plant AND M2",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 65,
    stateHigh: "cooked_rice",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "flour",
    breakIntoColor: "#f7f1df",
    state: "solid",
    isFood: true,
    density: 1050,
    cutInto: "rice",
}
elements.rice = {
    color: "#eeeed2",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 65,
    stateHigh: "cooked_rice",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "rice_flour",
    state: "solid",
    isFood: true,
    density: 1050,
    reactions:{
        "water":{elem1:"porridge",elem2:"porridge",chance:3,tempMin:70},
        "nut_oil":{elem1:"fried_rice",elem2:null,chance:3,tempMin:60}
    }
}
elements.cooked_rice = {
    color: "#eddfb9",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 200,
    stateHigh: "burnt_rice",
    burn:65,
    breakInto: "rice_flour",
    state: "solid",
    isFood: true,
    density: 1050,reactions:{
        "water":{elem1:"porridge",elem2:"porridge",chance:3,tempMin:70},
        "nut_oil":{elem1:"fried_rice",elem2:null,chance:3,tempMin:60}
    },
    hidden:true
}
elements.porridge = {
    color: "#f2ecdc",
    behavior: behaviors.LIQUID,
    category:"food",
    tempHigh: 200,
    stateHigh: "steam",
    viscosity: 999,
    burn:65,
    state: "solid",
    isFood: true,
    density: 1050,
}
elements.fried_rice = {
    color: "#e8dda0",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 200,
    stateHigh: "burnt_rice",
    burn:65,
    burnTime:60,
    state: "solid",
    isFood: true,
    density: 1050,reactions:{
        "salt":{color1:"#ede5b9",elem2:null,chance:3},
        "monosodium_glutamate":{color1:"#ede5b9",elem2:null,chance:3}
    },
    hidden:true
}
elements.burnt_rice = {
    color: "#262217",
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 500,
    stateHigh: "ash",
    burn:65,
    burnTime:60,
    state: "solid",
    isFood: true,
    density: 1050,
    hidden: true
}
elements.rice_plant = {
    color: "#37a825",
    behavior: behaviors.WALL,
    category:"life",
    tempHigh: 100,
    stateHigh: "steam",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
    
}
elements.rice_seed = {
    color: "#997a23",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.2 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if(!isEmpty(pixel.x-1,pixel.y) && !isEmpty(pixel.x+1,pixel.y)){
                    if(pixelMap[pixel.x+1][pixel.y].element === "water" && pixelMap[pixel.x-1][pixel.y].element === "water"){
                        if (isEmpty(pixel.x,pixel.y-1)){
                            movePixel(pixel,pixel.x,pixel.y-1)
                            createPixel("rice_plant",pixel.x,pixel.y+1)
                            pixel.notinwater=true
                        }
                        else if (!isEmpty(pixel.x,pixel.y-1)){
                            if (pixelMap[pixel.x][pixel.y-1].element === "water") {
                                deletePixel(pixel.x,pixel.y-1)
                                movePixel(pixel,pixel.x,pixel.y-1)
                                createPixel("rice_plant",pixel.x,pixel.y+1)
                            }
                        }
                    }
                }
                if (Math.random() < 0.2 && pixel.age > 50 && pixel.temp < 100 && pixel.notinwater == true) {
                    if (isEmpty(pixel.x+1,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1)&&isEmpty(pixel.x+2,pixel.y-2) && isEmpty(pixel.x-2,pixel.y-2)) {
                        createPixel("rice_plant",pixel.x+1,pixel.y-1);
                        createPixel("rice_plant",pixel.x-1,pixel.y-1);
                        createPixel("rice_plant",pixel.x+2,pixel.y-2);
                        createPixel("rice_plant",pixel.x-2,pixel.y-2);
                        pixel.leafgrown = true
                    }
                }
                if (Math.random() < 0.2 && pixel.age > 50 && pixel.temp < 100 && pixel.leafgrown == true) {
                    if (isEmpty(pixel.x,pixel.y-1) && isEmpty(pixel.x,pixel.y-2)&&isEmpty(pixel.x,pixel.y-3) && isEmpty(pixel.x,pixel.y-4)) {
                        movePixel(pixel,pixel.x,pixel.y-4)
                        createPixel("rice_plant",pixel.x,pixel.y+1);
                        createPixel("rice_plant",pixel.x,pixel.y+2);
                        createPixel("rice_plant",pixel.x,pixel.y+3);
                        createPixel("rice_plant",pixel.x,pixel.y+4);
                        changePixel(pixel,"rice_panicle")
                        pixel.grower = true
                    }
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"unhusked_rice");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "leafgrown":false,
        "notinwater":false,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 2500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.rice_panicle = {
    color: "#37a825",
    behavior: behaviors.WALL,
    category:"life",
    tempHigh: 100,
    stateHigh: "steam",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    tick: function(pixel) {
        if (Math.random() < 0.1) {
            if (isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x-1,pixel.y)) {
                createPixel("unhusked_rice",pixel.x+1,pixel.y);
                createPixel("unhusked_rice",pixel.x-1,pixel.y);
            }
            if (isEmpty(pixel.x+1,pixel.y+1) && isEmpty(pixel.x-1,pixel.y+1)) {
                createPixel("unhusked_rice",pixel.x+1,pixel.y+1);
                createPixel("unhusked_rice",pixel.x-1,pixel.y+1);
            }
            if (isEmpty(pixel.x,pixel.y-1)) {
                createPixel("unhusked_rice",pixel.x,pixel.y-1);
            }
        }
    },
    state: "solid",
    density: 1050,
    hidden: true,
    
}

elements.rice_flour = {
    color: "#f7f1df",
    behavior: behaviors.POWDER,
    reactions: {
        "water": { elem1: "mochi_dough", elem2: null },
        "salt_water": { elem1: "mochi_dough", elem2: null },
        "sugar_water": { elem1: "mochi_dough", elem2: null },
        "seltzer": { elem1: "mochi_dough", elem2: null },
        "yolk": { elem1: "batter", elem2: null },
        "yogurt": { elem1: "batter", elem2: null },
        "milk": { elem1:"dough", elem2:null },
        "cream": { elem1:"dough", elem2:null },
    },
    category: "food",
    tempHigh: 400,
    stateHigh: "fire",
    burn:40,
    burnTime:25,
    state: "solid",
    density: 600,
    isFood: true
},
elements.mochi_dough = {
    color: "#ebddae",
    behavior: behaviors.STURDYPOWDER,
    onMix: function(dough,ingredient) {
        if (elements[ingredient.element].isFood && elements[ingredient.element].id !== elements.dough.id && elements[ingredient.element].id !== elements.flour.id && elements[ingredient.element].id !== elements.batter.id && elements[ingredient.element].id !== elements.bread.id) {
            var rgb1 = dough.color.match(/\d+/g);
            var rgb2 = ingredient.color.match(/\d+/g);
            // average the colors
            var rgb = [
                Math.round((parseInt(rgb1[0])*10+parseInt(rgb2[0]))/11),
                Math.round((parseInt(rgb1[1])*10+parseInt(rgb2[1]))/11),
                Math.round((parseInt(rgb1[2])*10+parseInt(rgb2[2]))/11)
            ];
            // convert rgb to hex
            var hex = RGBToHex(rgb);
            dough.color = pixelColorPick(dough, hex);
        }
    },
    category: "food",
    tempHigh: 94,
    stateHigh: "mochi",
    //stateHighColorMultiplier: 0.9,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "solid",
    density: 526.9,
    isFood: true,
    hidden:true
},
elements.mochi = {
    color: "#f2e2a7",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 400,
    stateHigh: ["ash","steam"],
    category: "food",
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    state: "solid",
    density: 233.96,
    isFood: true
},
elements.monosodium_glutamate = {
    color: "#eeeeee",
    behavior: behaviors.POWDER,
    reactions: {
        "ice": { elem1:null, elem2:"salt_water", chance:0.1 },
        "rime": { elem1:null, elem2:"salt_water", chance:0.075 },
        "snow": { elem1:null, elem2:"salt_water", chance:0.25 },
        "packed_snow": { elem1:null, elem2:"salt_water", chance:0.05 },
        "packed_ice": { elem1:null, elem2:"salt_water", chance:0.01 },
        "water": { elem2: "salt_water", elem1: null, temp2:-20 },
    },
    category: "food",
    tempHigh: 801,
    state: "solid",
    density: 2160,
    alias: "msg",
}
elements.seaweed_spore = {
    color: "#291f13",
    tick: function(pixel) {
        pixel.age++;
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else if (!isEmpty(pixel.x,pixel.y+1)){
            if (!outOfBounds(pixel.x,pixel.y+1)) {
                if (pixelMap[pixel.x][pixel.y+1].element === "water"){
                    swapPixels(pixel,pixelMap[pixel.x][pixel.y+1])
                }
            }
        }
        if (!outOfBounds(pixel.x,pixel.y+1)) {
            if (!isEmpty(pixel.x,pixel.y+1)){
                var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                    changePixel(dirtPixel,"root");
                    pixel.rooted = true
                }
            }
        }
        if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100 && pixel.rooted == true) {
            if(!isEmpty(pixel.x,pixel.y-1)){
                if(pixelMap[pixel.x][pixel.y-1].element === "water"){
                    //swapPixels(pixel,pixelMap[pixel.x][pixel.y-1])
                    //changePixel("seaweed_stem",pixel.x,pixel.y+1)
                    deletePixel(pixel.x,pixel.y-1)
                    movePixel(pixel,pixel.x,pixel.y-1)
                    createPixel("seaweed_stem",pixel.x,pixel.y+1)
                    if (!isEmpty(pixel.x-1,pixel.y+1) && !isEmpty(pixel.x-1,pixel.y) && !isEmpty(pixel.x+1,pixel.y) && Math.random() < 0.5){
                        if (pixelMap[pixel.x-1][pixel.y].element === "water" && pixelMap[pixel.x+1][pixel.y].element === "water" && pixelMap[pixel.x-1][pixel.y+1].element != "seaweed") {
                            deletePixel(pixel.x-1,pixel.y)
                            createPixel("seaweed",pixel.x-1,pixel.y)
                            deletePixel(pixel.x+1,pixel.y)
                            createPixel("seaweed",pixel.x+1,pixel.y)
                        }
                    }
                }
            }
            if (pixel.age > 500 || isEmpty(pixel.x,pixel.y-1)) {
                changePixel(pixel,"seaweed");
            }
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "rooted":false,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 2500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.seaweed_stem = {
    color: "#35702c",
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "alcohol": { elem1:"agar", elem2:null, chance:0.035 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dried_seaweed",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
}
elements.seaweed = {
    color: ["#2e8021","#3e9031","#4ea041"],
    behavior: [
        "XX|XX|XX",
        "ST:seaweed_stem|XX|ST:seaweed_stem",
        "XX|M1|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "alcohol": { elem1:"agar", elem2:null, chance:0.035 },
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dried_seaweed",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 997,
}
elements.dried_seaweed = {
    color: ["#142e13","#041e03"],
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 400,
    stateHigh: "fire",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
}
elements.grape_vine = {
    color: "#427a33",
    behavior: [
        "ST:wood|ST:wood|ST:wood",
        "ST:wood AND CR:grape%0.02|XX|ST:wood AND CR:grape%0.02",
        "ST:wood|ST:wood AND M1|ST:wood",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    breakInto: "dead_plant"
}
elements.grape_seed = {
    color: "#7a6033",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    if (!isEmpty(pixel.x+1,pixel.y-1) || !isEmpty(pixel.x-1,pixel.y-1)) {
                        movePixel(pixel,pixel.x,pixel.y-1);
                        createPixel("grape_vine",pixel.x,pixel.y+1);
                    }
                }
                if (!isEmpty(pixel.x+2,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1)) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel("grape_vine",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x-2,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1)) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel("grape_vine",pixel.x+1,pixel.y+1);
                }
                if (!isEmpty(pixel.x,pixel.y-1) && !isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x+1,pixel.y-1)) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel("grape_vine",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x,pixel.y-1) && !isEmpty(pixel.x-1,pixel.y) && isEmpty(pixel.x-1,pixel.y-1)) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel("grape_vine",pixel.x+1,pixel.y+1);
                }
            }
            else if (pixel.age > 400 && Math.random() < 0.1) {
                changePixel(pixel,"grape_vine");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "ST:wood,grape_vine|ST:wood,grape_vine|ST:wood,grape_vine",
        "ST:wood,grape_vine|XX|ST:wood,grape_vine",
        "ST:wood,grape_vine|M1|ST:wood,grape_vine",
    ],
};
elements.grape.behavior = [
    "ST:grape_vine%95|ST:grape_vine%95|ST:grape_vine%95",
    "ST:grape_vine%95|XX|ST:grape_vine%95",
    "M2 AND ST:grape_vine%95|M1|M2 AND ST:grape_vine%95",
]
elements.tomato_vine = {
    color: "#2e7d1d",
    behavior: [
        "ST:wood|ST:wood|ST:wood",
        "ST:wood AND CR:tomato%0.02|XX|ST:wood AND CR:tomato%0.02",
        "ST:wood|ST:wood AND M1|ST:wood",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    breakInto: "dead_plant"
}
elements.tomato_seed = {
    color: "#945d26",
    tick: function(pixel) {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    if (!isEmpty(pixel.x+1,pixel.y-1) || !isEmpty(pixel.x-1,pixel.y-1)) {
                        movePixel(pixel,pixel.x,pixel.y-1);
                        createPixel("tomato_vine",pixel.x,pixel.y+1);
                    }
                }
                if (!isEmpty(pixel.x+2,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1)) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel("tomato_vine",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x-2,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1)) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel("tomato_vine",pixel.x+1,pixel.y+1);
                }
                if (!isEmpty(pixel.x,pixel.y-1) && !isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x+1,pixel.y-1)) {
                    movePixel(pixel,pixel.x+1,pixel.y-1);
                    createPixel("tomato_vine",pixel.x-1,pixel.y+1);
                }
                if (!isEmpty(pixel.x,pixel.y-1) && !isEmpty(pixel.x-1,pixel.y) && isEmpty(pixel.x-1,pixel.y-1)) {
                    movePixel(pixel,pixel.x-1,pixel.y-1);
                    createPixel("tomato_vine",pixel.x+1,pixel.y+1);
                }
            }
            else if (pixel.age > 400 && Math.random() < 0.1) {
                changePixel(pixel,"tomato_vine");
            }
            pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "age":0,
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "ST:wood,tomato_vine|ST:wood,tomato_vine|ST:wood,tomato_vine",
        "ST:wood,tomato_vine|XX|ST:wood,tomato_vine",
        "ST:wood,tomato_vine|M1|ST:wood,tomato_vine",
    ],
};
elements.tomato.behavior = [
    "ST:tomato_vine%95|ST:tomato_vine%95|ST:tomato_vine%95",
    "ST:tomato_vine%95|XX|ST:tomato_vine%95",
    "ST:tomato_vine%95|M1|ST:tomato_vine%95",
]
elements.peppermint_stem = {
    color: "#2c9c3a",
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    cutInto:"peppermint",
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    breakInto: "dead_plant",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1) && pixel.grower == false && pixel.leafgrower == false) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        if (pixel.grower == true) {
            // set limit to 3 + rounded math.random inside the function
            // check if left side has stem if no set direction to right
            if (!isEmpty(pixel.x-1,pixel.y) && pixel.direction == "undefined") {
                if (pixelMap[pixel.x-1][pixel.y].element == "peppermint_stem") {
                    pixel.direction = "right";
                    pixel.limit = 3+Math.round(Math.random());
                }
            }
            // same thing to set direction the left
            else if (!isEmpty(pixel.x+1,pixel.y) && pixel.direction == "undefined") {
                if (pixelMap[pixel.x+1][pixel.y].element == "peppermint_stem") {
                    pixel.direction = "left";
                    pixel.limit = 3+Math.round(Math.random());
                }
            }
        }
        if (pixel.grower == true && pixel.limit > 0) {
            // left
            if (pixel.direction == "left") {
                if (isEmpty(pixel.x-1,pixel.y-1) && Math.random() < 0.1) {
                    createPixel("peppermint_leaves",pixel.x-1,pixel.y-1);
                    if (isEmpty(pixel.x-2,pixel.y-2) && Math.random() < 0.2) {
                        createPixel("peppermint_leaves",pixel.x-2,pixel.y-2);
                        if (isEmpty(pixel.x-3,pixel.y-3) && Math.random() < 0.4) {
                            createPixel("peppermint_leaves",pixel.x-3,pixel.y-3);
                            if (isEmpty(pixel.x-4,pixel.y-4) && Math.random() < 0.75 && pixel.limit == 4) {
                                createPixel("peppermint_leaves",pixel.x-4,pixel.y-4);
                            }
                        }
                    }
                }
            }
            // right
            else if (pixel.direction == "right") {
                if (isEmpty(pixel.x+1,pixel.y-1) && Math.random() < 0.1) {
                    createPixel("peppermint_leaves",pixel.x+1,pixel.y-1);
                    if (isEmpty(pixel.x+2,pixel.y-2) && Math.random() < 0.2) {
                        createPixel("peppermint_leaves",pixel.x+2,pixel.y-2);
                        if (isEmpty(pixel.x+3,pixel.y-3) && Math.random() < 0.4) {
                            createPixel("peppermint_leaves",pixel.x+3,pixel.y-3);
                            if (isEmpty(pixel.x+4,pixel.y-4) && Math.random() < 0.75 && pixel.limit == 4) {
                                createPixel("peppermint_leaves",pixel.x+4,pixel.y-4);
                            }
                        }
                    }
                }
            }
        }
        pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "grower":false,
        "age":0,
        "direction":"undefined",
        "limit":0
    }
}
elements.peppermint_leaves = {
    color: "#36a845",
    reactions: {
        "water": { elem2:"peppermint_tea", tempMin:80 },
        "salt_water": { elem2:"peppermint_tea", tempMin:80 },
        "sugar_water": { elem2:"peppermint_tea", tempMin:80 },
        "seltzer": { elem2:"peppermint_tea", tempMin:80 },
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
        "yeast": {elem1:"tea", chance:0.01},
        "ice_cream": {elem1:null,color2:"#94e067",chance:0.3}
    },
    behavior: behaviors.WALL,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    tempLow: -2,
    stateLow: "frozen_plant",
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
    cutInto: "peppermint"
},
elements.peppermint_seed = {
    color: "#6b5f4c",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("peppermint_stem",pixel.x,pixel.y+1);
                    pixel.height++;
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 3) {
                    if (isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("peppermint_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                    }
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 9) {
                    if (isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("peppermint_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                    }
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 6) {
                    if (isEmpty(pixel.x-1,pixel.y)) {
                        createPixel("peppermint_stem",pixel.x-1,pixel.y);
                        pixelMap[pixel.x-1][pixel.y].grower = true;
                    }
                }
                if (pixel.height > 11) {
                    if (isEmpty(pixel.x-1,pixel.y) && isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("peppermint_stem",pixel.x-1,pixel.y);
                        pixelMap[pixel.x-1][pixel.y].grower = true;
                        createPixel("peppermint_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                        deletePixel(pixel.x,pixel.y);
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "height":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.peppermint_tea = {
    color: "#687d1d",
    behavior: behaviors.LIQUID,
    reactions: {
        "stench": { elem2:null },
        "flea": { elem2:null, chance:0.01 },
        "oxygen": { elem2:"fragrance", chance:0.01 },
        "infection": { elem2:"blood", chance:0.005 },
        "plague": { elem2:null, chance:0.004 },
        "sugar": { elem2:null, color1:"#8f5a21", chance:0.005},
        "honey": { elem2:null, color1:"#8f5a21", chance:0.005},
        "milk": { elem2:null, color1:"#9c6c38", chance:0.005},
        "cream": { elem2:null, color1:"#9c6c38", chance:0.005},
        "ice_cream": { elem2:null, color1:"#9c6c38", chance:0.005},
        "honey": {color1:"#8d8f27",elem2:null,chance:0.3},
        "lemon_juice": {color1:"#8d8f27",elem2:null,chance:0.3},
        "lemonade": {color1:"#8d8f27",elem2:null,chance:0.3},
        "sugar": {color1:"#83963e",elem2:null,chance:0.3}
    },
    tempHigh: 125,
    stateHigh: ["steam","fragrance",null],
    temp: 50,
    tempLow: 0,
    category:"liquids",
    state: "liquid",
    density: 1001,
    stain: -0.1,
    hidden: true,
    isFood: true
}
elements.peppermint = {
    color: ["#64a135","#559425"],
    reactions: {
        "water": { elem2:"peppermint_tea", tempMin:80 },
        "salt_water": { elem2:"peppermint_tea", tempMin:80 },
        "sugar_water": { elem2:"peppermint_tea", tempMin:80 },
        "seltzer": { elem2:"peppermint_tea", tempMin:80 },
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
        "ice_cream": {elem1:null,color2:"#94e067",chance:0.3},
    },
    behavior: behaviors.POWDER,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
}
//elements.candy.reactions.peppermint = {color1:["eeeddc","f5f267"],elem2:null,chance:3}
elements.vanilla_stem = {
    color: "#5d9c48",
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
    breakInto: "dead_plant",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1) && pixel.grower == false && pixel.leafgrower == false) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        if (pixel.grower == true) {
            // check if left side has stem if no set direction to right
            if (!isEmpty(pixel.x-1,pixel.y) && pixel.direction == "undefined") {
                if (pixelMap[pixel.x-1][pixel.y].element == "vanilla_stem") {
                    pixel.direction = "right";
                }
            }
            // same thing to set direction the left
            else if (!isEmpty(pixel.x+1,pixel.y) && pixel.direction == "undefined") {
                if (pixelMap[pixel.x+1][pixel.y].element == "vanilla_stem") {
                    pixel.direction = "left";
                }
            }
        }
        if (pixel.grower == true) {
            // left
            if (pixel.direction == "left") {
                if (isEmpty(pixel.x-1,pixel.y-1) && Math.random() < 0.1) {
                    createPixel("vanilla_leaves",pixel.x-1,pixel.y-1);
                    if (isEmpty(pixel.x-2,pixel.y-2) && Math.random() < 0.2) {
                        createPixel("vanilla_leaves",pixel.x-2,pixel.y-2);
                        if (isEmpty(pixel.x-3,pixel.y-3) && Math.random() < 0.4) {
                            createPixel("vanilla_leaves",pixel.x-3,pixel.y-3);
                        }
                    }
                }
            }
            // right
            else if (pixel.direction == "right") {
                if (isEmpty(pixel.x+1,pixel.y-1) && Math.random() < 0.1) {
                    createPixel("vanilla_leaves",pixel.x+1,pixel.y-1);
                    if (isEmpty(pixel.x+2,pixel.y-2) && Math.random() < 0.2) {
                        createPixel("vanilla_leaves",pixel.x+2,pixel.y-2);
                        if (isEmpty(pixel.x+3,pixel.y-3) && Math.random() < 0.4) {
                            createPixel("vanilla_leaves",pixel.x+3,pixel.y-3);
                        }
                    }
                }
            }
        }
        pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "grower":false,
        "age":0,
        "direction":"undefined",
    }
}
elements.vanilla_leaves = {
    color: "#5d9c48",
    reactions: {
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
        "yeast": {elem1:"tea", chance:0.01},
    },
    tick: function(pixel) {
        if (isEmpty(pixel.x-1,pixel.y-1) && !isEmpty(pixel.x+1,pixel.y+1) && Math.random() < 0.03) {
            createPixel("vanilla_flower",pixel.x-1,pixel.y-1);
        }
        if (isEmpty(pixel.x+1,pixel.y-1) && !isEmpty(pixel.x-1,pixel.y+1) && Math.random() < 0.03) {
            createPixel("vanilla_flower",pixel.x+1,pixel.y-1);
        }
        pixel.age++;
        doDefaults(pixel);
    },
    behavior: behaviors.WALL,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    tempLow: -2,
    stateLow: "frozen_plant",
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"life",
    state: "solid",
    density: 1400,
    isFood: true,
    hidden:true
},
elements.vanilla_seed = {
    color: "#806d3b",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("vanilla_stem",pixel.x,pixel.y+1);
                    pixel.height++;
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 3) {
                    if (isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("vanilla_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                    }
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 9) {
                    if (isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("vanilla_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                    }
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 6) {
                    if (isEmpty(pixel.x-1,pixel.y)) {
                        createPixel("vanilla_stem",pixel.x-1,pixel.y);
                        pixelMap[pixel.x-1][pixel.y].grower = true;
                    }
                }
                if (pixel.height > 11) {
                    if (isEmpty(pixel.x-1,pixel.y) && isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("vanilla_stem",pixel.x-1,pixel.y);
                        pixelMap[pixel.x-1][pixel.y].grower = true;
                        createPixel("vanilla_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                        deletePixel(pixel.x,pixel.y);
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "height":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.vanilla_flower = {
    color: "#f7f4e1",
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    tick: function(pixel) {
        if (pixel.age > 175 && pixel.pod == true) {
            changePixel(pixel,"vanilla_pod")
        }
        if (isEmpty(pixel.x,pixel.y+1) && Math.random() < 0.03 && pixel.pod == false && pixel.harvested == false) {
            createPixel("vanilla_flower",pixel.x,pixel.y+1);
            pixelMap[pixel.x][pixel.y+1].pod = true;
            if (Math.random < 0.5) {
                pixel.harvested = true;
            }
        }
        pixel.age++
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    properties: {
        "age":0,
        "pod":false,
        "harvested":false,
    }
}

elements.vanilla_pod = {
    color: "#36281d",
    behavior: [
        "XX|ST:vanilla_flower|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
    reactions: {
        "alcohol": { elem1:"vanilla_essence", elem2:null, chance:0.035 },
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
}
elements.ice_cream.reactions = {}
elements.ice_cream.reactions.vanilla_essence = {color1:"#fff7b6", elem2:null, chance:0.35}
elements.vanilla_essence = {
    color: "#9c7211",
    behavior: behaviors.LIQUID,
    tempHigh: 170,
    stateHigh: ["sugar","smoke","smoke"],
    tempLow: 0,
    category:"liquids",
    state: "liquid",
    density: 1400,
}

elements.candy.reactions = {}
elements.candy.reactions.peppermint = {elem1:"peppermint_candy", elem2:null, chance:0.35}
elements.peppermint_candy = {
    color: ["#fa5e3e","#fff5f5"],
    behavior: behaviors.WALL,
    tempHigh: 204.44,
    stateHigh: "smoke",
    category: "food",
    state: "solid",
    density: 850,
    isFood: true
}
elements.tapioca = {
    color: "#ded58e",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "M2 AND CH:dirt,mud,sand,wet_sand,clay_soil,clay,mycelium,grass,color_sand>tapioca,fiber%0.5|M1 AND CH:dirt,mud,sand,wet_sand,clay_soil,clay,mycelium,grass,color_sand>tapioca,fiber,fiber%0.5|M2 AND CH:dirt,mud,sand,wet_sand,clay_soil,clay,mycelium,grass,color_sand>tapioca,fiber%0.5",
    ],
    tempHigh: 275,
    stateHigh: "dirt",
    tempLow: -50,
    stateLow: "fiber",
    burn: 20,
    burnTime: 60,
    burnInto: "dirt",
    breakInto: "corn_starch",
    category: "food",
    state: "solid",
    density: 1250,
    conduct: 0.1,
    hidden: true,
    darkText: true,
    desc:'a wise icyking once said: \'state:"burn 100"\'',
    alias:["element that i made before icyking","burn 100 element"]
}

elements.tapioca_seed = {
    color: "#a78d38",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"tapioca");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("tapioca_stem",pixel.x,pixel.y+1);
                }
                if (isEmpty(pixel.x+1,pixel.y) && Math.random() < 0.2) {
                    createPixel("tapioca_leaves",pixel.x+1,pixel.y);
                }
                if (isEmpty(pixel.x-1,pixel.y) && Math.random() < 0.2) {
                    createPixel("tapioca_leaves",pixel.x-1,pixel.y);
                }
            }
            else if (pixel.age > 250) {
                changePixel(pixel,"tapioca_leaves");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};

elements.tapioca_stem = {
    color: "#358f35",
    behavior: behaviors.STURDYPOWDER,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
}
elements.tapioca_leaves = {
    color: "#3e823e",
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050
}
elements.sprinkle_bomb = {
    color: ["#eb726a", "#ebca6a", "#88eb6a", "#6aaceb", "#eb6ade"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1 AND EX:10>sprinkles|XX",
    ],
    category: "food",
    state: "solid",
    density: 1300,
    excludeRandom: true,
    cooldown: defaultCooldown
}

elements.chilli_stem = {
    color: "#5d9c48",
    behavior: behaviors.WALL,
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "mercury": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "stench": { elem2:null, chance:0.25 },
        "carbon_dioxide": { elem2:"oxygen", chance:0.25 },
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true,
    breakInto: "herb",
    breakIntoColor:"#245c1b",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1) && pixel.grower == false && pixel.leafgrower == false) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        if (pixel.grower == true) {
            // check if left side has stem if no set direction to right
            if (!isEmpty(pixel.x-1,pixel.y) && pixel.direction == "undefined") {
                if (pixelMap[pixel.x-1][pixel.y].element == "chilli_stem") {
                    pixel.direction = "right";
                }
            }
            // same thing to set direction the left
            else if (!isEmpty(pixel.x+1,pixel.y) && pixel.direction == "undefined") {
                if (pixelMap[pixel.x+1][pixel.y].element == "chilli_stem") {
                    pixel.direction = "left";
                }
            }
        }
        if (pixel.grower == true) {
            // left
            if (pixel.direction == "left") {
                if (isEmpty(pixel.x-1,pixel.y-1) && Math.random() < 0.1) {
                    createPixel("chilli_leaves",pixel.x-1,pixel.y-1);
                    if (isEmpty(pixel.x-2,pixel.y-2) && Math.random() < 0.2) {
                        createPixel("chilli_leaves",pixel.x-2,pixel.y-2);
                        if (isEmpty(pixel.x-3,pixel.y-3) && Math.random() < 0.4) {
                            createPixel("chilli_leaves",pixel.x-3,pixel.y-3);
                        }
                    }
                }
            }
            // right
            else if (pixel.direction == "right") {
                if (isEmpty(pixel.x+1,pixel.y-1) && Math.random() < 0.1) {
                    createPixel("chilli_leaves",pixel.x+1,pixel.y-1);
                    if (isEmpty(pixel.x+2,pixel.y-2) && Math.random() < 0.2) {
                        createPixel("chilli_leaves",pixel.x+2,pixel.y-2);
                        if (isEmpty(pixel.x+3,pixel.y-3) && Math.random() < 0.4) {
                            createPixel("chilli_leaves",pixel.x+3,pixel.y-3);
                        }
                    }
                }
            }
        }
        pixel.age++;
        doDefaults(pixel);
    },
    properties: {
        "grower":false,
        "age":0,
        "direction":"undefined",
    }
}
elements.chilli_leaves = {
    color: "#5d9c48",
    reactions: {
        "water": { elem2:"chilli_tea", tempMin:80 },
        "salt_water": { elem2:"chilli_tea", tempMin:80 },
        "sugar_water": { elem2:"chilli_tea", tempMin:80 },
        "seltzer": { elem2:"chilli_tea", tempMin:80 },
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
        "yeast": {elem1:"tea", chance:0.01},
    },
    tick: function(pixel) {
        if (isEmpty(pixel.x-1,pixel.y-1) && !isEmpty(pixel.x+1,pixel.y+1) && Math.random() < 0.03) {
            createPixel("chilli",pixel.x-1,pixel.y-1);
        }
        if (isEmpty(pixel.x+1,pixel.y-1) && !isEmpty(pixel.x-1,pixel.y+1) && Math.random() < 0.03) {
            createPixel("chilli",pixel.x+1,pixel.y-1);
        }
        pixel.age++;
        doDefaults(pixel);
    },
    behavior: behaviors.WALL,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    tempLow: -2,
    stateLow: "frozen_plant",
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"life",
    state: "solid",
    density: 1400,
    isFood: true,
    hidden:true,
    breakInto: "herb",
    breakIntoColor:"#245c1b",
},
elements.chilli_seed = {
    color: "#806d3b",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.1 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel("chilli_stem",pixel.x,pixel.y+1);
                    pixel.height++;
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 3) {
                    if (isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("chilli_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                    }
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 9) {
                    if (isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("chilli_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                    }
                }
                if (pixel.height < 12 && pixel.height > 2 && pixel.height == 6) {
                    if (isEmpty(pixel.x-1,pixel.y)) {
                        createPixel("chilli_stem",pixel.x-1,pixel.y);
                        pixelMap[pixel.x-1][pixel.y].grower = true;
                    }
                }
                if (pixel.height > 11) {
                    if (isEmpty(pixel.x-1,pixel.y) && isEmpty(pixel.x+1,pixel.y)) {
                        createPixel("chilli_stem",pixel.x-1,pixel.y);
                        pixelMap[pixel.x-1][pixel.y].grower = true;
                        createPixel("chilli_stem",pixel.x+1,pixel.y);
                        pixelMap[pixel.x+1][pixel.y].grower = true;
                        deletePixel(pixel.x,pixel.y);
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0,
        "height":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
};
elements.chilli = {
    color: "#ba3030",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "ST:chilli_leaves|M1|ST:chilli_leaves",
    ],
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:15,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    breakInto: "chilli_powder",
    reactions: {
	"sauce": {elem1:null, elem2:"hot_sauce", chance:2}
    },
}
elements.chilli_powder = {
    color: "#a32121",
    reactions: {
        "stench": { elem2:null, chance:0.25 },
        "steam": { elem2:"fragrance", chance:0.1 },
        "flea": { elem2:null, chance:0.01 },
        "termite": { elem2:null, chance:0.01 },
        "fly": { elem2:null, chance:0.01 },
        "ant": { elem2:null, chance:0.01 },
        "stink_bug": { elem2:null, chance:0.01 },
	"sauce": {elem1:null, elem2:"hot_sauce", chance:2}
    },
    behavior: behaviors.POWDER,
    tempHigh: 300,
    stateHigh: ["fire","smoke","smoke","smoke","ash"],
    burn:10,
    burnTime:300,
    burnInto: ["fire","smoke","smoke","smoke","smoke","smoke","smoke","fragrance"],
    category:"food",
    state: "solid",
    density: 1400,
    isFood: true,
}
elements.hot_sauce = {
    color: "#a31414",
    behavior: behaviors.LIQUID,
    reactions: {
        "stench": { elem2:null },
    },
    viscosity: 2600,
    tempHigh: 260,
    stateHigh: ["steam","salt","fragrance"],
    tempLow: -2,
    category:"food",
    state: "liquid",
    density: 1031.33,
    stain: 0.01,
    isFood: true
}
elements.head.reactions.hot_sauce = {elem2:["smoke","fire",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null], chance:3}


elements.durian_wood = {
    color: "#5e4b23",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.durian_branch = {
    color: "#5e4b23",
    behavior: [
        "CR:durian_leaves,durian_branch%2|CR:durian_leaves,durian_branch%2|CR:durian_leaves,durian_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "durian_wood",
    tempLow: -30,
    stateLow: "durian_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
}
elements.durian_leaves = {
    color: ["#326b25","#2e751e"],
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:durian%0.1|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.durian = {
    color: ["#578524","#5b8f1f"],
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    cutInto: "cut_durian",
    state: "solid",
    density: 1050,
    breakInto: "durian_juice"
}

elements.cut_durian = {
    color: ["#e3e04b","#d1cf36"],
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    state: "solid",
    density: 1050,
    hidden: true,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#a19f3b",
    breakInto: "durian_juice"
}

elements.durian_seed = {
    color: "#a17d3b",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "durian_wood" : "durian_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"durian_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};

elements.durian_juice = {
    color: "#ebe06e",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#ebe06e")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    hidden: true,
    tempLow: 0,
};
eLists.JUICEMIXABLE.push("durian_juice");
elements.egg_white = {
    color: "#edece8",
    behavior: behaviors.LIQUID,
    tempHigh: 100,
    stateHigh: "hard_egg_white",
    tempLow: 0,
    stateLow: "hard_egg_white",
    category: "food",
    state: "liquid",
    density: 1027.5,
    viscosity: 270,
    isFood: true,
    whiskInto: "whisked_egg_white",
}
elements.hard_egg_white = {
    color: "#dedddc",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 400,
    stateHigh: "smoke",
    category: "food",
    hidden: true,
    isFood: true,
    state: "solid",
    density: 1031
}
elements.milk.whiskInto = "cream";
elements.cream.whiskInto = "whipped_cream";
elements.egg.breakInto = ["egg_white","egg_white","yolk"]

elements.whisked_egg_white ={
    color: "#fefefe",
    behavior: behaviors.LIQUID,
    reactions: {
        "corn_syrup": { elem1: "marshmallow", elem2: null, chance: 2 },
        "sugar": { elem1: "marshmallow", elem2: null, chance: 2 },
    },
    viscosity: 1.5,
    tempHigh: 1000,
    stateHigh: ["smoke","steam"],
    category: "food",
    hidden: true,
    isFood: true,
    state: "liquid",
    density: 959.97,
}
elements.marshmallow = {
    color: "#fafafa",
    behavior: [
        "XX|XX|XX",
        "ST:wood|XX|ST:wood",
        "XX|M1|XX",
    ],
    viscosity: 1.5,
    tempHigh: 70,
    stateHigh: "cooked_marshmallow",
    category: "food",
    isFood: true,
    state: "solid",
    density: 959.97,
}
elements.cooked_marshmallow = {
    color: "#f0dbb6",
    behavior: [
        "XX|XX|XX",
        "ST:wood|XX|ST:wood",
        "XX|M1|XX",
    ],
    viscosity: 1.5,
    tempHigh: 150,
    stateHigh: "burnt_marshmallow",
    category: "food",
    isFood: true,
    state: "solid",
    density: 959.97,
    hidden:true
}
elements.burnt_marshmallow = {
    color: "#29231a",
    behavior: [
        "XX|XX|XX",
        "ST:wood|XX|ST:wood",
        "XX|M1|XX",
    ],
    viscosity: 1.5,
    tempHigh: 1000,
    stateHigh: ["steam","caramel"],
    category: "food",
    isFood: true,
    state: "solid",
    density: 959.97,
    hidden:true
}
eLists.FOODCOLORINGIGNORE = ["glass", "porcelain", "wall","iron","steel","copper","silver","aluminum","tungsten","gold","plastic"];
elements.food_coloring = {
    color: ["#ff0000", "#ff8800", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff"],
    behavior: behaviors.LIQUID,
    customColor: true,
    stain: 0.5,
    tempHigh: 100,
    stateHigh: "steam",
    category: "food",
    state: "liquid",
    density: 998,
    stainSelf: true,
    ignore: ["glass", "porcelain", "wall","iron","steel","copper","silver","aluminum","tungsten","gold","plastic"],
    desc: "coloring for food. color may fade when diluting with water.",
    onMix: function (pixel) {
        for (var i = 0; i < squareCoords.length; i++) {
            var coord = squareCoords[i];
            var x = pixel.x + coord[0];
            var y = pixel.y + coord[1];
            if (!isEmpty(x, y, true)) {
                if (pixelMap[x][y].element === "water" || pixelMap[x][y].element === "salt_water" || pixelMap[x][y].element === "sugar_water" || pixelMap[x][y].element === "seltzer" || pixelMap[x][y].element === "dirty_water" || pixelMap[x][y].element === "pool_water") {
                    changePixel(pixelMap[x][y], "food_coloring");
                    let newrgb = interpolateRgb(getRGB(pixel.color), getRGB(pixelMap[x][y].color), 0.5);
                    pixel.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
                    pixelMap[x][y].color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
                }
		    	else {
                    if (!outOfBounds(pixelMap[x][y])) {
                        if (!eLists.FOODCOLORINGIGNORE.includes(pixelMap[x][y].element) && pixelMap[x][y].element !== "glass" && pixelMap[x][y].element !== "porcelain" && pixelMap[x][y].element !== "wall" && pixelMap[x][y].element !== "plastic") {
                            let newrgb2 = interpolateRgb(getRGB(pixel.color), getRGB(pixelMap[x][y].color), 0.9);
                            pixelMap[x][y].color = `rgb(${parseInt(newrgb2.r)},${parseInt(newrgb2.g)},${parseInt(newrgb2.b)})`;
                            if (Math.random() < 0.002) {
                                deletePixel(pixel.x,pixel.y)
                            }
                        }
                    }
                }
            }
        }
    },
    onSelect: function () {
        logMessage("Tip: You can spread food coloring using water.");
    },
}

elements.cooked_meat.behavior = behaviors.SUPPORT;

elements.cake_batter = {
    color: "#d4bc85",
    behavior: behaviors.LIQUID,
    onMix: function(batter,ingredient) {
        if (elements[ingredient.element].isFood && elements[ingredient.element].id !== elements.batter.id && elements[ingredient.element].id !== elements.flour.id && elements[ingredient.element].id !== elements.yolk.id && elements[ingredient.element].id !== elements.dough.id && elements[ingredient.element].id !== elements.baked_batter.id && elements[ingredient.element].id !== elements.cake.id && elements[ingredient.element].id !== elements.cake_batter.id) {
            var rgb1 = batter.color.match(/\d+/g);
            var rgb2 = ingredient.color.match(/\d+/g);
            // average the colors
            var rgb = [
                Math.round((parseInt(rgb1[0])*10+parseInt(rgb2[0]))/11),
                Math.round((parseInt(rgb1[1])*10+parseInt(rgb2[1]))/11),
                Math.round((parseInt(rgb1[2])*10+parseInt(rgb2[2]))/11)
            ];
            // convert rgb to hex
            var hex = RGBToHex(rgb);
            batter.color = pixelColorPick(batter, hex);
            if ((elements[ingredient.element].density > elements.batter.density || shiftDown) && Math.random() < 0.05) {
                // 50% change to delete ingredient
                if (Math.random() < 0.5) { deletePixel(ingredient.x, ingredient.y); }
                else {
                    ingredient.color = pixelColorPick(ingredient, hex);
                }
            }
        }
    },
    reactions: {
        "cream": { elem2:"cake_batter", tempMin:40, chance:0.01 },
    },
    category: "food",
    tempHigh: 94,
    stateHigh: "cake",
    stateHighColorMultiplier: 0.9,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "liquid",
    viscosity: 10000,
    density: 1001,
    hidden: true,
    isFood: true
}
elements.batter.whiskInto = "cake_batter";
elements.milk.stateHigh = ["steam","steam","condensed_milk"];
elements.condensed_milk = {
    color: "#f2f0df",
    behavior: behaviors.LIQUID,
    reactions: {
        "cell": { elem1:"yogurt", chance:0.1 },
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "caramel": { color1:"#C8B39A", elem2:null, chance:0.05 },
        "sugar": { color1:"#fffbf0", elem2:null, chance:0.5},
    },
    tempLow: 0,
    stateLow: "ice_cream",
    stateLowColorMultiplier: [0.97,0.93,0.87],
    tempHigh: 500,
    stateHigh: ["smoke","smoke","smoke","quicklime"],
    viscosity: 1500,
    category: "food",
    state: "liquid",
    density: 1036.86,
    isFood: true,
    alias: "evaporated_milk"
}
elements.wasabi = {
    color: ["#82b55b","#6cad50","#7dcc5c"],
    behavior: behaviors.STURDYPOWDER2,
    reactions: {
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "clay_soil": { elem1: null, elem2: "clay" },
        "melted_chocolate": { color1:"#664934", elem2:null },
        "chocolate": { color1:"#664934", elem2:"melted_chocolate", chance:0.05 },
        "juice": { elem1:"fruit_milk", elem2:null, chance:0.05 },
        "soda": { elem1:"pilk", elem2:null, chance:0.1 },
        "yolk": { elem1:"#eggnog", elem2:null, chance:0.1 },
        "caramel": { color1:"#C8B39A", chance:0.05 },
        "sugar": { elem2:null, chance:0.005},
    },
    viscosity: 1.5,
    tempHigh: 1000,
    stateHigh: ["smoke","smoke","smoke","steam","steam"],
    category: "food",
    isFood: true,
    state: "solid",
    density: 959.97,
}
// extremely confused part
elements.beans.name = "baked_beans";
elements.real_beans = {
    name: "beans",
    color: ["#e8dfc5","#d1c7ab"],
    behavior: behaviors.POWDER,
    category: "food",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    reactions: {
        "sauce": { elem1: "beans", elem2: "beans" },
        "yeast": { elem1: "fermented_beans", elem2: null, chance:0.5 }
    },
    state: "solid",
    density: 721,
    isFood: true,
    alias: "soy_beans"
}
elements.fermented_beans = {
    color:"#ada386",
    behavior: behaviors.POWDER,
    category: "food",
    tempHigh: 350,
    stateHigh: ["fire","fire","ash"],
    burn:3,
    burnTime:500,
    burnInto: ["fire","smoke","smoke","steam","ash"],
    state: "solid",
    density: 721,
    breakInto: "soy_sauce",
    isFood: true,
    alias: "natto"
}
elements.soy_sauce = {
    color: "#480601",
    behavior: behaviors.LIQUID,
    tempLow: -5,
    tempHigh: 105,
    stateHigh: ["steam","steam","salt"],
    state: "liquid",
    category:"food",
    density: 1200,
};
// end of confused part

elements.ice.breakInto = "slush";

elements.cracker_dough = {
    color: "#dbd19a",
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    tempHigh: 94,
    stateHigh: "cracker",
    stateHighColorMultiplier: 1.1,
    burn:40,
    burnTime:25,
    burnInto:"ash",
    state: "solid",
    density: 526.9,
    isFood: true,
    hidden: true
}

elements.cracker = {
    color: "#e0ddb8",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 605,
    stateHigh: "ash",
    category: "food",
    burn: 30,
    burnTime: 200,
    burnInto: ["smoke","smoke","smoke","ash"],
    breakInto: "crumb",
    state: "solid",
    density: 233.96,
    isFood: true
}

elements.agar = {
    color: "#e0e0e0",
    behavior: behaviors.POWDER,
    reactions: {
        "ice": { elem1:null, elem2:"salt_water", chance:0.1 },
        "rime": { elem1:null, elem2:"salt_water", chance:0.075 },
        "snow": { elem1:null, elem2:"salt_water", chance:0.25 },
        "packed_snow": { elem1:null, elem2:"salt_water", chance:0.05 },
        "packed_ice": { elem1:null, elem2:"salt_water", chance:0.01 }
    },
    category: "food",
    tempHigh: 801,
    state: "solid",
    density: 2160,
    alias: "gelatin"
}
// thanks to adora
elements.agar.reactions.juice = { elem1:"jelly", elem2:null, chance:0.05, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB('rgb(250,250,250)'), getRGB(pixel2.color), 0.7);
    pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
}}
elements.agar.reactions.water = {elem1:"jelly",elem2:null,color1:"#e0e0e0",chance:0.05}

elements.duck = {
    color: ["#826c4e", "#2b5927", "#d6d6d6", "#7d4a2c"],
    behavior: [
        "M2%1 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%1|M2%2 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%50|M2%1 AND SW:water,salt_water,sugar_water,dirty_water,seltzer,pool_water,primordial_soup%1",
        "M2%10|XX|M2%10",
        "XX|M1%33|XX",
    ],
    category:"life",
	state: "solid",
    reactions: {
        "meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "chicken_nugget": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "worm": { elem2: "crushed_worm", chance:0.3},
        "cooked_meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "fish": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "rat": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "snail": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "frog": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "wheat_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "flower_seed": { elem2:null, chance:0.32, func:behaviors.FEEDPIXEL },
        "corn_seed": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "potato_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "grass_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "dead_bug": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "bee": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "ant": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "flea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "termite": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    },
    egg: "duck_egg",
    foodNeed: 10,
    temp: 40,
    tempHigh: 75,
    stateHigh: "cooked_duck",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "raw_duck",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 1117,
    conduct: 0.3,
    cutInto: "raw_duck",
};

elements.duck_egg = {
    color: "#e0d3ab",
    behavior: behaviors.STURDYPOWDER2,
    tick: function(pixel) {
        if (Math.random() < 0.1 && pixel.temp > 20 && pixel.temp < 35) {
            changePixel(pixel,"duckling")
        }
    doDefaults(pixel);
    },
    category: "food",
    state: "solid",
    temp: 20,
    tempLow: -18,
    stateLow: "frozen_duck_egg",
    breakInto: ["yolk"],
    tempHigh: 400,
    stateHigh: ["calcium", "ash"],
    burn:50,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    reactions: {
        "water": { elem2:null, elem1:"hard_boiled_egg", chance:10, tempMin:80 }
    }
};
elements.frozen_duck_egg = {
    color: "#e0d3cf",
    behavior: behaviors.POWDER,
    category: "food",
    state: "solid",
    temp: -20,
    tempHigh: 10,
    stateHigh: "duck_egg",
    breakInto: ["calcium", "hard_yolk"],
    burn:50,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    hidden: true,
};
elements.duckling = {
    color: ["#f0eba8", "#f0eba8"],
    behavior: [
        "M2%1|M2%2|M2%1",
        "M2%10|FX%5 AND CH:duck%0.1|M2%10",
        "XX|M1%33|XX",
    ],
    category: "life",
    state: "solid",
    egg: "duck_egg",
    foodNeed: 20,
    temp: 40,
    tempHigh: 75,
    stateHigh: "cooked_meat",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "blood",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    reactions: {
        "crushed_worm": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL},
        "meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "chicken_nugget": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "worm": { elem2: "crushed_worm", chance:0.3},
        "cooked_meat": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "fish": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "rat": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "snail": { elem2:null, chance:0.05, func:behaviors.FEEDPIXEL },
        "frog": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "slug": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "wheat_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "flower_seed": { elem2:null, chance:0.32, func:behaviors.FEEDPIXEL },
        "corn_seed": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "corn": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "crumb": { elem2:null, chance:0.25, func:behaviors.FEEDPIXEL },
        "potato_seed": { elem2:null, chance:0.4, func:behaviors.FEEDPIXEL },
        "grass_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "dead_bug": { elem2:null, chance:0.35, func:behaviors.FEEDPIXEL },
        "bee": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "ant": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "flea": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "termite": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    }
};

elements.barbecued_duck = {
    color:["#a67d2d","#9c721f"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.steamed_duck = {
    color:["#e8cb7b", "#d6bf7e"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:50,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}

elements.smoked_duck = {
    color:["#6b470e", "#8f5b09"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.cooked_duck = {
    color: ["#a38046", "#b39652"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
};

elements.raw_duck = {
    color: ["#d6a587", "#c99873"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "cooked_duck",
    temp:25,
    tempHigh: 600,
    stateHigh: ["cooked_duck"],
    reactions: {
        "smoke": {elem1: "smoked_duck"},
        "steam": {elem1: "steamed_duck"},
        "water": {elem1: "boiled_duck", tempMin: 70},
        "nut_oil": {elem1: "fried_duck", tempMin: 70},
        "charcoal": {elem1: "barbecued_duck", tempMin: 70},
        "fire": {elem1: "barbecued_duck"}
    }
};

elements.boiled_duck = {
    color: ["#e0d4a4", "#e0d4a4"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 65,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
}

elements.fried_duck = {
    color: ["#c49543", "#b88835", "#b07b20", "#996e23"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 90,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
}
// side note: i don't eat beef
elements.cow = {
    color: ["#292928", "#332b23", "#e0dfde", "#f0edeb"],
    behavior: [
        "M2%1|XX|M2%1",
        "M2%10|XX|M2%10",
        "XX|M1|XX",
    ],
    category:"life",
	state: "solid",
    reactions: {
        "petal": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    },
    egg: "calf",
    foodNeed: 10,
    temp: 40,
    tempHigh: 75,
    stateHigh: "steak",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "raw_beef",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 1117,
    conduct: 0.3,
    cutInto: "raw_beef",
};
elements.calf = {
    color: ["#363535", "#bdbdbd"],
    behavior: [
        "M2%1|XX|M2%1",
        "M2%10|FX%5 AND CH:cow%0.1|M2%10",
        "XX|M1|XX",
    ],
    category: "life",
    state: "solid",
    foodNeed: 20,
    temp: 40,
    tempHigh: 75,
    stateHigh: "steak",
    tempLow: -18,
    stateLow: "frozen_meat",
    breakInto: "blood",
    burn:85,
    burnTime:450,
    state: "solid",
    density: 900,
    conduct: 0.1,
    reactions: {
        "petal": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "grass": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "grape": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin_seed": { elem2:null, chance:0.3, func:behaviors.FEEDPIXEL },
        "pumpkin": { elem2:null, chance:0.1, func:behaviors.FEEDPIXEL },
        "nut": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "lichen": { elem2:null, chance:0.2, func:behaviors.FEEDPIXEL },
        "oxygen": { elem2:"carbon_dioxide", chance:0.3 },
        "mercury": { elem1:"rotten_meat", chance:0.1 },
        "bleach": { elem1:"rotten_meat", chance:0.1 },
        "infection": { elem1:"rotten_meat", chance:0.025 },
        "uranium": { elem1:"rotten_meat", chance:0.1 },
        "cyanide": { elem1:"rotten_meat", chance:0.1 },
        "chlorine": { elem1:"meat", chance:0.1 },
        "dirty_water": { elem1:"rotten_meat", chance:0.0001 },
    },
};

elements.barbecued_steak = {
    color:["#3b271a","#29180d"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}

elements.smoked_beef = {
    color:["#3b1911", "#3b2719"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.steak = {
    color: ["#a38046", "#b39652"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
    alias: "cooked_beef"
};

elements.raw_beef = {
    color: ["#ab5841", "#ab322e"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "steak",
    temp:25,
    tempHigh: 200,
    stateHigh: "steak",
    reactions: {
        "smoke": {elem1: "smoked_beef"},
        "charcoal": {elem1: "barbecued_beef", tempMin: 70},
        "fire": {elem1: "barbecued_beef"}
    }
};

elements.juice.reactions.milk = { elem1:"fruit_milk", elem2:null, chance:0.05, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB('rgb(250,250,250)'), getRGB(pixel2.color), 0.25);
    pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
}}
elements.juice.reactions.cream = { elem1:"fruit_milk", elem2:null, chance:0.05, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB('rgb(250,250,250)'), getRGB(pixel2.color), 0.25);
    pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
}}
elements.soda.reactions.soda = {
    func: function(pixel1, pixel2){
      if(pixel1.color != pixel2.color){
        if(Math.floor(Math.random() * 1000) == 1){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.5);
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
      }
    }
  }
elements.juice.reactions.soda = {
    chance:70,
    func: function(pixel1, pixel2){
        if(pixel1.color != pixel2.color){
            if(Math.floor(Math.random() * 1000) == 1){
                let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.5);
                changePixel(pixelMap[pixel1.x][pixel1.y],"soda")
                pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
                pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            }
        }
    }
}
if (!elements.orange_juice.reactions) { elements.orange_juice.reactions = {} }
elements.orange_juice.reactions.seltzer = { elem1:"soda", elem2:"foam", color1:"#ffb319"}
elements.orange_juice.reactions.carbon_dioxide = { elem1:"soda", elem2:"foam", color1:"#ffb319"}
elements.agar.reactions.soda = { elem1:"jelly", elem2:null, chance:0.05, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB('rgb(250,250,250)'), getRGB(pixel2.color), 0.7);
    pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
}}
elements.hard_jelly = {
    color: "#c372b8",
    behavior: behaviors.STURDYPOWDER,
    tempHigh: 200,
    stateHigh: ["smoke","sugar"],
    category: "food",
    state: "solid",
    density: 1245,
    isFood: true,
    hidden: true,
    temp: 0
}
elements.jelly.stateLow = "hard_jelly"
elements.jelly.stateLowColorMultiplier = 1.2
elements.jelly.temp = 0

elements.nut.name = "peanut";
elements.nut_meat.name = "peanut_meat";
elements.nut_butter.name = "peanut_butter";

elements.spring_onion_leaves = {
    color: "#519c2f",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "ST:onion|M1|ST:onion",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "herb",
    state: "solid",
    density: 1050,
    cutInto: "chopped_spring_onion",
}
elements.chopped_spring_onion = {
    color: ["#0f9912","#227d23"],
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: "dead_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    state: "solid",
    density: 1050,
    breakInto:"herb",
}


elements.spring_onion_seed = {
    color: "#1a0e02",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.2 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-2) && isEmpty(pixel.x,pixel.y-1) && isEmpty(pixel.x+1,pixel.y-1) && isEmpty(pixel.x-1,pixel.y-1) && isEmpty(pixel.x+1,pixel.y) && isEmpty(pixel.x-1,pixel.y)) {
                    createPixel("onion",pixel.x,pixel.y-1);
                    createPixel("onion",pixel.x+1,pixel.y-1);
                    createPixel("onion",pixel.x-1,pixel.y-1);
                    createPixel("onion",pixel.x,pixel.y-2);
                    createPixel("onion",pixel.x+1,pixel.y);
                    createPixel("onion",pixel.x-1,pixel.y);
                    if (isEmpty(pixel.x+1,pixel.y-3) && isEmpty(pixel.x-1,pixel.y-3)) {
                        createPixel("spring_onion_leaves",pixel.x+1,pixel.y-3);
                        createPixel("spring_onion_leaves",pixel.x-1,pixel.y-3);
                        if (isEmpty(pixel.x+1,pixel.y-4) && isEmpty(pixel.x-1,pixel.y-4)) {
                            createPixel("spring_onion_leaves",pixel.x+1,pixel.y-4);
                            createPixel("spring_onion_leaves",pixel.x-1,pixel.y-4);
                            if (isEmpty(pixel.x+1,pixel.y-5) && isEmpty(pixel.x-1,pixel.y-5)) {
                                createPixel("spring_onion_leaves",pixel.x+1,pixel.y-5);
                                createPixel("spring_onion_leaves",pixel.x-1,pixel.y-5);
                            }
                        }
                        changePixel(pixel,"onion");
                    }
                }
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|M1|XX",
    ],
}

elements.stainless_steel ={
    color: "#91999e",
    behavior: behaviors.WALL,
    tempHigh: 1455.5,
    category: "solids",
    density: 7850,
    conduct: 0.42,
    hardness: 0.8
} 

elements.rambutan_wood = {
    color: "#635418",
    behavior: behaviors.WALL,
    tempHigh: 400,
    stateHigh: ["ember","charcoal","fire","fire","fire"],
    category: "solids",
    burn: 5,
    burnTime: 300,
    burnInto: ["ember","charcoal","fire"],
    state: "solid",
    hardness: 0.15,
    breakInto: "sawdust",
    breakIntoColor: ["#dba66e","#cc8a64"],
    hidden: true
}
elements.rambutan_branch = {
    color: "#635418",
    behavior: [
        "CR:rambutan_leaves,rambutan_branch%2|CR:rambutan_leaves,rambutan_branch%2|CR:rambutan_leaves,rambutan_branch%2",
        "XX|XX|XX",
        "XX|XX|XX",
    ],
    tempHigh: 100,
    stateHigh: "rambutan_wood",
    tempLow: -30,
    stateLow: "rambutan_wood",
    category: "life",
    burn: 40,
    burnTime: 50,
    burnInto: ["sap","ember","charcoal"],
    hidden: true,
    state: "solid",
    density: 1500,
    hardness: 0.15,
    breakInto: ["sap","sawdust"],
}
elements.rambutan_leaves = {
    color: "#6fa611",
    behavior: [
        "XX|XX|XX",
        "XX|XX|XX",
        "XX|CR:unripe_rambutan%0.1|XX",
    ],
    reactions: {
        "vinegar": { elem1:"dead_plant", elem2:null, chance:0.035 },
        "baking_soda": { elem1:"dead_plant", elem2:null, chance:0.01 },
        "bleach": { elem1:"dead_plant", elem2:null, chance:0.05 },
        "alcohol": { elem1:"dead_plant", elem2:null, chance:0.035 }
    },
    category:"life",
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -1.66,
    stateLow: "frozen_plant",
    burn:65,
    burnTime:60,
    burnInto: "dead_plant",
    breakInto: "dead_plant",
    state: "solid",
    density: 1050,
    hidden: true
}
elements.unripe_rambutan = {
    color: ["#87c718","#8ac91c","#94de1d"],
    behavior: [
        "XX|ST:rambutan_leaves|XX",
        "XX|CH:rambutan%1|XX",
        "M2|M1|M2",
    ],
    category:"food",
    tempHigh: 100,
    stateHigh: ["dead_plant","steam"],
    burn:65,
    burnTime:60,
    cutInto: "cut_rambutan",
    state: "solid",
    density: 1050,
    breakInto: "rambutan_juice"
}

elements.rambutan = {
    color: ["#d64242","#f23333","#cc3737","#b1db69"],
    behavior: behaviors.POWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    state: "solid",
    density: 1050,
    cutInto: "cut_rambutan",
    breakInto: "rambutan_juice"
}

elements.cut_rambutan = {
    color: "#f5f1bf",
    behavior: behaviors.STURDYPOWDER,
    category:"food",
    tempHigh: 100,
    stateHigh: ["sugar","steam"],
    burn:65,
    burnTime:60,
    state: "solid",
    density: 1050,
    hidden: true,
    freezeDryInto: "freeze_dried_fruits",
    freezeDryIntoColor: "#a19f3b",
    breakInto: "rambutan_juice"
}

elements.rambutan_seed = {
    color: "#2b1807",
    tick: function(pixel) {
        if (isEmpty(pixel.x,pixel.y+1)) {
            movePixel(pixel,pixel.x,pixel.y+1);
        }
        else {
            if (Math.random() < 0.02 && pixel.age > 50 && pixel.temp < 100) {
                if (!outOfBounds(pixel.x,pixel.y+1)) {
                    var dirtPixel = pixelMap[pixel.x][pixel.y+1];
                    if (dirtPixel.element === "dirt" || dirtPixel.element === "mud" || dirtPixel.element === "sand" || dirtPixel.element === "wet_sand" || dirtPixel.element === "clay_soil" || dirtPixel.element === "mycelium") {
                        changePixel(dirtPixel,"root");
                    }
                }
                if (isEmpty(pixel.x,pixel.y-1)) {
                    movePixel(pixel,pixel.x,pixel.y-1);
                    createPixel(Math.random() > 0.5 ? "rambutan_wood" : "rambutan_branch",pixel.x,pixel.y+1);
                }
            }
            else if (pixel.age > 1000) {
                changePixel(pixel,"rambutan_wood");
            }
            pixel.age++;
        }
        doDefaults(pixel);
    },
    properties: {
        "age":0
    },
    tempHigh: 100,
    stateHigh: "dead_plant",
    tempLow: -2,
    stateLow: "frozen_plant",
    burn: 65,
    burnTime: 15,
    category: "life",
    state: "solid",
    density: 1500,
    cooldown: defaultCooldown,
    seed: true,
    behavior: [
        "XX|XX|XX",
        "XX|FX%10|XX",
        "XX|M1|XX",
    ],
};

elements.rambutan_juice = {
    color: "#f7f4cb",
    onMix: function(pixel) {
        if (shiftDown) {
            if (Math.random() < 0.2) {
                changePixel(pixel,"juice")
                pixel.color = pixelColorPick(pixel,"#f7f4cb")
            }
        }
    },
    behavior: behaviors.LIQUID,
    category: "liquids",
    tempHigh: 100,
    stateHigh: ["steam","sugar"],
    burn: 70,
    burnTime: 300,
    burnInto: ["steam", "smoke"],
    state: "liquid",
    density: 825,
    hidden: true,
    temp: 30,
    hidden: true,
    tempLow: 0,
};
eLists.JUICEMIXABLE.push("rambutan_juice");

elements.barbecued_shrimp = {
    color:["#bf743b", "#b57026","#8f5e29","#a87b11"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.steamed_shrimp = {
    color:["#e8dab2", "#e2cea6"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:50,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.smoked_shrimp = {
    color:["#78542e", "#6b4b26"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:55,
    tempHigh: 600,
    stateHigh: ["ash","smoke"],
    isFood: true,
    hidden: true,
}
elements.cooked_shrimp = {
    color:["#ff7f50", "#ffa07a", "#ffb3a7"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
};

elements.raw_shrimp = {
    color: ["#f0e0d6", "#e8d9ce", "#cdb7b5"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    burnInto: "cooked_shrimp",
    temp:25,
    tempHigh: 600,
    stateHigh: "cooked_shrimp",
    reactions: {
        "batter": { elem1: "battered_shrimp", elem2: null },
        "smoke": {elem1: "smoked_shrimp"},
        "steam": {elem1: "steamed_shrimp"},
        "water": {elem1: "boiled_shrimp", tempMin: 70},
        "nut_oil": {elem1: "fried_shrimp", tempMin: 70},
        "charcoal": {elem1: "barbecued_shrimp", tempMin: 70},
        "fire": {elem1: "barbecued_shrimp"}
    }
};

elements.boiled_shrimp = {
    color: ["#ffd180", "#ffc978", "#ffbe70"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    isFood: true,
    temp: 65,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    hidden: true,
}
elements.battered_shrimp = {
    color: ["#f2e7d5", "#eae0cd"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp:25,
    tempHigh: 125,
    stateHigh: "cooked_shrimp",
    reactions: {
        "crumb": { color1: "#123456", elem2: null },
        "nut_oil": {elem1: "tempura", tempMin: 60}
    },
    hidden: true,
};
elements.tempura = {
    color: ["#ff8c00", "#ff8c00", "#ffab00", "#ffab00"],
    behavior: behaviors.STURDYPOWDER,
    category: "food",
    state: "solid",
    temp: 40,
    tempHigh: 600,
    stateHigh: ["ash", "smoke"],
    breakInto: "crumb",
    isFood: true,
    density: 100,
    hidden: true,
};

elements.grape.stateHigh = "raisin"
elements.grape.tempHigh = 65

elements.raisin = {
    color: ["#522D68","#3B194D","#381845","2B194D"],
    behavior: [
        "XX|ST:vine|XX",
        "ST:vine|XX|ST:vine",
        "M2|M1|M2",
    ],
    reactions: {
        "radiation": { elem1:"explosion", chance:0.1, color1:"#291824" },
        "rock": { elem1:"juice", chance:0.1, color1:"#291824" },
        "concrete": { elem1:"juice", chance:0.1, color1:"#291824" },
        "basalt": { elem1:"juice", chance:0.1, color1:"#291824" },
        "limestone": { elem1:"juice", chance:0.1, color1:"#291824" },
        "tuff": { elem1:"juice", chance:0.1, color1:"#291824" },
        "water": { elem2:"juice", chance:0.005, color2:"#291824" },
        "sugar_water": { elem2:"juice", chance:0.025, color2:"#291824" },
        "acid": { elem1:"juice", color1:"#291824" },
        "acid_gas": { elem1:"juice", color1:"#291824" },
    },
    innerColor: "#cc7492",
    tempHigh: 256,
    stateHigh: ["steam","sugar"],
    category: "food",
    state: "solid",
    density: 1154,
    breakInto: "juice",
    breakIntoColor: "#291824",
    ignoreAir: true,
    isFood: true
}

elements.fruit_slush = {
    color: "#ed93a4",
    behavior: behaviors.LIQUID,
    reactions: {
        "dirt": { elem1: null, elem2: "mud" },
        "sand": { elem1: null, elem2: "wet_sand" },
        "uranium": { elem1:"dirty_water", chance:0.25 },
    },
    temp: -5,
    tempHigh: 18,
    tempLow: -20,
    stateLow: "juice_ice",
    stateHigh: "juice",
    category: "food",
    state: "liquid",
    density: 95,
    viscosity: 100,
    hidden: true
}

// things to mix: juice, water, seltzer, sugar water, soda, juice, milk, cream,
// juice, milk, chocolate milk, fruit milk, eggnog, nut milk, alcohol, wine, tea,
// tea, coffee, honey, caramel, vanilla essence, peppermint tea, sugar, yogurt, 
// whipped cream, chocolate, jam

// juice mixing
for (let juicei = 0; juicei < eLists.JUICEMIXABLE.length; juicei++) {
    elem = eLists.JUICEMIXABLE[juicei];
    // juice with juice
    for (let juicej = 0; juicej < eLists.JUICEMIXABLE.length; juicej++) {
        elem2 = eLists.JUICEMIXABLE[juicej];
        if (elem != elem2) {
            if (!elements[elem].reactions) { chance:1, elements[elem].reactions = {} }
            elements[elem].reactions[elem2] = { func: function(pixel1, pixel2){
                let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.5);
                changePixel(pixel1,"juice")
                pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
                pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
                // console.log("juice mixed")
            }}
        }
    }
    // juice with water
    if (!elements[elem].reactions) { elements[elem].reactions = {} }
    elements[elem].reactions.water = { chance:1, func: function(pixel1, pixel2){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB("rgb(255,255,255)"), 0.2);
        if (((newrgb.r + newrgb.g + newrgb.b) / 3) > 215) {
            newrgb = getRGB(pixel1.color);
        }
        changePixel(pixel1,"juice")
        changePixel(pixel2,"juice")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }}
    // juice with milk
    if (!elements[elem].reactions) { elements[elem].reactions = {} }
    elements[elem].reactions.milk = { chance:1, func: function(pixel1, pixel2){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        changePixel(pixel1,"fruit_milk")
        changePixel(pixel2,"fruit_milk")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }}
    // juice with coconut milk
    if (!elements[elem].reactions) { elements[elem].reactions = {} }
    elements[elem].reactions.coconut_milk = { chance:1, func: function(pixel1, pixel2){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        changePixel(pixel1,"fruit_milk")
        changePixel(pixel2,"fruit_milk")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }}
    // juice with nut milk
    if (!elements[elem].reactions) { elements[elem].reactions = {} }
    elements[elem].reactions.nut_milk = { chance:1, func: function(pixel1, pixel2){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        changePixel(pixel1,"fruit_milk")
        changePixel(pixel2,"fruit_milk")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }}
    // juice with cream
    if (!elements[elem].reactions) { elements[elem].reactions = {} }
    elements[elem].reactions.cream = { chance:1, func: function(pixel1, pixel2){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        changePixel(pixel1,"fruit_milk")
        changePixel(pixel2,"fruit_milk")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }}
    // juice with fruit milk
    if (!elements[elem].reactions) { elements[elem].reactions = {} }
    elements[elem].reactions.fruit_milk = { chance:1, func: function(pixel1, pixel2){
        let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        changePixel(pixel1,"fruit_milk")
        changePixel(pixel2,"fruit_milk")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }}
}

iceelem = elem+"_ice"
// ice slush
elements[elem].stateLowColorMultiplier = 1.2;
elements[elem].tempLow = 10;
elements.fruit_slush.stateHighColorMultiplier = 0.83333333333;
elements.fruit_slush.stateLowColorMultiplier = 1.2;
elements.juice_ice.stateHighColorMultiplier = 0.83333333333;
elements.juice_ice.stateHigh = "fruit_slush"
elements.juice_ice.tempHigh = -20
if(elements[iceelem]) {
	elements[iceelem].stateHigh = "fruit_slush"
	elements[iceelem].tempHigh = -20
}

// fruit milk with milk
elements.fruit_milk.reactions ??= {}; elements.fruit_milk.reactions.milk = { chance:1, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        if (((newrgb.r + newrgb.g + newrgb.b) / 3) < 230) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        } else if (Math.random() < 0.05) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
    }
}
// fruit milk with nut milk
elements.fruit_milk.reactions.nut_milk = { chance:1, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        if (((newrgb.r + newrgb.g + newrgb.b) / 3) < 230) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        } else if (Math.random() < 0.05) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
    }
}
// fruit milk with coconut milk
elements.fruit_milk.reactions.coconut_milk = { chance:1, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        if (((newrgb.r + newrgb.g + newrgb.b) / 3) < 230) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        } else if (Math.random() < 0.05) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
    }
}
// fruit milk with cream
elements.fruit_milk.reactions.cream = { chance:1, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        if (((newrgb.r + newrgb.g + newrgb.b) / 3) < 230) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        } else if (Math.random() < 0.05) {
            changePixel(pixel1,"fruit_milk")
            changePixel(pixel2,"fruit_milk")
            pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
            pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
    }
}
// fruit milk with fruit milk
elements.fruit_milk.reactions.fruit_milk = { chance:1, func: function(pixel1, pixel2){
    let newrgb = interpolateRgb(getRGB(pixel1.color), getRGB(pixel2.color), 0.2);
        changePixel(pixel1,"fruit_milk")
        changePixel(pixel2,"fruit_milk")
        pixel1.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
    }
}
// fruit milk onMix
elements.fruit_milk.onMix = function(pixel){
    let num = Math.floor(Math.random() * 4);
    let x = pixel.x + adjacentCoords[num][0];
    let y = pixel.y + adjacentCoords[num][1];
    if(!isEmpty(x,y) && !outOfBounds(x,y)){
      let pixel2 = pixelMap[x][y];
      if(pixel.color != pixel2.color && pixel2.element == "fruit_milk"){
        let condition;
        if(shiftDown == 0){
          condition = (Math.floor(Math.random() * 2) == 1); 
        } else {
          condition = true; 
        }
        if(condition){
          let newrgb = interpolateRgb(getRGB(pixel.color), getRGB(pixel2.color), 0.5);
          pixel.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
          pixel2.color = `rgb(${parseInt(newrgb.r)},${parseInt(newrgb.g)},${parseInt(newrgb.b)})`;
        }
      }
    }
  }
  var mods_to_include = ["mods/sbstuff.js","mods/ketchup_mod.js","mods/morefoodsmod.js","mods/weAllScreamFor.js","mods/soups.js","mods/pizzasstuff.js","mods/community_desserts.js","mods/plants.js","mods/aChefsDream2.js"]

var mods_included = mods_to_include.map(mod => enabledMods.includes(mod));
var all_mods_included = mods_included.reduce(function(a,b) { return a && b });

if(!all_mods_included) {
    var mods_needed = mods_to_include.filter(function(modPath) { return !(enabledMods.includes(modPath)) });

    mods_needed.forEach(function(modPath) {
		enabledMods.splice(enabledMods.indexOf("mods/food_mods"),0,modPath);
	});
	localStorage.setItem("enabledMods", JSON.stringify(enabledMods));
	alert(`The following mods have been inserted: ${mods_needed.join(", ")}
Reload the page for the mods to take effect. Happy cooking!`)
}